<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>现代游戏引擎 - GPU驱动的几何管线-Nanite（二十二）</title>
      <link href="/posts/647e170e.html"/>
      <url>/posts/647e170e.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍（Introduction）"><a href="#介绍（Introduction）" class="headerlink" title="介绍（Introduction）"></a>介绍（Introduction）</h2><h3 id="传统渲染管道（Traditional-Rendering-Pipeline）"><a href="#传统渲染管道（Traditional-Rendering-Pipeline）" class="headerlink" title="传统渲染管道（Traditional Rendering Pipeline）"></a>传统渲染管道（Traditional Rendering Pipeline）</h3><p>Nanite是虚幻5引擎中提出的虚拟几何系统用来实现渲染超高精度的网格。要理解Nanite首先要回顾一下经典渲染管线：当我们从CPU端发出渲染指令时会首先由CPU来准备各种渲染所需的资源，然后GPU会接收这些数据并计算实际的着色。这种模式的缺陷在于CPU可能无法跟上GPU的计算速度，而且CPU的算力会浪费在准备渲染素材这一过程中。<br><img src="/images/article/Games104/22/Games104_22_01.png"><span class="image-caption">传统渲染的“长”管道</span></p><p>随着渲染场景的复杂度逐渐提升，CPU端的计算开销会成为整个渲染过程的瓶颈。<br><img src="/images/article/Games104/22/Games104_22_02.png"><span class="image-caption">从杂乱中直接绘制图形API</span><br><img src="/images/article/Games104/22/Games104_22_03.png"><span class="image-caption">传统渲染管道的瓶颈</span></p><h3 id="计算着色器（Compute-Shader）"><a href="#计算着色器（Compute-Shader）" class="headerlink" title="计算着色器（Compute Shader）"></a>计算着色器（Compute Shader）</h3><p>为了提升渲染效率人们开发出了<b>compute shader</b>这样的技术，其核心在于把过去只能在CPU端执行的通用计算转移的GPU端，从而节约掉大量的CPU到GPU端的通信开销。<br><img src="/images/article/Games104/22/Games104_22_04.png"><span class="image-caption">计算着色器-在GPU上的一般计算</span></p><h3 id="图形API（Graphics-API）"><a href="#图形API（Graphics-API）" class="headerlink" title="图形API（Graphics API）"></a>图形API（Graphics API）</h3><p>在图形API层面上过去只能一次绘制一个网格，而现代图形API则支持在一次DrawCall中同时绘制多个网格。<br><img src="/images/article/Games104/22/Games104_22_05.png"><span class="image-caption">图形API</span></p><h3 id="GPU驱动的渲染管道（GPU-Driven-Rendering-Pipeline）"><a href="#GPU驱动的渲染管道（GPU-Driven-Rendering-Pipeline）" class="headerlink" title="GPU驱动的渲染管道（GPU Driven Rendering Pipeline）"></a>GPU驱动的渲染管道（GPU Driven Rendering Pipeline）</h3><p>总结一下，现代GPU驱动的渲染管线核心思想在于把CPU端的计算直接移动到GPU端，同时渲染所需的数据也会直接由GPU进行加载。在理想情况下CPU端只负责发出绘制指令，一切渲染数据加载和计算都在GPU端直接完成。<br><img src="/images/article/Games104/22/Games104_22_06.png"><span class="image-caption">GPU驱动的渲染管道</span></p><h2 id="《刺客信条》中GPU驱动的管道（GPU-Driven-Pipeline-in-Assassins-Creed）"><a href="#《刺客信条》中GPU驱动的管道（GPU-Driven-Pipeline-in-Assassins-Creed）" class="headerlink" title="《刺客信条》中GPU驱动的管道（GPU Driven Pipeline in Assassins Creed）"></a>《刺客信条》中GPU驱动的管道（GPU Driven Pipeline in Assassins Creed）</h2><p>游戏工业对GPU驱动渲染管线的大规模应用可以追溯到《刺客信条：大革命》。在游戏中我们可以看到大量的拥有真实细节的建筑和场景，如何渲染这些极其复杂的几何对象是整个渲染管线的巨大挑战。<br><img src="/images/article/Games104/22/Games104_22_07.png"><span class="image-caption">《刺客信条》中GPU驱动的管道</span></p><p>游戏开发团队提出了<b>mesh cluster rendering</b>的技术来提升渲染效率。mesh cluster rendering的思想在于对同一物体上的面片进行聚类，在渲染时首先根据cluster来判断面片的可见性<br><img src="/images/article/Games104/22/Games104_22_08.png"><span class="image-caption">网格群集渲染</span></p><p>整个游戏的渲染管线如下图所示。通过clustering的方法可以去除掉大量不可见的对象以及三角形，从而极大地缓解了GPU的渲染压力。<br><img src="/images/article/Games104/22/Games104_22_09.png"><span class="image-caption">GPU驱动的管道在刺客信条中</span></p><p>而在CPU端只负责非常少量的视锥剔除等工作，初步过滤掉不可见的物体。<br><img src="/images/article/Games104/22/Games104_22_10.png"><span class="image-caption">在CPU侧工作</span></p><p>然后GPU端会把过滤后物体上的cluster拓展为chunk，每个instance可以属于不同的chunk而每个chunk可以包含不同的cluster。<br><img src="/images/article/Games104/22/Games104_22_11.png"><span class="image-caption">GPU实例剔除</span></p><p>GPU端进行实际的可见性剔除时会先检查chunk的可见性然后计算cluster的可见性。除了利用bounding box进行剔除外，还会同时结合三角形的朝向进行过滤，最后得到所有可见的三角形编号。<br><img src="/images/article/Games104/22/Games104_22_12.png"><span class="image-caption">GPU实例剔除2</span></p><p>所有可见三角形的编号会存储在一个事先申请的巨大buffer中。写入过程是原子化的，因此可以利用GPU并行计算来高效处理。而在进行渲染时可以利用这个buffer来并行处理所有的三角形，从而实现对场景的渲染。<br><img src="/images/article/Games104/22/Games104_22_13.png"><span class="image-caption">索引缓冲区压缩</span><br><img src="/images/article/Games104/22/Games104_22_14.png"><span class="image-caption">立方体中的编解码器三角形可见性：背面剔除</span></p><h2 id="相机和阴影的遮挡剔除（Occlusion-Culling-for-Camera-and-Shadow）"><a href="#相机和阴影的遮挡剔除（Occlusion-Culling-for-Camera-and-Shadow）" class="headerlink" title="相机和阴影的遮挡剔除（Occlusion Culling for Camera and Shadow）"></a>相机和阴影的遮挡剔除（Occlusion Culling for Camera and Shadow）</h2><p>为了进一步提升渲染效率，除了剔除掉视野外的三角形外我们还希望能够把被遮挡住的三角形也同时剔除掉，这一过程称为<b>occlusion culling</b>。当相机在场景中的运动比较光滑时可以把前一帧的深度图投影到当前相机位置上，再结合hierarchy z-buffer就可以估计哪些cluster和三角形是可见的。<br><img src="/images/article/Games104/22/Games104_22_15.png"><span class="image-caption">遮挡深度生成</span></p><h3 id="两相遮挡剔除（Two-Phase-Occlusion-Culling）"><a href="#两相遮挡剔除（Two-Phase-Occlusion-Culling）" class="headerlink" title="两相遮挡剔除（Two-Phase Occlusion Culling）"></a>两相遮挡剔除（Two-Phase Occlusion Culling）</h3><p>更现代的occlusion culling方法是使用上一帧和这一帧的两个z-buffer来实现。首先利用前一帧的z-buffer来快速选取可能可见的物体，然后使用这些物体来渲染新的z-buffer。显然此时的深度图会有非常多的洞等待填充，而且很多像素的深度可能是错误的。为了修正这个问题还需要再利用这一帧的深度图来测试前面过滤掉的其它物体。<br><img src="/images/article/Games104/22/Games104_22_16.png"><span class="image-caption">两相遮挡剔除</span></p><p>这种two-phase occlusion culling方法对于非常复杂的场景以及动态物体都有很好的性能。<br><img src="/images/article/Games104/22/Games104_22_17.png"><span class="image-caption">疯狂的压缩案例</span></p><p>而对于阴影的问题也可以复用前一帧阴影的深度图并结合hierarchy z-buffer来进行剔除。<br><img src="/images/article/Games104/22/Games104_22_18.png"><span class="image-caption">阴影的快速遮挡</span></p><p>要进一步提升阴影的渲染效率还可以结合相机的可见性，把所有相机方向不可见的物体全部剔除掉。<br><img src="/images/article/Games104/22/Games104_22_19.png"><span class="image-caption">用于阴影剔除的相机深度重新投影</span><br><img src="/images/article/Games104/22/Games104_22_20.png"><span class="image-caption">相机深度重投影的最佳案例</span></p><h2 id="可见性缓冲区（Visibility-Buffer）"><a href="#可见性缓冲区（Visibility-Buffer）" class="headerlink" title="可见性缓冲区（Visibility Buffer）"></a>可见性缓冲区（Visibility Buffer）</h2><p>和Nanite相关的另一个技术是课程前面提到过的G-buffer和<a href="/posts/ed8f511c.html#延迟渲染（Deferred-Rendering）"><b><font color="red">延迟渲染</font></b></a>，我们可以把场景中的各种几何信息记录在G-buffer中从而方便渲染时的计算。<br><img src="/images/article/Games104/22/Games104_22_21.png"><span class="image-caption">重述-延迟着色，G缓冲区</span><br><img src="/images/article/Games104/22/Games104_22_22.png"><span class="image-caption">延迟着色</span></p><p>显然这样的G-buffer会占用非常多的显存，这在画面高分辨率或是复杂场景的情况下读取数据的效率会变得极其低下。<br><img src="/images/article/Games104/22/Games104_22_23.png"><span class="image-caption">延迟着色的G缓冲区</span><br><img src="/images/article/Games104/22/Games104_22_24.png"><span class="image-caption">复杂场景的挑战</span></p><p><a href="/posts/ed8f511c.html#可见性缓冲区（Visibility-Buffer）"><b><font color="red">V-buffer</font></b></a>是为了提升数据读取效率和缓存利用率而提出的一种技术。V-buffer中不会记录太多的几何信息，一般只保存像素上物体的各种编号。<br><img src="/images/article/Games104/22/Games104_22_25.png"><span class="image-caption">可见性缓冲区</span><br><img src="/images/article/Games104/22/Games104_22_26.png"><span class="image-caption">可见性缓冲区-填充</span></p><p>在进行着色时对每个像素需要先获取该处对应的三角形信息，然后通过插值来得到像素上相应的各种几何材质数据。这种渲染方式的优势在于计算量只与分辨率有关，而与场景的几何复杂度无关，因此拥有非常高的计算效率。<br><img src="/images/article/Games104/22/Games104_22_27.png"><span class="image-caption">可见性缓冲区-着色</span><br><img src="/images/article/Games104/22/Games104_22_28.png"><span class="image-caption">可见性缓冲区管道</span></p><p>V-buffer可以很容易地和延迟渲染管线进行结合。我们只需要利用V-buffer中可见物体的编号来重新写入G-buffer就可以完美融入延迟渲染管线中。<br><img src="/images/article/Games104/22/Games104_22_29.png"><span class="image-caption">混合使用</span></p><p>当然V-buffer在实际使用时还有很多的细节要处理，比如说如何考虑纹理的梯度、如何选取合适的mip-map等。<br><img src="/images/article/Games104/22/Games104_22_30.png"><span class="image-caption">使用渐变校正纹理Mipmap</span></p><p>使用V-buffer可以极大地提升具有复杂几何场景的渲染效率。<br><img src="/images/article/Games104/22/Games104_22_31.png"><span class="image-caption">结果</span></p><h2 id="虚拟几何系统（Virtual-Geometry-Nanite）"><a href="#虚拟几何系统（Virtual-Geometry-Nanite）" class="headerlink" title="虚拟几何系统（Virtual Geometry - Nanite）"></a>虚拟几何系统（Virtual Geometry - Nanite）</h2><h3 id="概述（Nanite-Overview）"><a href="#概述（Nanite-Overview）" class="headerlink" title="概述（Nanite Overview）"></a>概述（Nanite Overview）</h3><p>Nanite的核心任务是实现实时电影级高精度几何模型的渲染，我们希望能够尽可能还原有着无限细节的真实世界。<br><img src="/images/article/Games104/22/Games104_22_32.png"><span class="image-caption">概述</span><br><img src="/images/article/Games104/22/Games104_22_33.png"><span class="image-caption">概述2</span></p><p>回忆基于<a href="/posts/aa8fbdb6.html#纹理混合（Texture-Splatting）"><b><font color="red">virtual texture</font></b></a>的技术我们可以为物体不同LoD的纹理烘焙在固定大小的纹理贴图上，在渲染时根据相机的位置和实际需要加载所需的纹理。这种材质表达可以提升缓存利用率以及数据加载效率。<br><img src="/images/article/Games104/22/Games104_22_34.png"><span class="image-caption">虚拟纹理</span></p><p>Nanite的思想与virtual texture非常相似，不过Nanite更关心的是如何建立虚拟的几何表示。当然几何数据本身要比纹理贴图要复杂得多，如何建立规范的几何表示至今仍然是一个难题。<br><img src="/images/article/Games104/22/Games104_22_35.png"><span class="image-caption">梦想</span><br><img src="/images/article/Games104/22/Games104_22_36.png"><span class="image-caption">现实</span></p><p>以体素化表示为例，尽管体素本身是相对规范的但由于其巨大的数据量我们很难在游戏引擎中来直接使用。<br><img src="/images/article/Games104/22/Games104_22_37.png"><span class="image-caption">体素</span></p><p>另一种流行的几何表示方法是<b>曲面细分(surface subdivision)</b>，基于这样的技术我们可以把粗略的几何表面细分为高精度包含各种细节的曲面。然而曲面细分的一个缺陷在于很难对曲面进行降采样，即从高精度曲面来获得低精度表示。<br><img src="/images/article/Games104/22/Games104_22_38.png"><span class="image-caption">曲面细分</span></p><p>其它的几何表达方式包括displacement map或是点云也都无法满足我们的需求。<br><img src="/images/article/Games104/22/Games104_22_39.png"><span class="image-caption">基于地图的方法？</span><br><img src="/images/article/Games104/22/Games104_22_40.png"><span class="image-caption">点云？</span></p><p>因此在Nanite中还是选择了三角网格来表示，然后设计了一套非常复杂的算法流程来表达几何信息。<br><img src="/images/article/Games104/22/Games104_22_41.png"><span class="image-caption">计算机图形基础</span></p><h3 id="几何图形表示（Nanite-Geometry-Representation）"><a href="#几何图形表示（Nanite-Geometry-Representation）" class="headerlink" title="几何图形表示（Nanite Geometry Representation）"></a>几何图形表示（Nanite Geometry Representation）</h3><p>Nanite的一个重要想法是利用屏幕的精度来控制渲染时所需计算三角形的数量。尽管三角形的数量可以随着模型精度的提高不断增长，但只要屏幕分辨率不变所需绘制的三角形数量应该是比较稳定的。<br><img src="/images/article/Games104/22/Games104_22_42.png"><span class="image-caption">屏幕像素和三角形</span></p><p>因此可以结合前面介绍过的<a href="/posts/647e170e.html#《刺客信条》中GPU驱动的管道（GPU-Driven-Pipeline-in-Assassins-Creed）"><b><font color="red">mesh cluster</font></b></a>来控制模型的细节。<br><img src="/images/article/Games104/22/Games104_22_43.png"><span class="image-caption">用集群表示几何图形</span></p><p>然后根据相机与模型的相对远近关系来生成cluster在不同LoD下的几何表示。<br><img src="/images/article/Games104/22/Games104_22_44.png"><span class="image-caption">视图相关LOD转换–优于AC解决方案</span><br><img src="/images/article/Games104/22/Games104_22_45.png"><span class="image-caption">类似的视觉外观，1/30的渲染成本！</span></p><p>在选择cluster的LoD时需要考虑它投影到屏幕上产生的误差。一种直观的选取方法是当误差小于1px时选择当前层的LoD，否则选取下一层的LoD。<br><img src="/images/article/Games104/22/Games104_22_46.png"><span class="image-caption">朴素的解决方案-集群LoD层次结构</span><br><img src="/images/article/Games104/22/Games104_22_47.png"><span class="image-caption">朴素的解决方案-决定集群的LOD运行时</span><br><img src="/images/article/Games104/22/Games104_22_48.png"><span class="image-caption">朴素的解决方案-决定集群的LOD运行时</span></p><p>但是在合并cluster时需要考虑不同LoD的cluster之间可能会出现缝隙。当然我们可以把cluster的边锁住，这样不管是使用哪一层的LoD都会有一致的边界。不过这样的处理并不是一个非常好的办法，可能会产生严重的artifact。<br><img src="/images/article/Games104/22/Games104_22_49.png"><span class="image-caption">如何处理LOD裂缝</span><br><img src="/images/article/Games104/22/Games104_22_50.png"><span class="image-caption">锁定的边界？糟糕的结果</span></p><p>Nanite中提出了<b>cluster group</b>的概念来处理cluster之间的缝隙。cluster group之间的边界会被锁住，而内部的cluster会在生成LoD时一起进行简化。<br><img src="/images/article/Games104/22/Games104_22_51.png"><span class="image-caption">朴素的解决方案-群集组</span></p><p>整个cluster简化的过程如下。需要注意的是简化后的cluster与原始cluster之间并不是一对多的关系，而是多对多的关系。即不同的简化后的cluster可以对应同一个原始cluster。<br><img src="/images/article/Games104/22/Games104_22_52.png"><span class="image-caption">构建操作</span><br><img src="/images/article/Games104/22/Games104_22_53.png"><span class="image-caption">构建操作2</span><br><img src="/images/article/Games104/22/Games104_22_54.png"><span class="image-caption">构建集群</span><br><img src="/images/article/Games104/22/Games104_22_55.png"><span class="image-caption">群集组上的简化</span><br><img src="/images/article/Games104/22/Games104_22_56.png"><span class="image-caption">群集组上的简化2</span></p><p>随着LoD的提高不同cluster group的边界也会发生相应的变化，这样可以避免出现高频噪声。<br><img src="/images/article/Games104/22/Games104_22_57.png"><span class="image-caption">级别之间的交替组边界</span><br><img src="/images/article/Games104/22/Games104_22_58.png"><span class="image-caption">LoD0的群集组边界</span><br><img src="/images/article/Games104/22/Games104_22_59.png"><span class="image-caption">LoD1的群集组边界</span><br><img src="/images/article/Games104/22/Games104_22_60.png"><span class="image-caption">LoD2的群集组边界</span></p><p>实际上这样的简化cluster过程可以表示为一张DAG，每个cluster在上一层LoD会有多个指向。<br><img src="/images/article/Games104/22/Games104_22_61.png"><span class="image-caption">群集组的DAG</span><br><img src="/images/article/Games104/22/Games104_22_62.png"><span class="image-caption">为什么是DAG，而不是Tree（陷阱！）</span><br><img src="/images/article/Games104/22/Games104_22_63.png"><span class="image-caption">让我们Chop一下可爱的兔子</span></p><p>而网格本身的简化则可以使用经典的QEM等简化算法来实现。<br><img src="/images/article/Games104/22/Games104_22_64.png"><span class="image-caption">简化细节-QEM</span><br><img src="/images/article/Games104/22/Games104_22_65.png"><span class="image-caption">简化细节-QEM2</span></p><h3 id="运行时LoD选择（Runtime-LoD-Selection）"><a href="#运行时LoD选择（Runtime-LoD-Selection）" class="headerlink" title="运行时LoD选择（Runtime LoD Selection）"></a>运行时LoD选择（Runtime LoD Selection）</h3><p>进行渲染时需要根据相机的位置来选择合适的LoD。不过对于DAG这样的数据结构进行访问时仍然是比较复杂的。<br><img src="/images/article/Games104/22/Games104_22_66.png"><span class="image-caption">查看DAG上的LoD选择？</span><br><img src="/images/article/Games104/22/Games104_22_67.png"><span class="image-caption">集群组的LOD选择</span></p><p>Nanite还使用了并行化的技术来加速访问。<br><img src="/images/article/Games104/22/Games104_22_68.png"><span class="image-caption">并行的LOD选择</span><br><img src="/images/article/Games104/22/Games104_22_69.png"><span class="image-caption">并行的LOD选择2</span><br><img src="/images/article/Games104/22/Games104_22_70.png"><span class="image-caption">群并行逻辑选择核心方程</span><br><img src="/images/article/Games104/22/Games104_22_71.png"><span class="image-caption">每个集群组的单独LoD选择</span><br><img src="/images/article/Games104/22/Games104_22_72.png"><span class="image-caption">每个集群组的单独LoD选择2</span><br><img src="/images/article/Games104/22/Games104_22_73.png"><span class="image-caption">每个集群组的单独LoD选择3</span></p><p>除此之外还可以使用BVH来加速LoD选择。<br><img src="/images/article/Games104/22/Games104_22_74.png"><span class="image-caption">关于BVH为什么和如何的糟糕解释</span><br><img src="/images/article/Games104/22/Games104_22_75.png"><span class="image-caption">构建BVH以加速LoD的选择</span><br><img src="/images/article/Games104/22/Games104_22_76.png"><span class="image-caption">针对4个节点的平衡BVH</span><br><img src="/images/article/Games104/22/Games104_22_77.png"><span class="image-caption">BVH加速度详细信息</span></p><p>BVH的构建过程还可以使用job system来进行加速。<br><img src="/images/article/Games104/22/Games104_22_78.png"><span class="image-caption">分层筛选的的方法</span><br><img src="/images/article/Games104/22/Games104_22_79.png"><span class="image-caption">持久化线程</span></p><h3 id="光栅化（Nanite-Rasterization）"><a href="#光栅化（Nanite-Rasterization）" class="headerlink" title="光栅化（Nanite Rasterization）"></a>光栅化（Nanite Rasterization）</h3><p>Nanite在渲染时很多三角形的大小已经接近于屏幕上的一个像素，此时需要硬件光栅化来提供支持。<br><img src="/images/article/Games104/22/Games104_22_80.png"><span class="image-caption">像素比例详细信息</span><br><img src="/images/article/Games104/22/Games104_22_81.png"><span class="image-caption">硬件光栅化</span><br><img src="/images/article/Games104/22/Games104_22_82.png"><span class="image-caption">硬件光栅化2</span></p><p>传统光栅化对于小三角形的支持不够好，在Nanite中会结合compute shader来实现软光栅。<br><img src="/images/article/Games104/22/Games104_22_83.png"><span class="image-caption">硬件光栅化3</span><br><img src="/images/article/Games104/22/Games104_22_84.png"><span class="image-caption">微小三角形的软件光栅化</span><br><img src="/images/article/Games104/22/Games104_22_85.png"><span class="image-caption">Nanite-光栅化</span><br><img src="/images/article/Games104/22/Games104_22_86.png"><span class="image-caption">扫描线软件光栅化器</span></p><p>在深度测试时，Nanite还利用了一些trick进行加速。实际渲染过程与V-buffer渲染过程类似。<br><img src="/images/article/Games104/22/Games104_22_87.png"><span class="image-caption">如何进行深度测试？</span><br><img src="/images/article/Games104/22/Games104_22_88.png"><span class="image-caption">Nanite可见性缓冲区</span><br><img src="/images/article/Games104/22/Games104_22_89.png"><span class="image-caption">Nanite可见性缓冲区2</span><br><img src="/images/article/Games104/22/Games104_22_90.png"><span class="image-caption">Nanite可见性缓冲区3</span><br><img src="/images/article/Games104/22/Games104_22_91.png"><span class="image-caption">硬件光栅化</span><br><img src="/images/article/Games104/22/Games104_22_92.png"><span class="image-caption">针对微小实例的强制执行</span><br><img src="/images/article/Games104/22/Games104_22_93.png"><span class="image-caption">光栅放大器</span></p><h3 id="延迟材质（Nanite-Deferred-Material）"><a href="#延迟材质（Nanite-Deferred-Material）" class="headerlink" title="延迟材质（Nanite Deferred Material）"></a>延迟材质（Nanite Deferred Material）</h3><p>Nanite在绘制材质时会把材质信息转换为深度图，然后对可能出现的深度(材质)进行遍历。这样可以一次性绘制所有具有相同材质的像素。<br><img src="/images/article/Games104/22/Games104_22_94.png"><span class="image-caption">延迟材料</span><br><img src="/images/article/Games104/22/Games104_22_95.png"><span class="image-caption">材料着色</span><br><img src="/images/article/Games104/22/Games104_22_96.png"><span class="image-caption">着色效率</span></p><p>更新的Nanite版本还会把屏幕划分为若干个tile，然后在每个tile上统计出现的材质。这样可以加速对全屏材质的遍历和绘制。<br><img src="/images/article/Games104/22/Games104_22_97.png"><span class="image-caption">阴影</span><br><img src="/images/article/Games104/22/Games104_22_98.png"><span class="image-caption">使用基于瓦块的渲染方式进行材质排序</span><br><img src="/images/article/Games104/22/Games104_22_99.png"><span class="image-caption">材料分类</span><br><img src="/images/article/Games104/22/Games104_22_100.png"><span class="image-caption">材料分类-材料瓦块重新制作表</span><br><img src="/images/article/Games104/22/Games104_22_101.png"><span class="image-caption">延期材料整体流程</span></p><h3 id="虚拟阴影贴图（Virtual-Shadow-Map）"><a href="#虚拟阴影贴图（Virtual-Shadow-Map）" class="headerlink" title="虚拟阴影贴图（Virtual Shadow Map）"></a>虚拟阴影贴图（Virtual Shadow Map）</h3><p>高精度几何模型还会导致阴影渲染时的困难，而且遗憾的是Nanite目前尚不支持实时光追来计算阴影。<br><img src="/images/article/Games104/22/Games104_22_102.png"><span class="image-caption">阴影的细微级别细节</span><br><img src="/images/article/Games104/22/Games104_22_103.png"><span class="image-caption">Nanite阴影-光线跟踪？</span></p><p>不过计算阴影时也可以结合LoD，在距离相机不同远近的位置使用不同精度的模型。<br><img src="/images/article/Games104/22/Games104_22_104.png"><span class="image-caption">回顾层叠阴影贴图</span><br><img src="/images/article/Games104/22/Games104_22_105.png"><span class="image-caption">样例分布阴影贴图</span><br><img src="/images/article/Games104/22/Games104_22_106.png"><span class="image-caption">样例分布阴影贴图2</span></p><p>在这种思想下Nanite提出了virtual shadow map来表示不同精度的物体。<br><img src="/images/article/Games104/22/Games104_22_107.png"><span class="image-caption">虚拟阴影地图-一个缓存的阴影系统！</span><br><img src="/images/article/Games104/22/Games104_22_108.png"><span class="image-caption">虚拟阴影地图</span></p><p>对于不同类型的光源也可以定制划分virtual shadow map的方式。<br><img src="/images/article/Games104/22/Games104_22_109.png"><span class="image-caption">不同的灯光类型阴影贴图</span></p><p>当相机和光源都不变时我们可以把shadow map相关的信息写入page中方便下一帧读取。而如果相机和光源发生变化则只需更新一部分page即可。<br><img src="/images/article/Games104/22/Games104_22_110.png"><span class="image-caption">阴影页面分配</span><br><img src="/images/article/Games104/22/Games104_22_111.png"><span class="image-caption">阴影页面表和物理页面池</span></p><p>当然这种virtual shadow map在场景光源发生变化时会出现一些问题，因此比较适合主光源不变的场景。<br><img src="/images/article/Games104/22/Games104_22_112.png"><span class="image-caption">阴影页面缓存无效</span><br><img src="/images/article/Games104/22/Games104_22_113.png"><span class="image-caption">阴影演示</span><br><img src="/images/article/Games104/22/Games104_22_114.png"><span class="image-caption">结论</span></p><h3 id="流媒体和压缩（Streaming-and-Compression）"><a href="#流媒体和压缩（Streaming-and-Compression）" class="headerlink" title="流媒体和压缩（Streaming and Compression）"></a>流媒体和压缩（Streaming and Compression）</h3><p><img src="/images/article/Games104/22/Games104_22_115.png"><span class="image-caption">流媒体</span><br><img src="/images/article/Games104/22/Games104_22_116.png"><span class="image-caption">内存调度</span><br><img src="/images/article/Games104/22/Games104_22_117.png"><span class="image-caption">内存表示</span><br><img src="/images/article/Games104/22/Games104_22_118.png"><span class="image-caption">磁盘表示</span><br><img src="/images/article/Games104/22/Games104_22_119.png"><span class="image-caption">结果</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/12/12/GAMES104-NOTES-22.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1Et4y1P7ro/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV17G4y1x7VX/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture22_GPU%20Driven%20Geometry%20Pipeline-Nanite.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 动态全局光照和Lumen（二十一）</title>
      <link href="/posts/fd7746b4.html"/>
      <url>/posts/fd7746b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="GI基础（Global-Illumination）"><a href="#GI基础（Global-Illumination）" class="headerlink" title="GI基础（Global Illumination）"></a>GI基础（Global Illumination）</h2><h3 id="渲染方程式（The-Rendering-Equation）"><a href="#渲染方程式（The-Rendering-Equation）" class="headerlink" title="渲染方程式（The Rendering Equation）"></a>渲染方程式（The Rendering Equation）</h3><p><b>全局光照(global illumination, GI)</b>是渲染中的重要问题。在介绍GI在游戏引擎的实现方法前我们先回顾一下<b>渲染方程(the rendering equation)</b>：<br><img src="/images/article/Games104/21/Games104_21_01.png"><span class="image-caption">渲染方程</span></p><p>可以说一切渲染问题的本质在于求解渲染方程，而求解渲染方程的难点在于方程自身的递归形式。当场景中的物体被光源照亮后，被照亮的物体又会成为新的光源再次照亮其它物体。以Cornell box为例，来自屋顶的灯光会照亮左右两侧红色和绿色的墙壁，然后墙壁反射的光线又会照亮盒子使得盒子的两侧呈现红色或是绿色，这样的现象称为<b>color bleeding</b>。<br><img src="/images/article/Games104/21/Games104_21_02.png"><span class="image-caption">渲染方程2</span><br><img src="/images/article/Games104/21/Games104_21_03.png"><span class="image-caption">全局光照：数十亿个光源</span></p><p>在复杂的游戏场景中通过GI会极大地提升画面表现力。<br><img src="/images/article/Games104/21/Games104_21_04.png"><span class="image-caption">全局光照对游戏很重要</span></p><h3 id="蒙特卡罗积分（Monte-Carlo-Integration）"><a href="#蒙特卡罗积分（Monte-Carlo-Integration）" class="headerlink" title="蒙特卡罗积分（Monte Carlo Integration）"></a>蒙特卡罗积分（Monte Carlo Integration）</h3><p>作为积分方程，求解渲染方程的经典方法是<b>Monte Carlo积分(Monte Carlo integration)</b>。对于可积函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.299ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1900 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1511,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，我们可以通过采样的方法来逼近<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.299ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1900 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1511,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>的积分<br><img src="/images/article/Games104/21/Games104_21_05.png"><span class="image-caption">蒙特卡罗积分</span><br><img src="/images/article/Games104/21/Games104_21_06.png"><span class="image-caption">蒙特卡罗积分2</span></p><p><b>光线追踪(ray tracing)</b>算法的本质就是通过Monte Carlo积分来求解渲染方程。<br><img src="/images/article/Games104/21/Games104_21_07.png"><span class="image-caption">蒙特卡罗光线追踪（离线）</span></p><h3 id="重要性采样-Importance-Sampling"><a href="#重要性采样-Importance-Sampling" class="headerlink" title="重要性采样(Importance Sampling)"></a>重要性采样(Importance Sampling)</h3><p>Monte Carlo积分的效率和精度取决于如何设计采样的样本。当样本的数量比较少或是质量比较低时，通过光线追踪渲染出的图像往往会具有非常多的噪声。<br><img src="/images/article/Games104/21/Games104_21_08.png"><span class="image-caption">采样是关键</span></p><p>因此如何设计采样的分布对于提升渲染质量有着非常重要的意义，其中最简单的采样方法是均匀采样。<br><img src="/images/article/Games104/21/Games104_21_09.png"><span class="image-caption">采样：统一采样</span></p><p>现代高质量渲染的核心技术在于<b>重要性采样(importance sampling)<b>的大规模应用。重要性采样理论指出当我们的采样函数接近于被积函数时只需要相对少的样本就可以很好地近似被积函数的积分，而在计算Monte Carlo积分时只需要对样本按照pdf进行加权求和即可。<br><img src="/images/article/Games104/21/Games104_21_10.png"><span class="image-caption">概率分布函数</span><br><img src="/images/article/Games104/21/Games104_21_11.png"><span class="image-caption">重要性采样</span></b></b></p><p>回到渲染方程中，被积函数包含余弦项<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="5.205ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 2300.6 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="63" d="M370 305T349 305T313 320T297 358Q297 381 312 396Q317 401 317 402T307 404Q281 408 258 408Q209 408 178 376Q131 329 131 219Q131 137 162 90Q203 29 272 29Q313 29 338 55T374 117Q376 125 379 127T395 129H409Q415 123 415 120Q415 116 411 104T395 71T366 33T318 2T249 -11Q163 -11 99 53T34 214Q34 318 99 383T250 448T370 421T404 357Q404 334 387 320Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(444,0)"></path><path data-c="73" d="M295 316Q295 356 268 385T190 414Q154 414 128 401Q98 382 98 349Q97 344 98 336T114 312T157 287Q175 282 201 278T245 269T277 256Q294 248 310 236T342 195T359 133Q359 71 321 31T198 -10H190Q138 -10 94 26L86 19L77 10Q71 4 65 -1L54 -11H46H42Q39 -11 33 -5V74V132Q33 153 35 157T45 162H54Q66 162 70 158T75 146T82 119T101 77Q136 26 198 26Q295 26 295 104Q295 133 277 151Q257 175 194 187T111 210Q75 227 54 256T33 318Q33 357 50 384T93 424T143 442T187 447H198Q238 447 268 432L283 424L292 431Q302 440 314 448H322H326Q329 448 335 442V310L329 304H301Q295 310 295 316Z" transform="translate(944,0)"></path></g><g data-mml-node="mo" transform="translate(1338,0)"><path data-c="2061" d=""></path></g><g data-mml-node="msub" transform="translate(1504.7,0)"><g data-mml-node="mi"><path data-c="1D703" d="M35 200Q35 302 74 415T180 610T319 704Q320 704 327 704T339 705Q393 701 423 656Q462 596 462 495Q462 380 417 261T302 66T168 -10H161Q125 -10 99 10T60 63T41 130T35 200ZM383 566Q383 668 330 668Q294 668 260 623T204 521T170 421T157 371Q206 370 254 370L351 371Q352 372 359 404T375 484T383 566ZM113 132Q113 26 166 26Q181 26 198 36T239 74T287 161T335 307L340 324H145Q145 321 136 286T120 208T113 132Z"></path></g><g data-mml-node="mi" transform="translate(502,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>，因此一个常见技巧是根据余弦项进行采样；类似地也可以按照BRDF来进行采样，这种采样方式对于光泽表面的物体往往有着更高的积分效率。<br><img src="/images/article/Games104/21/Games104_21_12.png"><span class="image-caption">重要性采样：最好的PDF渲染？</span><br><img src="/images/article/Games104/21/Games104_21_13.png"><span class="image-caption">重要性采样：PDF是重要的</span><br><img src="/images/article/Games104/21/Games104_21_14.png"><span class="image-caption">重要性采样：Cosine和GGX PDF</span></p><h2 id="反射阴影贴图（Reflective-Shadow-Maps-RSM）"><a href="#反射阴影贴图（Reflective-Shadow-Maps-RSM）" class="headerlink" title="反射阴影贴图（Reflective Shadow Maps - RSM）"></a>反射阴影贴图（Reflective Shadow Maps - RSM）</h2><p>尽管通过光线追踪可以解决GI的问题，但它的主要缺陷在于光线追踪基本无法应用在游戏这样有实时性要求的场景中。为了实现实时的GI人们设计了各种各样的算法来进行近似，其中最早的工作可以追溯到2005年的<b>reflective shadow maps(RSM)</b>算法。</p><p>从实现的层面上讲，RSM更接近于<b>光子映射(photon mapping)</b>。光子映射理论认为相机接收到的radiance本质是由光源发射的光子经过场景不断的吸收和反射最终的被相机捕获的结果，因此我们可以从光源出发发射大量的光子然后计算光子在场景上的分布，然后通过相机来进行收集即可。</p><p>在RSM中我们需要从光源的位置首先渲染一张shadow map，它表示场景中所有被光源直接照射的部分。<br><img src="/images/article/Games104/21/Games104_21_15.png"><span class="image-caption">反射阴影贴图</span></p><p>shadow map记录了这些区域在直接光照下反射的radiance，这样当我们需要考虑GI时只需要把直接光照和shadow map上记录的来自其它物体的反射光线进行相加即可。<br><img src="/images/article/Games104/21/Games104_21_16.png"><span class="image-caption">反射阴影贴图2</span></p><p>直接计算来自场景中其它物体的反射光线仍然需要非常多的计算量，在RSM中使用了<b>cone tracing</b>的技术来进行简化。<br><img src="/images/article/Games104/21/Games104_21_17.png"><span class="image-caption">用RSM跟踪锥体</span></p><p>由于间接光照一般来说是相对低频的，在渲染时还可以降低输出的分辨率进一步提升效率。然后在与直接光照相加时通过插值的方式来获得完整分辨率下的间接光照。<br><img src="/images/article/Games104/21/Games104_21_18.png"><span class="image-caption">具有低分辨率间接光照的加速</span></p><p>通过RSM实现的GI可以明显提升游戏画面中阴影部分的细节。<br><img src="/images/article/Games104/21/Games104_21_19.png"><span class="image-caption">提升游戏画面中阴影部分的细节</span></p><p>总结一下，RSM作为实时GI的早期工作非常容易进行实现而且很高的计算效率；而它的缺陷在于RSM只能考虑光线的一次反射，而且在计算间接光照时没有进行可见性检测。<br><img src="/images/article/Games104/21/Games104_21_20.png"><span class="image-caption">RSM</span></p><h2 id="光传播体积（Light-Propagation-Volumes-LPV）"><a href="#光传播体积（Light-Propagation-Volumes-LPV）" class="headerlink" title="光传播体积（Light Propagation Volumes - LPV）"></a>光传播体积（Light Propagation Volumes - LPV）</h2><p><b>light propagation volumes(LPV)</b>是考虑光线在场景中不断传播的一种GI算法，最早在2009年提出。<br><img src="/images/article/Games104/21/Games104_21_21.png"><span class="image-caption">光传播体积</span></p><p>LPV的核心在于把场景使用三维的网格进行表示，并以此来计算光线在场景中的分布。<br><img src="/images/article/Games104/21/Games104_21_22.png"><span class="image-caption">光传播体积2</span><br><img src="/images/article/Games104/21/Games104_21_23.png"><span class="image-caption">光传播体积3</span></p><p>LPV在计算时会记录每个格子上当光线传播到物体表面后散射的radiance，然后以此为中心向其它格子进行扩散。<br><img src="/images/article/Games104/21/Games104_21_24.png"><span class="image-caption">“冻结”体素中的亮度</span><br><img src="/images/article/Games104/21/Games104_21_25.png"><span class="image-caption">光线传播</span></p><p>某种意义上讲LPV把光线的传播视为扩散过程，严格来说这样的处理是不完全遵循物理法则的。<br><img src="/images/article/Games104/21/Games104_21_26.png"><span class="image-caption">带有“限制速度”的光</span></p><h2 id="用于实时全局的稀疏体素八叉树（Sparse-Voxel-Octree-for-Real-time-Global）"><a href="#用于实时全局的稀疏体素八叉树（Sparse-Voxel-Octree-for-Real-time-Global）" class="headerlink" title="用于实时全局的稀疏体素八叉树（Sparse Voxel Octree for Real-time Global）"></a>用于实时全局的稀疏体素八叉树（Sparse Voxel Octree for Real-time Global）</h2><p>SVOGI的思路与LPV非常接近，都使用了网格的方式来对场景空间进行划分。在SVOGI中使用了<b>保守光栅化(conservative rasterization)</b>的方法来获取场景的体素表达，从而得到场景中所有表面的体素。<br><img src="/images/article/Games104/21/Games104_21_27.png"><span class="image-caption">体素化过程</span><br><img src="/images/article/Games104/21/Games104_21_28.png"><span class="image-caption">收集表面体素</span></p><p>为了更高效地管理场景中的体素，SVOGI使用了八叉树这样的数据结构来把体素组织起来。<br><img src="/images/article/Games104/21/Games104_21_29.png"><span class="image-caption">SVOGI</span></p><p>在进行shading时则使用了cone tracing的方式来对八叉树进行查询。<br><img src="/images/article/Games104/21/Games104_21_30.png"><span class="image-caption">体素树中的锥形追踪阴影</span></p><h3 id="体素基GI（Voxelization-Based-Global-Illumination）"><a href="#体素基GI（Voxelization-Based-Global-Illumination）" class="headerlink" title="体素基GI（Voxelization Based Global Illumination）"></a>体素基GI（Voxelization Based Global Illumination）</h3><p>VXGI可以看做是对SVOGI的简化。在VXGI中使用了clip map这样的数据结构来描述场景，离相机越近就具有越高的分辨率。<br><img src="/images/article/Games104/21/Games104_21_31.png"><span class="image-caption">体素基GI</span></p><p>当相机发生运动时无需更新clip map，只需要更新相机采样的范围即可。<br><img src="/images/article/Games104/21/Games104_21_32.png"><span class="image-caption">体素更新和环形寻址</span></p><p>这样整个场景就得到了一个体素化表达，离相机近的地方体素越稠密，越远的地方体素越稀疏。<br><img src="/images/article/Games104/21/Games104_21_33.png"><span class="image-caption">体素化表达</span><br>‘<br>对于每个体素我们还需要计算该体素遮挡了多少的光线，这里会记录体素在三个方向上的可见性。<br><img src="/images/article/Games104/21/Games104_21_34.png"><span class="image-caption">用于不透明的体素化</span><br><img src="/images/article/Games104/21/Games104_21_35.png"><span class="image-caption">体素化：定向覆盖范围</span></p><p>当来自光源的光线注入到场景中时需要记录每个体素的表面上接收到的直接光照。<br><img src="/images/article/Games104/21/Games104_21_36.png"><span class="image-caption">光注入</span><br><img src="/images/article/Games104/21/Games104_21_37.png"><span class="image-caption">光注入2</span></p><p>而对于屏幕上的像素则通过cone tracing的方式来计算间接光照，通过叠加整条光路上的radiance来获得间接光照。<br><img src="/images/article/Games104/21/Games104_21_38.png"><span class="image-caption">带圆锥跟踪的着色</span><br><img src="/images/article/Games104/21/Games104_21_39.png"><span class="image-caption">沿着路径积累体素的光线和不透明度</span><br><img src="/images/article/Games104/21/Games104_21_40.png"><span class="image-caption">沿着路径积累体素的光线和不透明度2</span></p><p>VXGI的主要缺陷在于cone tracing的结构仍然是对间接光照的一种近似，而且它非常容易出现漏光的问题。<br><img src="/images/article/Games104/21/Games104_21_41.png"><span class="image-caption">VXGI中的问题</span></p><h2 id="屏幕空间全局照明（Screen-Space-Global-Illumination-SSGI）"><a href="#屏幕空间全局照明（Screen-Space-Global-Illumination-SSGI）" class="headerlink" title="屏幕空间全局照明（Screen Space Global Illumination - SSGI）"></a>屏幕空间全局照明（Screen Space Global Illumination - SSGI）</h2><p>SSGI和前面介绍过的方法相比是基于屏幕空间的GI技术。在现代GPU渲染管线中我们可以快速地渲染出屏幕空间上的各种物理量，通过重用屏幕空间的数据就可以实现GI。<br><img src="/images/article/Games104/21/Games104_21_42.png"><span class="image-caption">总体思路</span></p><p>当我们渲染得到屏幕空间上的直接光照时，可以利用屏幕空间上像素的法向信息来继续计算间接光照。<br><img src="/images/article/Games104/21/Games104_21_43.png"><span class="image-caption">屏幕空间中的光线采样</span></p><p>计算间接光照时可以利用ray marching的方式来计算光线和平面空间中物体的交点。<br><img src="/images/article/Games104/21/Games104_21_44.png"><span class="image-caption">射线性行进</span></p><p>为了进一步提升ray marching的效率，SSGI还使用了z-buffer的mipmap来进行加速。<br><img src="/images/article/Games104/21/Games104_21_45.png"><span class="image-caption">层次追踪</span><br><img src="/images/article/Games104/21/Games104_21_46.png"><span class="image-caption">层次追踪2</span><br><img src="/images/article/Games104/21/Games104_21_47.png"><span class="image-caption">层次追踪3</span><br><img src="/images/article/Games104/21/Games104_21_48.png"><span class="image-caption">层次追踪4</span><br><img src="/images/article/Games104/21/Games104_21_49.png"><span class="image-caption">层次追踪5</span><br><img src="/images/article/Games104/21/Games104_21_50.png"><span class="image-caption">层次追踪6</span><br><img src="/images/article/Games104/21/Games104_21_51.png"><span class="image-caption">层次追踪7</span></p><p>同时SSGI还会对每一个像素来重复使用其相邻像素采样的间接光照，这样可以减少采样的光线数量从而进一步提升渲染效率。<br><img src="/images/article/Games104/21/Games104_21_52.png"><span class="image-caption">邻居像素之间的光线重用</span><br><img src="/images/article/Games104/21/Games104_21_53.png"><span class="image-caption">使用Mipmap筛选的锥体跟踪</span></p><p>和前面介绍过的基于体素的GI技术相比，SSGI对于光泽表面有非常好的渲染效果；但需要注意的是SSGI无法处理屏幕空间之外的物体，这容易导致各种错误的渲染结果。<br><img src="/images/article/Games104/21/Games104_21_54.png"><span class="image-caption">SSGI摘要</span><br><img src="/images/article/Games104/21/Games104_21_55.png"><span class="image-caption">SSGI的独特优势</span></p><h2 id="流明（Lumen）"><a href="#流明（Lumen）" class="headerlink" title="流明（Lumen）"></a>流明（Lumen）</h2><p><b>Luman</b>是虚幻5引擎提出的最新实时GI技术。尽管实时光线追踪也可以实现实时GI，但它依赖于硬件层面的实现而且需要大量的采样才能实现比较好的渲染效果。而Luman不依赖于硬件实现，可以应用到大量对实时性有需求的环境中。<br><img src="/images/article/Games104/21/Games104_21_56.png"><span class="image-caption">光线跟踪缓慢</span><br><img src="/images/article/Games104/21/Games104_21_57.png"><span class="image-caption">取样困难</span><br><img src="/images/article/Games104/21/Games104_21_58.png"><span class="image-caption">低分辨率滤波场景空间探测器照亮全像素</span></p><h3 id="流明：SDF光线追踪-Fast-Ray-Trace-in-Any-Hardware"><a href="#流明：SDF光线追踪-Fast-Ray-Trace-in-Any-Hardware" class="headerlink" title="流明：SDF光线追踪(Fast Ray Trace in Any Hardware)"></a>流明：SDF光线追踪(Fast Ray Trace in Any Hardware)</h3><p>Luman的渲染过程可以大致划分为4个部分，首先是进行高效的路径追踪。考虑到不是所有的硬件都支持光线追踪的加速，Luman使用了<b>SDF</b>的方式来实现这一过程。<br><img src="/images/article/Games104/21/Games104_21_59.png"><span class="image-caption">什么是SDF</span></p><p>由于直接把场景转换成SDF往往是比较复杂的，我们可以先对每个物体转换为SDF。对于平移变换和等比例的放缩，物体坐标系下的SDF都可以很容易地转换为场景坐标系下的SDF。<br><img src="/images/article/Games104/21/Games104_21_60.png"><span class="image-caption">每个网格SDF</span></p><p>需要注意的是当物体比较薄时要进行一些额外的处理。<br><img src="/images/article/Games104/21/Games104_21_61.png"><span class="image-caption">薄网格的SDF</span></p><p>SDF的一大优势在于它可以非常容易地得到光线步进的长度：在任意p位置前进SDF(p)的距离总是可以保证不会和场景出现相交。<br><img src="/images/article/Games104/21/Games104_21_62.png"><span class="image-caption">带SDF的射线跟踪</span></p><p>同时，SDF在进行cone tracing时也可以很容易地计算出遮挡面积比例的估计。<br><img src="/images/article/Games104/21/Games104_21_63.png"><span class="image-caption">使用SDF的圆锥体跟踪（即软阴影）</span></p><p>生成SDF时可以考虑使用一些稀疏的数据结构进行表示。<br><img src="/images/article/Games104/21/Games104_21_64.png"><span class="image-caption">稀疏网格SDF</span></p><p>SDF甚至可以表达物体的不同LOD。<br><img src="/images/article/Games104/21/Games104_21_65.png"><span class="image-caption">网格SDF LoD</span></p><p>在低LOD下结合sparse mesh可以极大地减少模型的存储空间。<br><img src="/images/article/Games104/21/Games104_21_66.png"><span class="image-caption">稀疏网格SDF2</span></p><p>当然，直接将场景中物体的SDF组合到一起在进行计算时仍然是过于复杂的。<br><img src="/images/article/Games104/21/Games104_21_67.png"><span class="image-caption">真实场景中的光线跟踪成本</span><br><img src="/images/article/Games104/21/Games104_21_68.png"><span class="image-caption">每条光线上都有许多物体</span></p><p>这里可以结合屏幕空间的概念只考虑相机视野范围内的物体，将它们的SDF融合为一个低精度的全局SDF。<br><img src="/images/article/Games104/21/Games104_21_69.png"><span class="image-caption">全局SDF</span></p><p>在这个低精度的全局SDF上进行ray tracing可以极大地降低计算压力。<br><img src="/images/article/Games104/21/Games104_21_70.png"><span class="image-caption">使用全局SDF的光线跟踪</span></p><p>除此之外SDF也可以结合mip的思想，近处的精度高而远处精度低。<br><img src="/images/article/Games104/21/Games104_21_71.png"><span class="image-caption">缓存摄影机周围的全局SDF</span></p><h3 id="流明：光辉缓存-Radiance-Injection-and-Caching"><a href="#流明：光辉缓存-Radiance-Injection-and-Caching" class="headerlink" title="流明：光辉缓存(Radiance Injection and Caching)"></a>流明：光辉缓存(Radiance Injection and Caching)</h3><p>接下来我们需要把光照信息注入到场景中。在Lumen中使用了<b>mesh card</b>来保存物体在6个正方形上被光照亮后的结果。<br><img src="/images/article/Games104/21/Games104_21_72.png"><span class="image-caption">网格卡-6轴对齐方向上的正交相机</span><br><img src="/images/article/Games104/21/Games104_21_73.png"><span class="image-caption">网格卡-6轴对齐方向上的正交相机2</span></p><p>对于每个card我们还需要记录物体表面的albedo、法向以及深度等信息。<br><img src="/images/article/Games104/21/Games104_21_74.png"><span class="image-caption">生成表面缓存</span></p><p>所有物体的表面信息会统一记录到一张标准大小的纹理图像上，称为<b>surface cache</b>。<br><img src="/images/article/Games104/21/Games104_21_75.png"><span class="image-caption">生成表面缓存2</span><br><img src="/images/article/Games104/21/Games104_21_76.png"><span class="image-caption">生成表面缓存3</span></p><p>根据物体距离相机的远近还可以设置不同的card分辨率以降低存储和计算需求。<br><img src="/images/article/Games104/21/Games104_21_77.png"><span class="image-caption">视图相关的每对象卡片分辨率</span></p><p>我们的目标是把物体所有光照的radiance记录到surface cache上。<br><img src="/images/article/Games104/21/Games104_21_78.png"><span class="image-caption">我们如何才能“冻结”表面缓存上的照明</span></p><p>在Lumen中整个光照可分解为直接光照、体素化光照以及间接光照三部分。<br><img src="/images/article/Games104/21/Games104_21_79.png"><span class="image-caption">光照缓存管道</span></p><p>直接光照相对比较简单，我们只需要考虑光源直接照射到物体上反射的radiance即可。对于阴影中的物体则可以结合shadow map来进行处理。<br><img src="/images/article/Games104/21/Games104_21_80.png"><span class="image-caption">直接光照</span><br><img src="/images/article/Games104/21/Games104_21_81.png"><span class="image-caption">直接光照2</span></p><p>得到直接光照后Lumen会对场景进行体素化来存储物体在6个方向上直接光照的亮度。而且体素化后的光照信息会在相邻帧上进行传递，随着时间的积累会得到光线多次弹射的效果。<br><img src="/images/article/Games104/21/Games104_21_82.png"><span class="image-caption">全局SDF无法采样表面高速缓存</span><br><img src="/images/article/Games104/21/Games104_21_83.png"><span class="image-caption">对整个场景的光线缓存的体素剪贴图</span><br><img src="/images/article/Games104/21/Games104_21_84.png"><span class="image-caption">通过短射线投射来构建体素面</span><br><img src="/images/article/Games104/21/Games104_21_85.png"><span class="image-caption">通过4x4x4格子过滤大多数对象</span><br><img src="/images/article/Games104/21/Games104_21_86.png"><span class="image-caption">将灯光注入到剪贴图中</span></p><p>最后计算间接光照时只需要从surface cache上进行采样，利用上一步体素化光照作为照明即可。<br><img src="/images/article/Games104/21/Games104_21_87.png"><span class="image-caption">间接光照</span><br><img src="/images/article/Games104/21/Games104_21_88.png"><span class="image-caption">间接光照2</span><br><img src="/images/article/Games104/21/Games104_21_89.png"><span class="image-caption">具有4个探针插值的每像素间接光照</span></p><p>把直接光照和间接光照相加就得到了环境中光照的信息。<br><img src="/images/article/Games104/21/Games104_21_90.png"><span class="image-caption">联合光照</span><br><img src="/images/article/Games104/21/Games104_21_91.png"><span class="image-caption">光照更新策略</span></p><h3 id="流明：内存探头（Build-a-lot-of-Probes-with-Different-Kinds）"><a href="#流明：内存探头（Build-a-lot-of-Probes-with-Different-Kinds）" class="headerlink" title="流明：内存探头（Build a lot of Probes with Different Kinds）"></a>流明：内存探头（Build a lot of Probes with Different Kinds）</h3><h4 id="屏幕空间探测器（Screen-Space-Probe）"><a href="#屏幕空间探测器（Screen-Space-Probe）" class="headerlink" title="屏幕空间探测器（Screen Space Probe）"></a>屏幕空间探测器（Screen Space Probe）</h4><p>有了光照后我们需要在物体表面通过采样来计算着色，此时我们需要在场景中放置<b>探针(probe)</b>来采样光照。Lumen中直接在屏幕空间里放置probe，每个probe会同时记录光线前进的距离以及收集到的radiance。<br><img src="/images/article/Games104/21/Games104_21_92.png"><span class="image-caption">屏幕探针结构</span><br><img src="/images/article/Games104/21/Games104_21_93.png"><span class="image-caption">屏幕探针结构2</span><br><img src="/images/article/Games104/21/Games104_21_94.png"><span class="image-caption">屏幕探针放置</span><br><img src="/images/article/Games104/21/Games104_21_95.png"><span class="image-caption">探针插值的平面距离加权</span><br><img src="/images/article/Games104/21/Games104_21_96.png"><span class="image-caption">检测不可插值的情况</span><br><img src="/images/article/Games104/21/Games104_21_97.png"><span class="image-caption">屏幕探测图集</span><br><img src="/images/article/Games104/21/Games104_21_98.png"><span class="image-caption">屏幕探测图集2</span><br><img src="/images/article/Games104/21/Games104_21_99.png"><span class="image-caption">屏幕探针抖动</span></p><h4 id="重要性抽样（Importance-Sampling）"><a href="#重要性抽样（Importance-Sampling）" class="headerlink" title="重要性抽样（Importance Sampling）"></a>重要性抽样（Importance Sampling）</h4><p>为了提升渲染质量我们需要使用重要性采样的技术尽可能在比较重要的方向上进行采样。<br><img src="/images/article/Games104/21/Games104_21_100.png"><span class="image-caption">重要性抽样</span><br><img src="/images/article/Games104/21/Games104_21_101.png"><span class="image-caption">重要性抽样2</span></p><p>回到Monte Carlo积分的公式中，我们需要把光线更多地分布在光照比较强或是接近物体法线的方向上。<br><img src="/images/article/Games104/21/Games104_21_102.png"><span class="image-caption">重要性抽样3</span></p><p>Lumen中会对上一帧以及四周相邻的probe进行平均来估计光照的分布。<br><img src="/images/article/Games104/21/Games104_21_103.png"><span class="image-caption">来自最后一帧探测器的近似亮度重要性</span></p><p>而对于物体法向附近的方向，Lumen会估计probe附近的法向分布。<br><img src="/images/article/Games104/21/Games104_21_104.png"><span class="image-caption">在附近的正态分布</span><br><img src="/images/article/Games104/21/Games104_21_105.png"><span class="image-caption">附近的正常积累</span><br><img src="/images/article/Games104/21/Games104_21_106.png"><span class="image-caption">结构化重要性抽样</span><br><img src="/images/article/Games104/21/Games104_21_107.png"><span class="image-caption">基于光照和BRDF的固定预算重要性采样</span><br><img src="/images/article/Games104/21/Games104_21_108.png"><span class="image-caption">基于光照和BRDF的固定预算重要性采样2</span><br><img src="/images/article/Games104/21/Games104_21_109.png"><span class="image-caption">基于光照和BRDF的固定预算重要性采样3</span><br><img src="/images/article/Games104/21/Games104_21_110.png"><span class="image-caption">基于光照和BRDF的固定预算重要性采样4</span></p><h4 id="去噪和空间探测滤波（Denoising-and-Spatial-Probe-Filtering）"><a href="#去噪和空间探测滤波（Denoising-and-Spatial-Probe-Filtering）" class="headerlink" title="去噪和空间探测滤波（Denoising and Spatial Probe Filtering）"></a>去噪和空间探测滤波（Denoising and Spatial Probe Filtering）</h4><p>为了进一步提升渲染效果我们还需要对图像进行滤波降噪。<br><img src="/images/article/Games104/21/Games104_21_111.png"><span class="image-caption">去噪：探测器的空间滤波</span><br><img src="/images/article/Games104/21/Games104_21_112.png"><span class="image-caption">去噪：从邻居那里收集光线</span><br><img src="/images/article/Games104/21/Games104_21_113.png"><span class="image-caption">去噪：从邻居那里收集光线2</span><br><img src="/images/article/Games104/21/Games104_21_114.png"><span class="image-caption">夹角距离不匹配</span><br><img src="/images/article/Games104/21/Games104_21_115.png"><span class="image-caption">夹角距离不匹配2</span><br><img src="/images/article/Games104/21/Games104_21_116.png"><span class="image-caption">夹角距离不匹配3</span></p><h4 id="世界空间探测器和射线连接（World-Space-Probes-and-Ray-Connecting）"><a href="#世界空间探测器和射线连接（World-Space-Probes-and-Ray-Connecting）" class="headerlink" title="世界空间探测器和射线连接（World Space Probes and Ray Connecting）"></a>世界空间探测器和射线连接（World Space Probes and Ray Connecting）</h4><p><img src="/images/article/Games104/21/Games104_21_117.png"><span class="image-caption">世界空间光线缓存</span><br><img src="/images/article/Games104/21/Games104_21_118.png"><span class="image-caption">世界空间光线缓存2</span><br><img src="/images/article/Games104/21/Games104_21_119.png"><span class="image-caption">连接射线</span><br><img src="/images/article/Games104/21/Games104_21_120.png"><span class="image-caption">连接射线2</span><br><img src="/images/article/Games104/21/Games104_21_121.png"><span class="image-caption">连接射线3</span><br><img src="/images/article/Games104/21/Games104_21_122.png"><span class="image-caption">连接射线4</span><br><img src="/images/article/Games104/21/Games104_21_123.png"><span class="image-caption">连接射线5</span><br><img src="/images/article/Games104/21/Games104_21_124.png"><span class="image-caption">放置和缓存</span><br><img src="/images/article/Games104/21/Games104_21_125.png"><span class="image-caption">没有世界空间探测器</span><br><img src="/images/article/Games104/21/Games104_21_126.png"><span class="image-caption">有世界空间探测器</span></p><h3 id="流明：阴影（Shading-Full-Pixels-with-Screen-Space-Probes）"><a href="#流明：阴影（Shading-Full-Pixels-with-Screen-Space-Probes）" class="headerlink" title="流明：阴影（Shading Full Pixels with Screen Space Probes）"></a>流明：阴影（Shading Full Pixels with Screen Space Probes）</h3><p><img src="/images/article/Games104/21/Games104_21_127.png"><span class="image-caption">使用屏幕空间探测器着色全像素</span><br><img src="/images/article/Games104/21/Games104_21_128.png"><span class="image-caption">与SH的最终集成</span></p><h3 id="流明：性能与结果（Overall-Performance-and-Result）"><a href="#流明：性能与结果（Overall-Performance-and-Result）" class="headerlink" title="流明：性能与结果（Overall, Performance and Result）"></a>流明：性能与结果（Overall, Performance and Result）</h3><p><img src="/images/article/Games104/21/Games104_21_129.png"><span class="image-caption">不同跟踪方法的速度</span><br><img src="/images/article/Games104/21/Games104_21_130.png"><span class="image-caption">SDF生成</span><br><img src="/images/article/Games104/21/Games104_21_131.png"><span class="image-caption">过程</span><br><img src="/images/article/Games104/21/Games104_21_132.png"><span class="image-caption">SSGI关闭</span><br><img src="/images/article/Games104/21/Games104_21_133.png"><span class="image-caption">SSGI开启</span><br><img src="/images/article/Games104/21/Games104_21_134.png"><span class="image-caption">表现</span><br><img src="/images/article/Games104/21/Games104_21_135.png"><span class="image-caption">表现2</span><br><img src="/images/article/Games104/21/Games104_21_136.png"><span class="image-caption">表现3</span><br><img src="/images/article/Games104/21/Games104_21_137.png"><span class="image-caption">表现4</span><br><img src="/images/article/Games104/21/Games104_21_138.png"><span class="image-caption">表现5</span><br><img src="/images/article/Games104/21/Games104_21_139.png"><span class="image-caption">表现6</span></p><h2 id="结论（Conclusion）"><a href="#结论（Conclusion）" class="headerlink" title="结论（Conclusion）"></a>结论（Conclusion）</h2><p><img src="/images/article/Games104/21/Games104_21_140.png"><span class="image-caption">真实渲染的复杂性</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/10/09/GAMES104-NOTES-21.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1oe411u7DJ/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV1Ya411g7Th/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture21_Dynamic%20Global%20Illumination%20and%20Lumen_Advance%20Topic.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 面向数据编程与任务系统（二十）</title>
      <link href="/posts/8a707622.html"/>
      <url>/posts/8a707622.html</url>
      
        <content type="html"><![CDATA[<h2 id="并行编程基础（Basics-of-Parallel-Programming）"><a href="#并行编程基础（Basics-of-Parallel-Programming）" class="headerlink" title="并行编程基础（Basics of Parallel Programming）"></a>并行编程基础（Basics of Parallel Programming）</h2><p>随着硬件技术的发展，芯片中晶体管的数量已经接近了物理极限。因此在现代计算机中会使用<b>多核(multi-core)</b>处理器来进一步提升计算性能。<br><img src="/images/article/Games104/20/Games104_20_01.png"><span class="image-caption">摩尔定律和多核定律的上限</span></p><h3 id="进程和线程（Process-and-Thread）"><a href="#进程和线程（Process-and-Thread）" class="headerlink" title="进程和线程（Process and Thread）"></a>进程和线程（Process and Thread）</h3><p><b>进程(process)</b>和<b>线程(thread)</b>是并行编程会涉及到的基本概念。简单来说一个程序就是一个进程，它拥有自己的内存空间；而一个进程可以拥有很多线程，它们会共享进程指向的同一片内存数据。<br><img src="/images/article/Games104/20/Games104_20_02.png"><span class="image-caption">进程和线程</span></p><h3 id="多任务处理的类型（Types-of-Multitasking）"><a href="#多任务处理的类型（Types-of-Multitasking）" class="headerlink" title="多任务处理的类型（Types of Multitasking）"></a>多任务处理的类型（Types of Multitasking）</h3><p>对于多核的计算机我们希望能够充分利用不同的计算核心来提升程序的性能。根据处理器管理任务的不同可以把进程调度分为两种：<b>抢占式(preemptive multitasking)</b>和<b>非抢占式(non-preemptive multitasking)</b>式。preemptive multitasking是由调度器来控制任务的切换，而non-preemptive multitasking则是由任务自身来进行控制。<br><img src="/images/article/Games104/20/Games104_20_03.png"><span class="image-caption">多任务处理的类型</span></p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>线程在进行切换时会产生额外的开销，因此在游戏引擎中我们希望尽可能减少线程的上下文切换。<br><img src="/images/article/Games104/20/Games104_20_04.png"><span class="image-caption">线程上下文切换</span></p><h3 id="并行计算中的并行问题（Parallel-Problems-in-Parallel-Computing）"><a href="#并行计算中的并行问题（Parallel-Problems-in-Parallel-Computing）" class="headerlink" title="并行计算中的并行问题（Parallel Problems in Parallel Computing）"></a>并行计算中的并行问题（Parallel Problems in Parallel Computing）</h3><p>在并行程序中我们希望不同的任务之间互不打扰，只需要在程序最后把所有的计算结果进行汇总就好。这样的程序往往有着非常高的运行效率，比如说Monte Carlo模拟就是典型的例子。不过现实中的程序往往不会这样理想，很多任务之间存在各种相互依赖，这会降低程序的运行效率。<br><img src="/images/article/Games104/20/Games104_20_05.png"><span class="image-caption">并行计算中的并行问题</span></p><h3 id="并行编程中的数据竞争（Data-Race-in-Parallel-Programming）"><a href="#并行编程中的数据竞争（Data-Race-in-Parallel-Programming）" class="headerlink" title="并行编程中的数据竞争（Data Race in Parallel Programming）"></a>并行编程中的数据竞争（Data Race in Parallel Programming）</h3><p><b>data race</b>是编写并行程序中最常见的问题，当不同的线程想要访问并修改同一块内存时就会产生data race。由于线程的调度是不可预料的，data race会导致程序的计算结果出现各种各样的问题。<br><img src="/images/article/Games104/20/Games104_20_06.png"><span class="image-caption">并行编程中的数据竞争</span></p><h4 id="阻塞算法（Blocking-Algorithm）"><a href="#阻塞算法（Blocking-Algorithm）" class="headerlink" title="阻塞算法（Blocking Algorithm）"></a>阻塞算法（Blocking Algorithm）</h4><p>处理data race最简单的方式是给程序<b>上锁(lock)</b>，这样可以保证同一时间只能有一个线程对指定的内存区域进行访问。锁之间的程序片断称为<b>critical section</b>，当某个线程执行critical section时其它需要访问同一内存的线程会被强制等待。<br><img src="/images/article/Games104/20/Games104_20_07.png"><span class="image-caption">阻塞算法</span></p><p>尽管使用锁可以保证程序的正确执行，但锁的存在会影响程序的并行性。更严重的是它可能会产生<b>死锁(dead lock)</b>的现象从而阻塞程序的运行。因此在编写并行程序时需要注意尽可能减少锁的使用。<br><img src="/images/article/Games104/20/Games104_20_08.png"><span class="image-caption">锁的其他问题</span></p><h4 id="原子操作（Atomic-Operation）"><a href="#原子操作（Atomic-Operation）" class="headerlink" title="原子操作（Atomic Operation）"></a>原子操作（Atomic Operation）</h4><p>处理data race的另一种常用方法是使用<b>原子操作(atomic operation)</b>。原子操作是硬件层面实现的最基本操作，它无法同时被多个CPU一起执行。利用原子操作可以实现无锁的程序并行，从而极大地提升运行效率。<br><img src="/images/article/Games104/20/Games104_20_09.png"><span class="image-caption">原子操作：无锁定编程</span><br><img src="/images/article/Games104/20/Games104_20_10.png"><span class="image-caption">锁定空闲与等待空闲</span></p><h4 id="更复杂的重新排序优化（Complier-Reordering-Optimizations）"><a href="#更复杂的重新排序优化（Complier-Reordering-Optimizations）" class="headerlink" title="更复杂的重新排序优化（Complier Reordering Optimizations）"></a>更复杂的重新排序优化（Complier Reordering Optimizations）</h4><p>另一方面需要注意的是现代编译器对于高级语言是可以进行自动优化的。通过调整代码的执行顺序可以提升单线程程序的运行效率，但对于多线程的情况这种调整则可能会导致一些问题。<br><img src="/images/article/Games104/20/Games104_20_11.png"><span class="image-caption">编译器重新排序优化</span><br><img src="/images/article/Games104/20/Games104_20_12.png"><span class="image-caption">内存重排序问题</span></p><p>实际上很多的现代芯片出于种种方面的考虑都无法保证多线程情况下编译后代码的执行顺序。<br><img src="/images/article/Games104/20/Games104_20_13.png"><span class="image-caption">cpu的无序执行</span></p><h2 id="游戏引擎并行架构（Parallel-Framework-of-Game-Engine）"><a href="#游戏引擎并行架构（Parallel-Framework-of-Game-Engine）" class="headerlink" title="游戏引擎并行架构（Parallel Framework of Game Engine）"></a>游戏引擎并行架构（Parallel Framework of Game Engine）</h2><h3 id="固定多线程（Fixed-Multi-Thread）"><a href="#固定多线程（Fixed-Multi-Thread）" class="headerlink" title="固定多线程（Fixed Multi-Thread）"></a>固定多线程（Fixed Multi-Thread）</h3><p>游戏引擎在使用多线程时最经典的架构是<b>fixed multi-thread</b>，此时引擎中的每个系统都各自拥有一个线程。在每一帧开始时会通过线程间的通信来交换数据，然后各自执行自己的任务。<br><img src="/images/article/Games104/20/Games104_20_14.png"><span class="image-caption">固定多线程</span></p><p>fixed multi-thread的一个缺陷在于它很难保证不同线程上负载是一致的。实际上不同线程之间负载的差异往往非常巨大，很多时候一些线程已经完成了自己的任务却必须要等待其它线程结束。这就造成了计算资源的浪费。<br><img src="/images/article/Games104/20/Games104_20_15.png"><span class="image-caption">固定多线程的问题</span></p><h3 id="线程分叉连接（Thread-Fork-Join）"><a href="#线程分叉连接（Thread-Fork-Join）" class="headerlink" title="线程分叉连接（Thread Fork-Join）"></a>线程分叉连接（Thread Fork-Join）</h3><p>另一种并行处理的方式是<b>fork-join</b>。对于某些负载比较高的系统我们可以实现申请一系列线程，当需要执行计算时通过fork操作把不同的计算任务分配到各个线程中并最后汇总到一起。<br><img src="/images/article/Games104/20/Games104_20_16.png"><span class="image-caption">线程分叉连接</span></p><p>fork-join的缺陷在于有很多的任务是无法事先预测具体的负载的。<br><img src="/images/article/Games104/20/Games104_20_17.png"><span class="image-caption">线程分叉连接的问题</span></p><p>在虚幻引擎中设计了name thread和worker thread两种类型的线程。其中name thread对应引擎中的不同系统，而worker thread则是系统中具体计算任务的线程。<br><img src="/images/article/Games104/20/Games104_20_18.png"><span class="image-caption">虚幻并行框架</span></p><h3 id="任务图（Task-Graph）"><a href="#任务图（Task-Graph）" class="headerlink" title="任务图（Task Graph）"></a>任务图（Task Graph）</h3><p>除此之外还可以使用<b>task graph</b>来处理多线程，task graph会根据不同任务之间的依赖性来决定具体的执行顺序以及需要进行并行的任务。<br><img src="/images/article/Games104/20/Games104_20_19.png"><span class="image-caption">任务图</span><br><img src="/images/article/Games104/20/Games104_20_20.png"><span class="image-caption">按链接构建任务图</span></p><h2 id="任务系统（Job-System）"><a href="#任务系统（Job-System）" class="headerlink" title="任务系统（Job System）"></a>任务系统（Job System）</h2><h3 id="协程（Coroutine）"><a href="#协程（Coroutine）" class="headerlink" title="协程（Coroutine）"></a>协程（Coroutine）</h3><p><b>协程(coroutine)</b>是一种轻量的线程上下文切换机制，它允许函数在执行过程中临时切换到协程上然后再切换回来。和线程相比，协程无需硬件层面上的数据切换，可以由程序自己进行定义，也不需要进入系统内核执行interruption。因此协程要比线程切换高效的多。<br><img src="/images/article/Games104/20/Games104_20_21.png"><span class="image-caption">协程</span><br><img src="/images/article/Games104/20/Games104_20_22.png"><span class="image-caption">协程VS线程</span></p><h4 id="堆叠协程（Stackful-Coroutine）"><a href="#堆叠协程（Stackful-Coroutine）" class="headerlink" title="堆叠协程（Stackful Coroutine）"></a>堆叠协程（Stackful Coroutine）</h4><p>协程有两种实现方式。首先是使用栈来保存函数切换时的状态，当协程切换回来后根据栈上的数据来恢复之前的状态。<br><img src="/images/article/Games104/20/Games104_20_23.png"><span class="image-caption">堆栈协程</span></p><h4 id="无堆叠协程（Stackless-Coroutine）"><a href="#无堆叠协程（Stackless-Coroutine）" class="headerlink" title="无堆叠协程（Stackless Coroutine）"></a>无堆叠协程（Stackless Coroutine）</h4><p>另一种实现方式是不保存函数切换时的状态，当协程切换回来后按照当前的状态继续执行程序。<br><img src="/images/article/Games104/20/Games104_20_24.png"><span class="image-caption">无堆叠协程</span></p><p>在实践中一般推荐使用基于栈来实现的协程。尽管它在进行切换时的开销要稍微多一些，但可以避免状态改变导致的各种问题。<br><img src="/images/article/Games104/20/Games104_20_25.png"><span class="image-caption">堆栈协程VS无堆叠协程</span></p><h3 id="基于管线的任务系统（Fiber-Based-Job-System）"><a href="#基于管线的任务系统（Fiber-Based-Job-System）" class="headerlink" title="基于管线的任务系统（Fiber-Based Job System）"></a>基于管线的任务系统（Fiber-Based Job System）</h3><p>基于协程的思想可以实现<b>fiber-based job system</b>。在这种任务系统中job会通过fiber来进行执行，在线程进行计算时通过fiber的切换来减少线程调度的开销。<br><img src="/images/article/Games104/20/Games104_20_26.png"><span class="image-caption">基于管线的任务系统</span></p><p>对于多核的情况我们希望尽可能保证一个线程对应一个核(包括逻辑核)，这样可以进一步减少线程切换带来的额外开销。<br><img src="/images/article/Games104/20/Games104_20_27.png"><span class="image-caption">为一个核心的一个工作线程</span></p><p>在执行计算时根据程序的需要生成大量的job，然后调度器根据线程负载分配到合适的线程以及线程上的fiber中。<br><img src="/images/article/Games104/20/Games104_20_28.png"><span class="image-caption">基于管线的任务系统2</span><br><img src="/images/article/Games104/20/Games104_20_29.png"><span class="image-caption">任务调度程序-全局任务</span></p><p>在执行job时根据计算顺序可以分为FIFO以及LIFO两种模式，在实践工程中一般会选择LIF。<br><img src="/images/article/Games104/20/Games104_20_30.png"><span class="image-caption">先进先出和先进后出模式</span></p><p>当job出现依赖时会把当前的job移动到等待区然后执行线程中的下一个job。这样的方式可以减少CPU的等待，提高程序效率。<br><img src="/images/article/Games104/20/Games104_20_31.png"><span class="image-caption">任务调度程序-任务依赖性</span></p><p>如果出现了线程闲置的情况，调度器会把其他线程中的job移动到闲置线程中进行计算。<br><img src="/images/article/Games104/20/Games104_20_32.png"><span class="image-caption">任务调度程序-任务拉取</span></p><p>和上面介绍过的多线程方法相比，任务系统可以更好地利用多核并且避免线程切换从而提升计算性能。不过目前原生C++暂不支持协程，而且在不同的操作系统中任务系统的实现往往是不同的。<br><img src="/images/article/Games104/20/Games104_20_33.png"><span class="image-caption">任务系统的利与弊</span></p><h2 id="编程规范（Programming-Paradigms）"><a href="#编程规范（Programming-Paradigms）" class="headerlink" title="编程规范（Programming Paradigms）"></a>编程规范（Programming Paradigms）</h2><p>除了硬件之外，<b>编程范式(programming paradigms)</b>对于程序的性能也会有一定的影响。在游戏引擎中我们会使用各种类型的编程范式来实现各种各样的功能。<br><img src="/images/article/Games104/20/Games104_20_34.png"><span class="image-caption">游戏引擎的编程规范</span></p><h3 id="面向过程的程序设计（Procedural-Oriented-Programming-POP）"><a href="#面向过程的程序设计（Procedural-Oriented-Programming-POP）" class="headerlink" title="面向过程的程序设计（Procedural-Oriented Programming - POP）"></a>面向过程的程序设计（Procedural-Oriented Programming - POP）</h3><p>早期的游戏一般是使用<b>面向过程编程(procedural-oriented programming, POP)</b>来实现的。<br><img src="/images/article/Games104/20/Games104_20_35.png"><span class="image-caption">面向过程的程序设计</span></p><h3 id="面向对象编程（Object-Oriented-Programming-OOP）"><a href="#面向对象编程（Object-Oriented-Programming-OOP）" class="headerlink" title="面向对象编程（Object-Oriented Programming - OOP）"></a>面向对象编程（Object-Oriented Programming - OOP）</h3><p>随着游戏系统变得不断复杂，<b>面向对象编程(object-oriented programming, OOP)</b>的思想在现代游戏引擎中起着越来越重要的作用。<br><img src="/images/article/Games104/20/Games104_20_36.png"><span class="image-caption">面向对象编程</span></p><h3 id="OOP的问题（Problems-of-OOP）"><a href="#OOP的问题（Problems-of-OOP）" class="headerlink" title="OOP的问题（Problems of OOP）"></a>OOP的问题（Problems of OOP）</h3><p>然而在大量的实践中人们发现OOP也不是完美的，一个最常见的问题是OOP存在二义性：角色的攻击行为既可以写在角色身上，也可以写在被攻击者身上。<br><img src="/images/article/Games104/20/Games104_20_37.png"><span class="image-caption">OOP的问题：将代码放在哪里？</span></p><p>同时OOP中存在大量的继承关系，有时很难去查询对象的方法具体是在那个类中实现的。<br><img src="/images/article/Games104/20/Games104_20_38.png"><span class="image-caption">OOP的问题：继承树中的方法散射</span></p><p>另外OOP中的基类往往需要提供非常多的功能，对于很多派生子类来说这样的基类实在过于臃肿了。<br><img src="/images/article/Games104/20/Games104_20_39.png"><span class="image-caption">OOP的问题：混乱的的继承类</span></p><p>OOP最大的问题在于它的性能可能是很低的。尽管OOP很符合人的认识，但对象的数据往往分布在不同的内存区域上。这就导致程序运行时会浪费大量的时间来读取数据。<br><img src="/images/article/Games104/20/Games104_20_40.png"><span class="image-caption">OOP的问题：性能</span></p><p>最后，OOP的可测试性非常差。当我们想要去测试对象的某个方法是否按照我们的期望运作时，往往需要从头创建出整个对象，这与单元测试的思想是相违背的。<br><img src="/images/article/Games104/20/Games104_20_41.png"><span class="image-caption">OOP的问题：可检验性</span></p><h2 id="面向数据编程（Data-Oriented-Programming-DOP）"><a href="#面向数据编程（Data-Oriented-Programming-DOP）" class="headerlink" title="面向数据编程（Data-Oriented Programming - DOP）"></a>面向数据编程（Data-Oriented Programming - DOP）</h2><p><b>面向数据编程(data-oriented programming, DOP)</b>是现代游戏引擎中越来越流行的一种编程范式。现代计算机的发展趋势是CPU运行速度越来越快，但是相对地内存访问的速度却跟不上CPU计算的速度。<br><img src="/images/article/Games104/20/Games104_20_42.png"><span class="image-caption">处理器内存性能差距</span></p><h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><p>为了解决的问题人们设计了<b>缓存(cache)</b>这样的机制来加快内存的访问。一般来说现代计算机都有多级缓存系统，越底层的缓存容量越小但访问速度越快。通过缓存机制我们可以把内存中的数据先放到缓存中来加快CPU的访问速度。<br><img src="/images/article/Games104/20/Games104_20_43.png"><span class="image-caption">内存-高速缓存的演变</span></p><h3 id="局部性原理（Principle-of-Locality）"><a href="#局部性原理（Principle-of-Locality）" class="headerlink" title="局部性原理（Principle of Locality）"></a>局部性原理（Principle of Locality）</h3><p>利用缓存机制进行编程时就需要考虑数据的<b>locality</b>。<br><img src="/images/article/Games104/20/Games104_20_44.png"><span class="image-caption">内存-高速缓存的演变</span></p><h4 id="单指令多数据（Single-Instruction-Multiple-Data-SIMD）"><a href="#单指令多数据（Single-Instruction-Multiple-Data-SIMD）" class="headerlink" title="单指令多数据（Single Instruction Multiple Data - SIMD）"></a>单指令多数据（Single Instruction Multiple Data - SIMD）</h4><p><b>SIMD<b>是利用缓存机制实现高性能编程的经典案例。现代CPU基本都实现了SIMD机制，这样可以在一个指令中同时处理4个操作。因此我们可以把数据尽可能组织成SIMD的格式来对程序进行加速。<br><img src="/images/article/Games104/20/Games104_20_45.png"><span class="image-caption">单指令多数据</span></b></b></p><b><b><h4 id="最近最少使用（Least-Recently-Used-LRU）"><a href="#最近最少使用（Least-Recently-Used-LRU）" class="headerlink" title="最近最少使用（Least Recently Used - LRU）"></a>最近最少使用（Least Recently Used - LRU）</h4><p><b>LRU<b>同样是高性能编程中的常用的技巧。当缓存满了后系统会把最不常用的数据置换出去，只留下近期用过的数据从而提升缓存的利用率。在实践中也会采用随机丢弃数据的策略，可以证明这样的策略拥有更好的性能。<br><img src="/images/article/Games104/20/Games104_20_46.png"><span class="image-caption">最近最少使用</span></b></b></p><b><b><h3 id="超高速缓冲存储器线（Cache-Line）"><a href="#超高速缓冲存储器线（Cache-Line）" class="headerlink" title="超高速缓冲存储器线（Cache Line）"></a>超高速缓冲存储器线（Cache Line）</h3><p>当缓存中的数据进行读写时，不是对单个数据进行操作而是直接读写一条cache line上的全部数据(一般是64 byte)。实际上CPU的读写操作都是以cache line作为单位来执行的，因此需要操作系统来保证CPU读写缓存以及内存数据时的顺序和一致性。<br><img src="/images/article/Games104/20/Games104_20_47.png"><span class="image-caption">超高速缓冲存储器线</span></p><p>因此我们在设计数据的存储形式时就可以利用cache line的机制来加速访问。以矩阵这种数据格式为例，按照行来进行存储的矩阵往往要比按照列来存储的有更高的读写效率。<br><img src="/images/article/Games104/20/Games104_20_48.png"><span class="image-caption">高速缓存未命中</span></p><h3 id="面向数据的程序设计（Data-Oriented-Programming-DOP）"><a href="#面向数据的程序设计（Data-Oriented-Programming-DOP）" class="headerlink" title="面向数据的程序设计（Data-Oriented Programming - DOP）"></a>面向数据的程序设计（Data-Oriented Programming - DOP）</h3><p>DOP的核心思想在于把游戏世界(包括代码)认为是数据的集合，在编写程序时要尽可能利用缓存同时避免cache miss。<br><img src="/images/article/Games104/20/Games104_20_49.png"><span class="image-caption">面向数据的程序设计</span><br><img src="/images/article/Games104/20/Games104_20_50.png"><span class="image-caption">指令也是数据</span></p><p>因此在DOP中我们会把数据和代码看做一个整体，同时使它们在缓存中的分布尽可能地集中。<br><img src="/images/article/Games104/20/Games104_20_51.png"><span class="image-caption">保持代码和数据在内存中</span></p><h2 id="性能敏感编程（Performance-Sensitive-Programming）"><a href="#性能敏感编程（Performance-Sensitive-Programming）" class="headerlink" title="性能敏感编程（Performance-Sensitive Programming）"></a>性能敏感编程（Performance-Sensitive Programming）</h2><h3 id="减少顺序相关性（Reducing-Order-Dependency）"><a href="#减少顺序相关性（Reducing-Order-Dependency）" class="headerlink" title="减少顺序相关性（Reducing Order Dependency）"></a>减少顺序相关性（Reducing Order Dependency）</h3><p>那么如何基于DOP的思想来设计高性能的程序呢？首先我们需要避免程序对于代码执行顺序的依赖。<br><img src="/images/article/Games104/20/Games104_20_52.png"><span class="image-caption">减少顺序相关性</span></p><h3 id="在高速缓存行中的错误共享（False-Sharing-in-Cache-Line）"><a href="#在高速缓存行中的错误共享（False-Sharing-in-Cache-Line）" class="headerlink" title="在高速缓存行中的错误共享（False Sharing in Cache Line）"></a>在高速缓存行中的错误共享（False Sharing in Cache Line）</h3><p>对于多线程的程序要避免两个线程同时访问同一块数据，我们希望不同的线程之间尽可能地相互独立。<br><img src="/images/article/Games104/20/Games104_20_53.png"><span class="image-caption">在高速缓存行中的错误共享</span></p><h3 id="分支预测（Branch-Prediction）"><a href="#分支预测（Branch-Prediction）" class="headerlink" title="分支预测（Branch Prediction）"></a>分支预测（Branch Prediction）</h3><p>对于包含分支的程序，CPU会对程序可能选择的分支进行预测并把最有可能直线的指令提前送到缓存中，如果程序选择了不常见的分支则往往需要从内存中重新读取相应的指令从而降低程序性能。<br><img src="/images/article/Games104/20/Games104_20_54.png"><span class="image-caption">分支预测</span></p><p>因此在设计程序时要尽可能保证具有相同分支的程序在一起执行，比如说可以通过对数据进行排序的方式来避免错误的分支预测。<br><img src="/images/article/Games104/20/Games104_20_55.png"><span class="image-caption">分支预测2</span><br><img src="/images/article/Games104/20/Games104_20_56.png"><span class="image-caption">分支预测3</span></p><p>更通用的方法是按照业务逻辑对数据进行分组，每一组中只使用相同的函数进行处理。这样可以完全避免分支判断从而极大地提升程序性能。<br><img src="/images/article/Games104/20/Games104_20_57.png"><span class="image-caption">程序处理</span></p><h2 id="性能敏感数据组织（Performance-Sensitive-Programming）"><a href="#性能敏感数据组织（Performance-Sensitive-Programming）" class="headerlink" title="性能敏感数据组织（Performance-Sensitive Programming）"></a>性能敏感数据组织（Performance-Sensitive Programming）</h2><p>当然数据的组织方式对于程序性能也有巨大的影响。<br><img src="/images/article/Games104/20/Games104_20_58.png"><span class="image-caption">减少内存依赖性</span></p><p>一个经典的案例是AOS和SOA。根据OOP的思想，我们可以把数据封装到不同对象中然后使用一个数组作为这些对象的容器，这种组织方式称为<b>AOS(array of structure)</b>；或者直接对数据进行封装把所有数据放到一个巨大的对象中，称为<b>SOA(structure of array)</b>。当程序需要对数据进行访问时AOS往往会产生大量的cache miss，因此在高性能编程中更推荐使用SOA的组织方式。<br><img src="/images/article/Games104/20/Games104_20_59.png"><span class="image-caption">结构阵列vVS阵列结构</span></p><h2 id="ECS架构（Entity-Component-System-ECS）"><a href="#ECS架构（Entity-Component-System-ECS）" class="headerlink" title="ECS架构（Entity Component System - ECS）"></a>ECS架构（Entity Component System - ECS）</h2><p>本节课最后介绍了现代游戏引擎中的<b>ECS架构(entity component system)</b>。回忆在前面的课程中我们介绍过基于OOP来对组件进行编程，然后通过继承的方式来实现具体的GO。就像前面介绍过的那样，这种编程范式是相对低效的。<br><img src="/images/article/Games104/20/Games104_20_60.png"><span class="image-caption">概述：基于组件的设计</span><br><img src="/images/article/Games104/20/Games104_20_61.png"><span class="image-caption">概述：基于组件的设计2</span></p><p>而在ECS架构中则使用了entity的概念将不同的组件组织起来。entity实际上只是一个ID，用来指向一组component。而ECS架构中的component则只包括各种类型的数据，不包含任何具体的业务逻辑。当需要执行具体的计算和逻辑时则需要调用system来修改component中的数据。这样游戏中的数据可以集中到一起进行管理，从而极大地提升数据读写的效率。<br><img src="/images/article/Games104/20/Games104_20_62.png"><span class="image-caption">ECS架构</span></p><h3 id="Unity中的面向数据技术栈的系统（Unity-Data-Oriented-Tech-Stacks）"><a href="#Unity中的面向数据技术栈的系统（Unity-Data-Oriented-Tech-Stacks）" class="headerlink" title="Unity中的面向数据技术栈的系统（Unity Data-Oriented Tech Stacks）"></a>Unity中的面向数据技术栈的系统（Unity Data-Oriented Tech Stacks）</h3><p><b>unity中的DOTS系统(data-oriented tech stacks)</b>就是基于ECS架构来实现的，同时它还结合了C#任务系统用来进行并行化以及设计了burst编译器来优化代码。<br><img src="/images/article/Games104/20/Games104_20_63.png"><span class="image-caption">DOTS系统</span></p><p>在unity的ECS架构中设计了archetype来对不同类型的entity进行抽象，这样具有相似功能的entity可以组织到一起方便管理。<br><img src="/images/article/Games104/20/Games104_20_64.png"><span class="image-caption">Unity ECS-原型</span></p><p>在内存中系统会为不同的archetype分配不同大小的存储空间，称为chunk。<br><img src="/images/article/Games104/20/Games104_20_65.png"><span class="image-caption">Unity ECS-原型中的数据布局</span></p><p>对于system而言只需要一次性更新chunk中的相关数据即可。<br><img src="/images/article/Games104/20/Games104_20_66.png"><span class="image-caption">Unity ECS-系统</span></p><p>而为了支持这样的高性能架构还需要native级别的任务系统、容器以及安全检查，也因此unity需要定制编译器来把C#代码编译成更底层的代码。<br><img src="/images/article/Games104/20/Games104_20_67.png"><span class="image-caption">Unity C# 任务系统</span><br><img src="/images/article/Games104/20/Games104_20_68.png"><span class="image-caption">Unity C# 任务系统-本地容器</span><br><img src="/images/article/Games104/20/Games104_20_69.png"><span class="image-caption">Unity C# 任务系统-安全系统</span><br><img src="/images/article/Games104/20/Games104_20_70.png"><span class="image-caption">高性能的C#和Burst编译器</span></p><h3 id="虚幻质量系统（Unreal-Mass-System）"><a href="#虚幻质量系统（Unreal-Mass-System）" class="headerlink" title="虚幻质量系统（Unreal Mass System）"></a>虚幻质量系统（Unreal Mass System）</h3><p>虚幻引擎中使用了<b>Mass</b>系统来实现ECS架构。<br><img src="/images/article/Games104/20/Games104_20_71.png"><span class="image-caption">虚幻Mass框架</span></p><p>Mass系统与DOTS非常类似，都使用了entity作为component的索引ID。<br><img src="/images/article/Games104/20/Games104_20_72.png"><span class="image-caption">Mass实体</span></p><p>Mass系统中的component称为fragment，用来强调它只具有数据的属性。<br><img src="/images/article/Games104/20/Games104_20_73.png"><span class="image-caption">Mass实体-组件</span></p><p>而system则称为processor，这表示它只承担业务逻辑的功能。<br><img src="/images/article/Games104/20/Games104_20_74.png"><span class="image-caption">Mass实体-系统</span></p><p>processor需要实现query和excute两个接口。前者表示在内存中选出所需的entity，而后者则是不同system执行的逻辑。<br><img src="/images/article/Games104/20/Games104_20_75.png"><span class="image-caption">Mass实体-片段查询</span><br><img src="/images/article/Games104/20/Games104_20_76.png"><span class="image-caption">Mass实体-执行</span><br><img src="/images/article/Games104/20/Games104_20_77.png"><span class="image-caption">所有你需要知道的关于性能的东西</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/08/31/GAMES104-NOTES-20.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1EP411V7jx/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV1Md4y1G7zp/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/Game104_Lecture20_Data-Oriented%20Programming%20-Advance%20Topics.pdf">课件PPT</a></p></b></b></b></b>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 网络游戏的进阶架构（十九）</title>
      <link href="/posts/d8819d45.html"/>
      <url>/posts/d8819d45.html</url>
      
        <content type="html"><![CDATA[<h2 id="位移同步（Character-Movement-Replication）"><a href="#位移同步（Character-Movement-Replication）" class="headerlink" title="位移同步（Character Movement Replication）"></a>位移同步（Character Movement Replication）</h2><p><b>角色位移同步(character movement replication)</b>是现代大型网络游戏必须要实现的功能。由于网络环境的不稳定，玩家操作角色在自己视角和其他玩家视角下的行为往往会有一定的延迟，即角色在其他玩家视角下的动作会滞后于操作玩家的第一视角。<br><img src="/images/article/Games104/19/Games104_19_01.png"><span class="image-caption">位移同步</span></p><h3 id="内插和外插（Interpolation-Extrapolation）"><a href="#内插和外插（Interpolation-Extrapolation）" class="headerlink" title="内插和外插（Interpolation &amp; Extrapolation）"></a>内插和外插（Interpolation &amp; Extrapolation）</h3><p>在这种情况下我们可以使用<b>内插(interpolation)</b>和<b>外插(extrapolation)</b>两种插值方法来缓解延迟。<br><img src="/images/article/Games104/19/Games104_19_02.png"><span class="image-caption">内插和外插</span></p><h4 id="内插（Interpolation）"><a href="#内插（Interpolation）" class="headerlink" title="内插（Interpolation）"></a>内插（Interpolation）</h4><p>内插是指利用已知的控制点来获得中间的状态。当网络存在波动时利用内插的方法可以保证角色的动作仍然是足够平滑的。<br><img src="/images/article/Games104/19/Games104_19_03.png"><span class="image-caption">插值平滑状态</span></p><p>在具体进行插值时还可以人工设置一个offset来保证buffer中有足够多的控制点，这样虽然会提高一些延迟但可以获得更加光滑稳定的插值结果。<br><img src="/images/article/Games104/19/Games104_19_04.png"><span class="image-caption">缓冲区状态和延迟渲染</span></p><p>当然内插也存在一些问题。由于内插加剧了网络延迟的问题，同样的游戏世界在操作者和其他玩家的视角下会有非常大的差别。这样的问题在一些延迟要求很高的游戏中可能是不可接受的。<br><img src="/images/article/Games104/19/Games104_19_05.png"><span class="image-caption">车辆运动复制的插值挑战</span></p><h4 id="内插（Extrapolation）"><a href="#内插（Extrapolation）" class="headerlink" title="内插（Extrapolation）"></a>内插（Extrapolation）</h4><p>相比于内插，外插的本质是利用已有的信息来预测未来的状态。当我们对网络延迟有一定的估计时就可以通过外插的方法来推断角色的状态。<br><img src="/images/article/Games104/19/Games104_19_06.png"><span class="image-caption">通过外推法估计当前的状态</span></p><p>实际上外插的思想在很多领域都有非常多的应用，dead reckoning算法那就是外插在导航领域的实践。<br><img src="/images/article/Games104/19/Games104_19_07.png"><span class="image-caption">航位推算法</span></p><h3 id="投影速度混合（Projective-Velocity-Blending-PVB）"><a href="#投影速度混合（Projective-Velocity-Blending-PVB）" class="headerlink" title="投影速度混合（Projective Velocity Blending - PVB）"></a>投影速度混合（Projective Velocity Blending - PVB）</h3><p>回到游戏领域的应用中来，<b>projective velocity blending (PVB)</b>是一种使用外插来更新角色位置的算法。假设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.804ex" height="1.791ex" role="img" focusable="false" viewBox="0 -626 797.6 791.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>时刻角色的位置、速度和加速度分别为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="2.126ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 939.6 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mn" transform="translate(536,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.377ex" role="img" focusable="false" viewBox="0 -443 921.6 608.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.185ex" height="1.372ex" role="img" focusable="false" viewBox="0 -441 965.6 606.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>，而收到来自服务器同步的位置、速度和加速度则是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.618ex;" xmlns="http://www.w3.org/2000/svg" width="2.126ex" height="2.335ex" role="img" focusable="false" viewBox="0 -759 939.6 1032.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(536,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(536,-257.5) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.618ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="2.335ex" role="img" focusable="false" viewBox="0 -759 921.6 1032.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(518,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(518,-257.5) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.618ex;" xmlns="http://www.w3.org/2000/svg" width="2.185ex" height="2.335ex" role="img" focusable="false" viewBox="0 -759 965.6 1032.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(562,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(562,-257.5) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>。假设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.804ex" height="1.791ex" role="img" focusable="false" viewBox="0 -626 797.6 791.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.219ex" height="1.756ex" role="img" focusable="false" viewBox="0 -626 980.7 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></g></svg></mjx-container>时间内没有意外状况发生，则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.817ex" height="1.441ex" role="img" focusable="false" viewBox="0 -626 361 637"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container>时刻角色的位置为：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.552ex;" xmlns="http://www.w3.org/2000/svg" width="21.595ex" height="4.588ex" role="img" focusable="false" viewBox="0 -1342 9544.9 2028"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(536,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mi" transform="translate(536,-247) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mo" transform="translate(1119,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msubsup" transform="translate(2174.8,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(536,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(536,-247) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(3336.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msubsup" transform="translate(4336.8,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(518,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(518,-247) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mi" transform="translate(5258.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(5841.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(6841.8,0)"><g data-mml-node="mn" transform="translate(220,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="700" height="60" x="120" y="220"></rect></g><g data-mml-node="msubsup" transform="translate(7781.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(562,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(562,-247) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="msup" transform="translate(8747.4,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mn" transform="translate(394,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container></p><p>我们的目的是通过调整速度使得角色可以在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.219ex" height="1.756ex" role="img" focusable="false" viewBox="0 -626 980.7 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></g></svg></mjx-container>时刻到达位置<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="2.158ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 953.7 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(536,-150) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></g></svg></mjx-container>，因此首先对速度进行插值：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.594ex;" xmlns="http://www.w3.org/2000/svg" width="19.745ex" height="2.424ex" role="img" focusable="false" viewBox="0 -809 8727.4 1071.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mo" transform="translate(1101,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(2156.8,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(3300.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4300.8,0)"><path data-c="1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path></g><g data-mml-node="mo" transform="translate(4883.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msubsup" transform="translate(5272.8,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(518,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(518,-247) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(6416.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(7416.8,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(8338.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.927ex;" xmlns="http://www.w3.org/2000/svg" width="12.12ex" height="4.872ex" role="img" focusable="false" viewBox="0 -1302 5357.2 2153.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path></g><g data-mml-node="mo" transform="translate(860.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1916.6,0)"><g data-mml-node="mrow" transform="translate(529.8,676)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(583.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(1583.4,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><g data-mml-node="mo" transform="translate(1202.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(2203.1,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><rect width="3200.7" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p>上式意味着对速度进行线性插值使得<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.219ex" height="1.756ex" role="img" focusable="false" viewBox="0 -626 980.7 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></g></svg></mjx-container>时刻具有速度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.377ex" role="img" focusable="false" viewBox="0 -443 921.6 608.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>。接下来再对位置进行线性插值即可：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.552ex;" xmlns="http://www.w3.org/2000/svg" width="22.001ex" height="4.588ex" role="img" focusable="false" viewBox="0 -1342 9724.6 2028"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mo" transform="translate(1258,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(2313.8,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(3614.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(4614.8,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mi" transform="translate(5438.1,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6021.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(7021.5,0)"><g data-mml-node="mn" transform="translate(220,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="700" height="60" x="120" y="220"></rect></g><g data-mml-node="msubsup" transform="translate(7961.5,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(562,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mn" transform="translate(562,-247) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="msup" transform="translate(8927.1,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mn" transform="translate(394,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.576ex;" xmlns="http://www.w3.org/2000/svg" width="20.988ex" height="2.407ex" role="img" focusable="false" viewBox="0 -809 9276.6 1063.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g><g data-mml-node="mo" transform="translate(1370.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(2426.3,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mo" transform="translate(3628.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4629,0)"><path data-c="1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path></g><g data-mml-node="mo" transform="translate(5212,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msubsup" transform="translate(5601,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(839.5,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g><g data-mml-node="mi" transform="translate(675,-247) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mo" transform="translate(6907.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(7907.3,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g><g data-mml-node="mo" transform="translate(8887.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br><img src="/images/article/Games104/19/Games104_19_08.png"><span class="image-caption">投影速度混合</span><br><img src="/images/article/Games104/19/Games104_19_09.png"><span class="image-caption">投影速度混合2</span></p><p>这里需要注意的是PVB算法并不符合动力学原理，它仅仅是一种插值方法。</p><h3 id="碰撞问题（Collision-Issues）"><a href="#碰撞问题（Collision-Issues）" class="headerlink" title="碰撞问题（Collision Issues）"></a>碰撞问题（Collision Issues）</h3><p>外插在处理碰撞时会容易产生严重的物体穿插问题。<br><img src="/images/article/Games104/19/Games104_19_10.png"><span class="image-caption">碰撞问题</span><br><img src="/images/article/Games104/19/Games104_19_11.png"><span class="image-caption">碰撞问题2</span><br><img src="/images/article/Games104/19/Games104_19_12.png"><span class="image-caption">碰撞问题3</span><br><img src="/images/article/Games104/19/Games104_19_13.png"><span class="image-caption">碰撞问题4</span></p><p>要处理这样的情况一般需要切换到本地物理引擎来处理碰撞问题，比如说在看门狗2中就使用了这样的方法。<br><img src="/images/article/Games104/19/Games104_19_14.png"><span class="image-caption">碰撞时的物理模拟混合</span></p><h3 id="使用场景（Usage-Scenarios）"><a href="#使用场景（Usage-Scenarios）" class="headerlink" title="使用场景（Usage Scenarios）"></a>使用场景（Usage Scenarios）</h3><p>简单总结一下，对于玩家操作角色经常出现瞬移或是具有很大加速度的情况比较适合内插，对于操作角色比较符合物理规律的情况比较适合外插，而在一些大型在线游戏中还会同时结合这两种插值方法来提升玩家的游戏体验。<br><img src="/images/article/Games104/19/Games104_19_15.png"><span class="image-caption">内插的使用场景</span><br><img src="/images/article/Games104/19/Games104_19_16.png"><span class="image-caption">外插的使用场景</span><br><img src="/images/article/Games104/19/Games104_19_17.png"><span class="image-caption">内插和外插的混合场景</span></p><h2 id="命中判定（Hit-Registration）"><a href="#命中判定（Hit-Registration）" class="headerlink" title="命中判定（Hit Registration）"></a>命中判定（Hit Registration）</h2><p><b>命中判定(hit registration)</b>同样是现代网络游戏必须要提供的基本服务。以FPS游戏为例，从玩家开枪到击中敌人这一过程实际上有着非常大的一段延迟，在各种不确定因素的影响下如何判断玩家确实击中目标就需要一些专门的设计。<br><img src="/images/article/Games104/19/Games104_19_18.png"><span class="image-caption">如何在网络游戏中做爆头</span></p><h3 id="挑战（Challenges）"><a href="#挑战（Challenges）" class="headerlink" title="挑战（Challenges）"></a>挑战（Challenges）</h3><p>命中判定的难点之一在于确定敌人在什么位置。由于网络延迟和插值算法的存在，玩家视角下的目标是落后于服务器上目标的真实位置的。<br><img src="/images/article/Games104/19/Games104_19_19.png"><span class="image-caption">敌人在哪里？</span></p><p>命中判定的另一个难点在于如何判定是否击中了目标。在游戏场景中目标往往是运动的，而且往往会位于一些掩体附近。当弹道不是瞬间命中时就需要一些额外的算法来进行判断。<br><img src="/images/article/Games104/19/Games104_19_20.png"><span class="image-caption">我应该在哪里射击？</span></p><h3 id="客户端命中检测（Client-Side-Hit-Detection）"><a href="#客户端命中检测（Client-Side-Hit-Detection）" class="headerlink" title="客户端命中检测（Client-Side Hit Detection）"></a>客户端命中检测（Client-Side Hit Detection）</h3><p>因此命中判定的目标是保证游戏中的玩家就是否命中的问题能够达成一个<b>共识(consensus)</b>。目前主流的处理方法包括在客户端上进行检测，称为<b>client-side hit detection</b>，以及在服务器端进行判断的<b>server-side hit registration</b>。<br><img src="/images/article/Games104/19/Games104_19_21.png"><span class="image-caption">命中检测</span></p><p>在客户端上进行检测时的基本思想是一切以玩家客户端视角下的结果为准。玩家开枪后的弹道轨迹以及击中判断都先在本地进行，然后发送到服务器上再进行验证。<br><img src="/images/article/Games104/19/Games104_19_22.png"><span class="image-caption">命中检测2</span><br><img src="/images/article/Games104/19/Games104_19_23.png"><span class="image-caption">命中扫描武器与投射武器的比较</span></p><p>在服务器上会对玩家的行为进行一些验证从而保证确实击中了目标。当然在实际的游戏中这个验证过程是相当复杂的，涉及到大量的验证和反作弊检测。<br><img src="/images/article/Games104/19/Games104_19_24.png"><span class="image-caption">一个非常简单的服务器验证命中事件</span></p><p>在客户端上进行命中检测的优势在于它非常高效而且可以减轻服务器的负担，但它的核心问题在于它不够安全，一旦客户端被破解或是网络消息被劫持就需要非常复杂的反作弊系统来维持游戏平衡。<br><img src="/images/article/Games104/19/Games104_19_25.png"><span class="image-caption">客户端命中检测的问题</span></p><h3 id="服务器端命中检测（Server-Side-Hit-Registration）"><a href="#服务器端命中检测（Server-Side-Hit-Registration）" class="headerlink" title="服务器端命中检测（Server-Side Hit Registration）"></a>服务器端命中检测（Server-Side Hit Registration）</h3><p>在服务器端进行检测的一个难点在于服务器上角色的位置和状态是领先于玩家视角的，当玩家开枪时目标很可能已经移动到其它的位置上了。从这样的角度来看，玩家很难命中移动中的目标。<br><img src="/images/article/Games104/19/Games104_19_26.png"><span class="image-caption">在服务器端检测命中？</span></p><p>因此我们需要对网络延迟进行一定的补偿。当服务器收到射击的消息时不会直接使用当前的游戏状态，而是根据延迟使用之前保存的游戏状态。<br><img src="/images/article/Games104/19/Games104_19_27.png"><span class="image-caption">滞后补偿</span><br><img src="/images/article/Games104/19/Games104_19_28.png"><span class="image-caption">补偿所有可能的滞后</span></p><h3 id="掩体问题（Cover-Problems）"><a href="#掩体问题（Cover-Problems）" class="headerlink" title="掩体问题（Cover Problems）"></a>掩体问题（Cover Problems）</h3><p>对于掩体的问题，由于网络延迟的存在可能会出现射击者优势或窥视者优势的情况。<br><img src="/images/article/Games104/19/Games104_19_29.png"><span class="image-caption">掩体问题-遇到掩体</span><br><img src="/images/article/Games104/19/Games104_19_30.png"><span class="image-caption">掩体问题-从掩体出来</span></p><p>为了缓解延迟的问题在游戏设计时还可以利用动作<b>前摇(startup frames)</b>来掩盖掉网络同步。<br><img src="/images/article/Games104/19/Games104_19_31.png"><span class="image-caption">缓解延迟感的启动框架</span></p><p>类似地，也可以使用各种特效来为服务器同步争取时间。<br><img src="/images/article/Games104/19/Games104_19_32.png"><span class="image-caption">本地预测VFX效果</span></p><h2 id="基础MMO网络架构（MMOG-Network-Architecture）"><a href="#基础MMO网络架构（MMOG-Network-Architecture）" class="headerlink" title="基础MMO网络架构（MMOG Network Architecture）"></a>基础MMO网络架构（MMOG Network Architecture）</h2><p>对于<b>大型多人在线游戏(massively multiplayer online game, MMOG)</b>我们还需要一些额外的网络架构设计。<br><img src="/images/article/Games104/19/Games104_19_33.png"><span class="image-caption">什么是MMOG？</span><br><img src="/images/article/Games104/19/Games104_19_34.png"><span class="image-caption">第一个网路游戏和角色扮演游戏</span><br><img src="/images/article/Games104/19/Games104_19_35.png"><span class="image-caption">现代MMO的多样性</span></p><h3 id="MMO体系结构（MMO-Architecture）"><a href="#MMO体系结构（MMO-Architecture）" class="headerlink" title="MMO体系结构（MMO Architecture）"></a>MMO体系结构（MMO Architecture）</h3><p>MMOG中一般会有各种子系统来组成整体的玩法系统。<br><img src="/images/article/Games104/19/Games104_19_36.png"><span class="image-caption">游戏子系统</span></p><p>简单的MMO分层架构如下：<br><img src="/images/article/Games104/19/Games104_19_37.png"><span class="image-caption">MMO体系结构</span></p><h4 id="连接层（Link-Layer）"><a href="#连接层（Link-Layer）" class="headerlink" title="连接层（Link Layer）"></a>连接层（Link Layer）</h4><p><b>连接层(link layer)</b>是玩家和游戏建立连接的一层。在MMO中为了保护服务器不受攻击，我们需要单独的连接层来分离玩家和服务器数据。<br><img src="/images/article/Games104/19/Games104_19_38.png"><span class="image-caption">链路层服务</span></p><h4 id="大厅（Lobby）"><a href="#大厅（Lobby）" class="headerlink" title="大厅（Lobby）"></a>大厅（Lobby）</h4><p>连接到link layer后玩家会进入<b>大厅(lobby)</b>。大厅可以理解为一个特殊的游戏模式，从而方便管理等待进行游戏的玩家。<br><img src="/images/article/Games104/19/Games104_19_39.png"><span class="image-caption">大厅</span></p><h4 id="角色服务器（Character-Server）"><a href="#角色服务器（Character-Server）" class="headerlink" title="角色服务器（Character Server）"></a>角色服务器（Character Server）</h4><p>由于MMO中玩家的数据往往非常巨大，玩家的数据一般会保存在一个专门的服务器上称为<b>character server</b>。<br><img src="/images/article/Games104/19/Games104_19_40.png"><span class="image-caption">角色服务器</span></p><h4 id="交易系统（Trading-System）"><a href="#交易系统（Trading-System）" class="headerlink" title="交易系统（Trading System）"></a>交易系统（Trading System）</h4><p><b>交易系统(trading system)</b>是MMO的重要组成部分，在设计交易系统时需要保证系统有足够高的安全性。<br><img src="/images/article/Games104/19/Games104_19_41.png"><span class="image-caption">交易系统</span></p><h4 id="社交系统（Social-System）"><a href="#社交系统（Social-System）" class="headerlink" title="社交系统（Social System）"></a>社交系统（Social System）</h4><p>玩家之间的聊天和交互功能一般会通过专门的<b>社交系统(social system)</b>来进行实现。<br><img src="/images/article/Games104/19/Games104_19_42.png"><span class="image-caption">社交系统</span></p><h4 id="匹配（Matchmaking）"><a href="#匹配（Matchmaking）" class="headerlink" title="匹配（Matchmaking）"></a>匹配（Matchmaking）</h4><p>很多MMO还需要实现玩家的匹配<br><img src="/images/article/Games104/19/Games104_19_43.png"><span class="image-caption">匹配</span></p><h3 id="数据存储（Data-Storage）"><a href="#数据存储（Data-Storage）" class="headerlink" title="数据存储（Data Storage）"></a>数据存储（Data Storage）</h3><p><b>数据存储(data storage)</b>是MMO中非常重要的问题。不同于单机游戏，在MMO中玩家可能会随时下线但服务器则必须要保证一直运行。因此如何存储和调用数据是一个非常重要也非常困难的问题。<br><img src="/images/article/Games104/19/Games104_19_44.png"><span class="image-caption">数据存储</span></p><h4 id="关系型数据库（Relational-Data-Storage）"><a href="#关系型数据库（Relational-Data-Storage）" class="headerlink" title="关系型数据库（Relational Data Storage）"></a>关系型数据库（Relational Data Storage）</h4><p>关系数据库是最基本的数据存储方式，像游戏中玩家数据和游戏数据都会使用关系数据库进行存储。现代网络游戏中往往还会结合分布式的技术进行存储。<br><img src="/images/article/Games104/19/Games104_19_45.png"><span class="image-caption">关系型数据库</span></p><h4 id="非关系型数据库（Non-Relational-Data-Storage）"><a href="#非关系型数据库（Non-Relational-Data-Storage）" class="headerlink" title="非关系型数据库（Non-Relational Data Storage）"></a>非关系型数据库（Non-Relational Data Storage）</h4><p>除了关系数据库外，非关系数据库也是目前非常流行的数据存储方法。像游戏中的日志还有各种game state就比较适合使用非关系数据库。<br><img src="/images/article/Games104/19/Games104_19_46.png"><span class="image-caption">非关系型数据库</span></p><h4 id="内存数据库（In-Memory-Data-Storage）"><a href="#内存数据库（In-Memory-Data-Storage）" class="headerlink" title="内存数据库（In-Memory Data Storage）"></a>内存数据库（In-Memory Data Storage）</h4><p>随着游戏系统变得越来越复杂，在服务器运行过程中会产生大量的中间数据存储在内存中。因此我们需要一些内存数据管理工具。<br><img src="/images/article/Games104/19/Games104_19_47.png"><span class="image-caption">非关系型数据库</span></p><h3 id="分布式系统（Distributed-System）"><a href="#分布式系统（Distributed-System）" class="headerlink" title="分布式系统（Distributed System）"></a>分布式系统（Distributed System）</h3><p>随着玩家数量的增长，在单个服务器上支撑所有玩家进行游玩是几乎不可能的。在这种情况下就需要使用<b>分布式系统(distributed system)</b>来提供游戏服务。<br><img src="/images/article/Games104/19/Games104_19_48.png"><span class="image-caption">玩家数量增长</span><br><img src="/images/article/Games104/19/Games104_19_49.png"><span class="image-caption">分布式系统</span></p><p>分布式系统有很多自身的难点：<br><img src="/images/article/Games104/19/Games104_19_50.png"><span class="image-caption">分布式系统所面临的挑战</span></p><h4 id="负载均衡（Load-Balancing）"><a href="#负载均衡（Load-Balancing）" class="headerlink" title="负载均衡（Load Balancing）"></a>负载均衡（Load Balancing）</h4><p><b>负载均衡(load balancing)</b>是分布式系统中非常重要的概念，我们希望在不同服务器上都有相近的负载从而避免某些服务器负载过大的问题。<br><img src="/images/article/Games104/19/Games104_19_51.png"><span class="image-caption">负载均衡</span></p><p><b>consistent hashing</b>是实现负载均衡的经典技术。它的核心在于为服务器以及玩家设计对应的hashing算法，然后把服务器和玩家映射到一个环上，当玩家需要连接服务器时只需要利用hashing值寻找最近的服务器即可。当某个服务器从圆环上删除时只需要把玩家连接到下一个服务器上即可，类似地添加新的服务器只需要在圆环上添加新的节点。<br><img src="/images/article/Games104/19/Games104_19_52.png"><span class="image-caption">一致性哈希</span><br><img src="/images/article/Games104/19/Games104_19_53.png"><span class="image-caption">一致性哈希2</span><br><img src="/images/article/Games104/19/Games104_19_54.png"><span class="image-caption">一致性哈希3</span></p><p>显然consistent hashing算法的效果很大程度上依赖于hashing函数，当服务器或是玩家在环上的分布不够均匀时是很难保证负载均衡的。为了缓解这样的问题我们可以在环上设置一些虚拟的服务器，然后再把虚拟服务器链接到真实服务器上。<br><img src="/images/article/Games104/19/Games104_19_55.png"><span class="image-caption">一致性哈希中的虚拟服务器节点</span></p><h4 id="服务器管理（Servers-Management）"><a href="#服务器管理（Servers-Management）" class="headerlink" title="服务器管理（Servers Management）"></a>服务器管理（Servers Management）</h4><p>分布式系统的另一大难点在于如何管理大量同时运行的服务。<br><img src="/images/article/Games104/19/Games104_19_56.png"><span class="image-caption">服务器管理</span></p><p>我们可以使用Apache或是etcd这样的工具来监视和管理各种服务。<br><img src="/images/article/Games104/19/Games104_19_57.png"><span class="image-caption">服务发现-注册表</span><br><img src="/images/article/Games104/19/Games104_19_58.png"><span class="image-caption">服务发现-查询和监视</span><br><img src="/images/article/Games104/19/Games104_19_59.png"><span class="image-caption">服务发现-运行状况检查</span></p><h2 id="带宽优化（Bandwidth-Optimization）"><a href="#带宽优化（Bandwidth-Optimization）" class="headerlink" title="带宽优化（Bandwidth Optimization）"></a>带宽优化（Bandwidth Optimization）</h2><p><b>带宽优化(bandwidth optimization)</b>是现代网络游戏必须要解决的问题。网络带宽不仅仅是游戏运营成本的重要组成部分，对玩家的游戏体验也有着重要的影响。<br><img src="/images/article/Games104/19/Games104_19_60.png"><span class="image-caption">为什么带宽很重要</span></p><p>带宽的计算实际上非常简单，根据计算视角的不同我们有不同的衡量指标：<br><img src="/images/article/Games104/19/Games104_19_61.png"><span class="image-caption">计算带宽</span></p><h3 id="数据压缩（Data-Compression）"><a href="#数据压缩（Data-Compression）" class="headerlink" title="数据压缩（Data Compression）"></a>数据压缩（Data Compression）</h3><p><b>数据压缩(data compression)</b>是经典的带宽优化方法。在网络游戏中我们可以把浮点数转换为低精度的定点数来减少数据量。<br><img src="/images/article/Games104/19/Games104_19_62.png"><span class="image-caption">数据压缩</span></p><p>我们甚至可以对游戏地图进行分区然后在小区域中使用定点数来缓解低精度数值带来的影响。<br><img src="/images/article/Games104/19/Games104_19_63.png"><span class="image-caption">数据压缩2</span></p><h3 id="对象相关性（Object-Relevance）"><a href="#对象相关性（Object-Relevance）" class="headerlink" title="对象相关性（Object Relevance）"></a>对象相关性（Object Relevance）</h3><p>另一种缓解带宽需求的方式是只同步和玩家相关的对象，这样可以极大地减少每次和玩家同步的数据量。<br><img src="/images/article/Games104/19/Games104_19_64.png"><span class="image-caption">对象相关性</span></p><p>我们可以把整个游戏世界划分为若干个区域，这样每个玩家都会位于某个区域中。不同区域的数据是相互隔绝的，因此在同步时只需要同步区域中的数据即可。<br><img src="/images/article/Games104/19/Games104_19_65.png"><span class="image-caption">相关性-静态区域</span></p><p>在一些开放世界游戏中我们不希望出现区域的划分，此时则可以利用<b>area of inerest (AOI)</b>的概念。AOI的意义在于我们只需要关注玩家附近的情况而无需考虑更远区域的信息。<br><img src="/images/article/Games104/19/Games104_19_66.png"><span class="image-caption">相关性-感兴趣的领域</span></p><p>AOI最简单的实现方法是利用一个半径来查询附近信息。<br><img src="/images/article/Games104/19/Games104_19_67.png"><span class="image-caption">AOI-直接范围查询</span></p><p>当玩家数量很多时还可以利用网格划分的方法来加速查询。<br><img src="/images/article/Games104/19/Games104_19_68.png"><span class="image-caption">AOI-空间网格</span><br><img src="/images/article/Games104/19/Games104_19_69.png"><span class="image-caption">AOI-空间网格2</span><br><img src="/images/article/Games104/19/Games104_19_70.png"><span class="image-caption">AOI-空间网格3</span></p><p>除此之外我们也可以使用十字链表这样的数据结构来进行加速。<br><img src="/images/article/Games104/19/Games104_19_71.png"><span class="image-caption">AOI-正交链接列表</span><br><img src="/images/article/Games104/19/Games104_19_72.png"><span class="image-caption">AOI-正交链接列表2</span><br><img src="/images/article/Games104/19/Games104_19_73.png"><span class="image-caption">AOI-正交链接列表3</span><br><img src="/images/article/Games104/19/Games104_19_74.png"><span class="image-caption">AOI-正交链接列表4</span></p><p>当然也可以使用<b>PVS</b>这样的技术来剔除不相关的对象。<br><img src="/images/article/Games104/19/Games104_19_75.png"><span class="image-caption">AOI-潜在可见集</span></p><h3 id="变化的更新频率（Varying-Update-Frequency）"><a href="#变化的更新频率（Varying-Update-Frequency）" class="headerlink" title="变化的更新频率（Varying Update Frequency）"></a>变化的更新频率（Varying Update Frequency）</h3><p>除了上面介绍的方法我们也可以通过调整更新频率的方式来降低带宽。一种经典的策略是根据物体和玩家之间的距离来设置更新频率，使得距离玩家远的物体更新得慢一些，距离近的更新得快一些。<br><img src="/images/article/Games104/19/Games104_19_76.png"><span class="image-caption">AOI-潜在可见集</span></p><h2 id="反作弊（Anti-Cheat）"><a href="#反作弊（Anti-Cheat）" class="headerlink" title="反作弊（Anti-Cheat）"></a>反作弊（Anti-Cheat）</h2><p><b>反作弊(anti-cheat)</b>同样是现代网络游戏必须要实现的功能，作弊行为对游戏运营和其他玩家都会造成非常巨大的伤害。<br><img src="/images/article/Games104/19/Games104_19_77.png"><span class="image-caption">作弊杀死网络游戏</span></p><p>网络游戏中的作弊手段是相当多样的，比如说可以修改本地的代码或是内存中的数据，骇入底层三方库的接口，甚至可以通过劫持网络通信来实现作弊行为。<br><img src="/images/article/Games104/19/Games104_19_78.png"><span class="image-caption">数以百万计的作弊方式</span></p><h3 id="混淆内存（Obfuscating-Memory）"><a href="#混淆内存（Obfuscating-Memory）" class="headerlink" title="混淆内存（Obfuscating Memory）"></a>混淆内存（Obfuscating Memory）</h3><p>作弊最基本的方法是修改本地的内存。对于很多在客户端进行校验的游戏只需要修改游戏内存中的数据就可以进行作弊。<br><img src="/images/article/Games104/19/Games104_19_79.png"><span class="image-caption">混淆内存</span></p><p>为了应对这种作弊方式，我们可以对客户端套一个壳来防止侵入。类似地，也可以对内存数据进行加密来防止侵入。<br><img src="/images/article/Games104/19/Games104_19_80.png"><span class="image-caption">可装卸的壳</span><br><img src="/images/article/Games104/19/Games104_19_81.png"><span class="image-caption">可装卸的壳2</span></p><h3 id="通过哈希验证本地文件（Verifying-Local-Files-by-Hashing）"><a href="#通过哈希验证本地文件（Verifying-Local-Files-by-Hashing）" class="headerlink" title="通过哈希验证本地文件（Verifying Local Files by Hashing）"></a>通过哈希验证本地文件（Verifying Local Files by Hashing）</h3><p>另一种常见的作弊方法是修改本地的资源文件。我们可以通过对比本地和服务器上资源的hashing来进行处理。<br><img src="/images/article/Games104/19/Games104_19_82.png"><span class="image-caption">通过哈希验证本地文件</span></p><h3 id="数据包拦截和操作（Packet-Interception-and-Manipulation）"><a href="#数据包拦截和操作（Packet-Interception-and-Manipulation）" class="headerlink" title="数据包拦截和操作（Packet Interception and Manipulation）"></a>数据包拦截和操作（Packet Interception and Manipulation）</h3><p>消息的劫持和篡改是网络游戏中经常遇到的作弊方式，因此对于客户端和服务器发出的包就必须进行加密。<br><img src="/images/article/Games104/19/Games104_19_83.png"><span class="image-caption">数据包拦截和操作</span></p><p>目前主流的加密算法包括对称加密和非对称加密两种。对称加密是指客户端和服务器共享一副秘钥，它的缺陷在于当客户端被破解后秘钥就是公开的了，此时加密也就失效了。因此在实践中更多地使用的是非对称加密算法，此时客户端只有公钥而在服务器端存有私钥。这样即使客户端被破解了也无法完全获知所有数据。<br><img src="/images/article/Games104/19/Games104_19_84.png"><span class="image-caption">加密网络流量</span><br><img src="/images/article/Games104/19/Games104_19_85.png"><span class="image-caption">加密网络流量2</span></p><h3 id="系统软件调用（System-Software-Invoke）"><a href="#系统软件调用（System-Software-Invoke）" class="headerlink" title="系统软件调用（System Software Invoke）"></a>系统软件调用（System Software Invoke）</h3><p>除此之外，作弊者还可以通过修改底层游戏引擎代码来进行作弊。<br><img src="/images/article/Games104/19/Games104_19_86.png"><span class="image-caption">系统软件调用</span></p><p>针对这种情况可以使用各种安全软件来检测游戏引擎是否存在注入的情况。<br><img src="/images/article/Games104/19/Games104_19_87.png"><span class="image-caption">阀门防作弊和简易防作弊</span></p><h3 id="AI作弊（AI-Cheat）"><a href="#AI作弊（AI-Cheat）" class="headerlink" title="AI作弊（AI Cheat）"></a>AI作弊（AI Cheat）</h3><p>目前随着AI技术的发展还出现了使用AI进行作弊的现象，这对下一代反作弊系统的开发又提出了新的挑战。<br><img src="/images/article/Games104/19/Games104_19_88.png"><span class="image-caption">AI作弊</span><br><img src="/images/article/Games104/19/Games104_19_89.png"><span class="image-caption">丰富的人工智能商品</span><br><img src="/images/article/Games104/19/Games104_19_90.png"><span class="image-caption">反恐精英：守望先锋</span><br><img src="/images/article/Games104/19/Games104_19_91.png"><span class="image-caption">基于统计学的系统</span><br><img src="/images/article/Games104/19/Games104_19_92.png"><span class="image-caption">检测已知的作弊程序</span></p><h2 id="构建可拓展的游戏世界（Build-a-Scalable-World）"><a href="#构建可拓展的游戏世界（Build-a-Scalable-World）" class="headerlink" title="构建可拓展的游戏世界（Build a Scalable World）"></a>构建可拓展的游戏世界（Build a Scalable World）</h2><p>构建可拓展的游戏世界可以说是每个游戏从业者的梦想。<br><img src="/images/article/Games104/19/Games104_19_93.png"><span class="image-caption">可扩展的游戏服务器</span><br><img src="/images/article/Games104/19/Games104_19_94.png"><span class="image-caption">分区-无缝区域</span><br><img src="/images/article/Games104/19/Games104_19_95.png"><span class="image-caption">分区-无缝区域2</span><br><img src="/images/article/Games104/19/Games104_19_96.png"><span class="image-caption">分区-无缝区域3</span><br><img src="/images/article/Games104/19/Games104_19_97.png"><span class="image-caption">分区-无缝区域4</span><br><img src="/images/article/Games104/19/Games104_19_98.png"><span class="image-caption">主从复制</span><br><img src="/images/article/Games104/19/Games104_19_99.png"><span class="image-caption">可扩展的游戏服务器-组合</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/08/17/GAMES104-NOTES-19.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV13B4y1L7bZ/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV1RG411t7TP/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_PPT_Lecture%2019_Online%20Gaming%20Architecture-Advanced%20Topics.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 网络游戏的架构基础（十八）</title>
      <link href="/posts/af86add3.html"/>
      <url>/posts/af86add3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络游戏的出现是游戏发展历程中的重要里程碑，基于互联网玩家可以同时和全球的其它玩家一起进行游玩。<br><img src="/images/article/Games104/18/Games104_18_01.png"><span class="image-caption">和任何人一起玩</span></p><p>网络游戏和单机游戏相比有很多难点，比如说如何保证每个玩家的游戏状态是一致的、如何进行网络同步、如何处理延迟和丢包、如何检测玩家的作弊行为、如何处理不同的设备和系统、如何设计高性能的服务器系统等等。这些网络游戏专有的问题都为游戏引擎的开发提出了更大的挑战。<br><img src="/images/article/Games104/18/Games104_18_02.png"><span class="image-caption">多人在线游戏中的挑战</span><br><img src="/images/article/Games104/18/Games104_18_03.png"><span class="image-caption">多人在线游戏中的挑战2</span><br><img src="/images/article/Games104/18/Games104_18_04.png"><span class="image-caption">多人在线游戏中的挑战3</span><br><img src="/images/article/Games104/18/Games104_18_05.png"><span class="image-caption">多人在线游戏中的挑战4</span><br><img src="/images/article/Games104/18/Games104_18_06.png"><span class="image-caption">多人在线游戏中的挑战5</span></p><p>所以网络游戏是一个非常复杂庞大的系统，在这一部分我们同样分为两节来介绍相关的技术。<br><img src="/images/article/Games104/18/Games104_18_07.png"><span class="image-caption">大纲</span></p><h2 id="网络协议（Network-Protocols）"><a href="#网络协议（Network-Protocols）" class="headerlink" title="网络协议（Network Protocols）"></a>网络协议（Network Protocols）</h2><p>在介绍网络游戏相关的内容前我们先来介绍一下<b>网络协议(network protocols)</b>。实际上互联网的概念最早是由Vint和Robert提出的，他们设计了TCP/IP协议从而实现了不同设备基于电话线和卫星的通信。<br><img src="/images/article/Games104/18/Games104_18_08.png"><span class="image-caption">互联网的开国元勋们</span></p><h3 id="通信问题（The-Problem-of-Communication）"><a href="#通信问题（The-Problem-of-Communication）" class="headerlink" title="通信问题（The Problem of Communication）"></a>通信问题（The Problem of Communication）</h3><p>网络协议要解决的核心问题是如何实现两台计算机之间的数据通信，当软件应用和硬件连接不断地变得复杂时直接进行通信是非常困难的。<br><img src="/images/article/Games104/18/Games104_18_09.png"><span class="image-caption">如何在两台个人电脑之间进行通信</span><br><img src="/images/article/Games104/18/Games104_18_10.png"><span class="image-caption">通信问题</span></p><p>因此人们提出了<b>中间层(intermediate layer)</b>的概念来隔绝掉应用和硬件，使得开发者可以专注于程序本身而不是具体的通信过程。<br><img src="/images/article/Games104/18/Games104_18_11.png"><span class="image-caption">解决方案：分层</span></p><p>在现代计算机网络中人们设计了<b>OSI模型(OSI model)</b>来对通信过程进行封装和抽象。<br><img src="/images/article/Games104/18/Games104_18_12.png"><span class="image-caption">在互联网-OSI模型中的分层</span></p><h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>对于网络游戏开发来说一般不需要接触到很底层的通信协议，在大多数情况下只需要知道如何使用<b>socket</b>建立连接即可。<br><img src="/images/article/Games104/18/Games104_18_13.png"><span class="image-caption">基于网络套接字的通信</span></p><p>socket是一个非常简单的结构体，我们只需要知道对方的IP地址和端口号就可以使用socket建立连接来发送和接收数据。<br><img src="/images/article/Games104/18/Games104_18_14.png"><span class="image-caption">套接字</span></p><p>建立连接时需要额外注意到底是使用IPv4还是IPv6，使用TCP还是UDP协议等问题。<br><img src="/images/article/Games104/18/Games104_18_15.png"><span class="image-caption">设置套接字</span></p><h3 id="传输控制协议（-Transmission-Control-Protocol-TCP）"><a href="#传输控制协议（-Transmission-Control-Protocol-TCP）" class="headerlink" title="传输控制协议（ Transmission Control Protocol - TCP）"></a>传输控制协议（ Transmission Control Protocol - TCP）</h3><p>TCP是最经典也是著名的网络协议，它可以确保发送端发送的数据包都按照顺序被接收端接收。<br><img src="/images/article/Games104/18/Games104_18_16.png"><span class="image-caption">TCP</span></p><p>TCP的核心是<b>retransmission mechanism</b>，这个机制要求接收端收到消息后会向发送端发送一个ACK，而发送端只有接收到这个ACK之后才会继续发包。当然TCP实际使用的机制要比上述的过程复杂得多。<br><img src="/images/article/Games104/18/Games104_18_17.png"><span class="image-caption">TCP重传机制</span></p><p>当TCP出现网络拥堵时会主动调节单次发包的数量。如果发包都能顺利地接收到则会提高发包数量以提升效率，反之则会减少发包数量以提升稳定性。<br><img src="/images/article/Games104/18/Games104_18_18.png"><span class="image-caption">TCP堵塞控制</span></p><h3 id="用户数据报协议（-User-Datagram-Protocol-UDP）"><a href="#用户数据报协议（-User-Datagram-Protocol-UDP）" class="headerlink" title="用户数据报协议（ User Datagram Protocol - UDP）"></a>用户数据报协议（ User Datagram Protocol - UDP）</h3><p>除了TCP之外人们还开发出了UDP这样的轻量级网络协议。UDP的本质是一个端到端的网络协议，它不需要建立长时间的连接，也不要求发送数据的顺序，因此UDP要比TCP简单得多。<br><img src="/images/article/Games104/18/Games104_18_19.png"><span class="image-caption">UDP</span><br><img src="/images/article/Games104/18/Games104_18_20.png"><span class="image-caption">UDP功能</span></p><p>在现代网络游戏中根据游戏类型的不同使用合适的网络协议，比如说对于实时性要求比较高的游戏会优先选择UDP，而策略类的游戏则会考虑使用TCP。在大型网络游戏中还可能会使用复合类型的协议来支持游戏中不同系统的通信需求。<br><img src="/images/article/Games104/18/Games104_18_21.png"><span class="image-caption">UDP功能</span></p><h3 id="可靠的-UDP（Reliable-UDP）"><a href="#可靠的-UDP（Reliable-UDP）" class="headerlink" title="可靠的 UDP（Reliable UDP）"></a>可靠的 UDP（Reliable UDP）</h3><p>同时现代网络游戏中往往还会对网络协议进行定制。以TCP为例，虽然TCP协议比较稳定但是效率过于低了，而且网络游戏中出现一定的丢包是可以接受的；而对于UDP来说它虽然非常高效但是却不够稳定。<br><img src="/images/article/Games104/18/Games104_18_22.png"><span class="image-caption">TCP不是时间关键型</span><br><img src="/images/article/Games104/18/Games104_18_23.png"><span class="image-caption">UDP的速度很快，但并不可靠</span></p><p>因此现代网络游戏中往往会基于UDP来定制一个网络协议，这样既可以利用UDP的高效性又可以保证数据通信的有序性。<br><img src="/images/article/Games104/18/Games104_18_24.png"><span class="image-caption">为什么我们需要定制协议</span></p><p>ACK及其相关技术是保证数据可靠通信的基本方法。<br><img src="/images/article/Games104/18/Games104_18_25.png"><span class="image-caption">确认信息和序列编号</span></p><h4 id="自动重复请求（Automatic-Repeat-Request-ARQ）"><a href="#自动重复请求（Automatic-Repeat-Request-ARQ）" class="headerlink" title="自动重复请求（Automatic Repeat Request - ARQ）"></a>自动重复请求（Automatic Repeat Request - ARQ）</h4><p><b>ARQ(automatic repeat request)</b>是基于ACK的错误控制方法，所有的通信算法都要事项ARQ的功能。<br><img src="/images/article/Games104/18/Games104_18_26.png"><span class="image-caption">ARQ</span></p><h4 id="滑窗协议（Sliding-Window-Protocol）"><a href="#滑窗协议（Sliding-Window-Protocol）" class="headerlink" title="滑窗协议（Sliding Window Protocol）"></a>滑窗协议（Sliding Window Protocol）</h4><p><b>滑窗协议(sliding window protocol)</b>是经典的ARQ实现方法，它在发送数据时每次发送窗口大小的包然后检验回复的ACK来判断是否出现丢包的情况。<br><img src="/images/article/Games104/18/Games104_18_27.png"><span class="image-caption">滑窗协议</span><br><img src="/images/article/Games104/18/Games104_18_28.png"><span class="image-caption">滑窗协议2</span></p><p>滑窗协议的一个缺陷在于它需要等待接收端的ACK才能继续发送数据，因此在很多情况下它无法完全利用带宽。<br><img src="/images/article/Games104/18/Games104_18_29.png"><span class="image-caption">停止等待ARQ</span></p><h4 id="回退n帧的自动重复请求（Go-Back-N-ARQ）"><a href="#回退n帧的自动重复请求（Go-Back-N-ARQ）" class="headerlink" title="回退n帧的自动重复请求（Go-Back-N ARQ）"></a>回退n帧的自动重复请求（Go-Back-N ARQ）</h4><p>对滑窗协议的一种改进方法是<b>Go-Back-N ARQ</b>，当出现丢包时它只会把窗口内的包重新发送。<br><img src="/images/article/Games104/18/Games104_18_30.png"><span class="image-caption">Go-Back-N ARQ</span></p><h4 id="选择性重复的ARQ（Selective-Repeat-ARQ）"><a href="#选择性重复的ARQ（Selective-Repeat-ARQ）" class="headerlink" title="选择性重复的ARQ（Selective Repeat ARQ）"></a>选择性重复的ARQ（Selective Repeat ARQ）</h4><p>另一种改进方法是<b>selective repeat ARQ</b>，它只会重新发送丢失或损坏的包从而进一步提升带宽的利用率。<br><img src="/images/article/Games104/18/Games104_18_31.png"><span class="image-caption">Selective Repeat ARQ</span></p><h4 id="前向纠错（Forward-Error-Correction）"><a href="#前向纠错（Forward-Error-Correction）" class="headerlink" title="前向纠错（Forward Error Correction）"></a>前向纠错（Forward Error Correction）</h4><p>在网络游戏中需要额外处理丢包的问题，因此我们在自定义网络协议时一般会结合<b>forward error correction(FEC)</b>的方法来避免数据的反复发送。<br><img src="/images/article/Games104/18/Games104_18_32.png"><span class="image-caption">在丢包丢失场景中使UDP可靠</span><br><img src="/images/article/Games104/18/Games104_18_33.png"><span class="image-caption">前向纠错</span></p><p>目前常用的FEC算法包括异或校验位以及Reed-Solomon codes两大类。<br><img src="/images/article/Games104/18/Games104_18_34.png"><span class="image-caption">前向纠错</span></p><h4 id="异或（XOR-FEC）"><a href="#异或（XOR-FEC）" class="headerlink" title="异或（XOR FEC）"></a>异或（XOR FEC）</h4><p>异或校验位是使用<b>异或(XOR)</b>运算来恢复丢失数据的方法。这里需要注意的是当同时有多个包丢失时，使用异或校验位是无法恢复数据的。<br><img src="/images/article/Games104/18/Games104_18_35.png"><span class="image-caption">异或</span><br><img src="/images/article/Games104/18/Games104_18_36.png"><span class="image-caption">异或2</span></p><h4 id="Reed-Solomon编码（Reed-Solomon-Codes）"><a href="#Reed-Solomon编码（Reed-Solomon-Codes）" class="headerlink" title="Reed-Solomon编码（Reed-Solomon Codes）"></a>Reed-Solomon编码（Reed-Solomon Codes）</h4><p><b>Reed-Solomon codes</b>是经典的信息传输算法，它利用Vandemode矩阵及其逆阵来恢复丢失的数据。<br><img src="/images/article/Games104/18/Games104_18_37.png"><span class="image-caption">Reed-Solomon编码</span><br><img src="/images/article/Games104/18/Games104_18_38.png"><span class="image-caption">Reed-Solomon编码2</span><br><img src="/images/article/Games104/18/Games104_18_39.png"><span class="image-caption">Reed-Solomon编码3</span></p><p>总结一下，在自定义UDP时需要考虑ARQ和FEC两类问题。<br><img src="/images/article/Games104/18/Games104_18_40.png"><span class="image-caption">基于ARQ和FEC定制您的UDP</span></p><h2 id="时钟同步（Clock-Synchronization）"><a href="#时钟同步（Clock-Synchronization）" class="headerlink" title="时钟同步（Clock Synchronization）"></a>时钟同步（Clock Synchronization）</h2><p>有了网络协议后就可以开始对网络游戏进行开发了，不过在具体设计游戏前我们还需要考虑不同玩家之间的<b>时钟同步(clock synchronization)</b>问题。</p><h3 id="往返时间（Round-Trip-Time-RTT）"><a href="#往返时间（Round-Trip-Time-RTT）" class="headerlink" title="往返时间（Round Trip Time - RTT）"></a>往返时间（Round Trip Time - RTT）</h3><p>由于网络通信延迟的存在，客户端向服务器端发送一个包后都需要等待一定的时间才能收到回包，这个间隔的时间称为round-trip time(RTT)<b>。RTT的概念类似于ping，不过它们的区别在于ping更加偏向于底层而RTT则位于顶部的应用层。<br><img src="/images/article/Games104/18/Games104_18_41.png"><span class="image-caption">基于ARQ和FEC定制您的UDP</span></b></p><b><h3 id="网络时间协议（Network-Time-Protocol）"><a href="#网络时间协议（Network-Time-Protocol）" class="headerlink" title="网络时间协议（Network Time Protocol）"></a>网络时间协议（Network Time Protocol）</h3><p>利用RTT就可以实现不同设备之间的时间同步。实际上不仅仅是网络游戏，现实生活中的各种电子设备进行同步都使用了RTT的技术。<br><img src="/images/article/Games104/18/Games104_18_42.png"><span class="image-caption">网络时间协议</span></p><p>在实际设备的时间同步过程中一般会利用层次化的结构来进行实现。<br><img src="/images/article/Games104/18/Games104_18_43.png"><span class="image-caption">时间服务器层</span></p><p>NTP的算法实际上非常简单，我们只需要从客户端发送请求然后从服务器接收一个时刻就好，这样就可以得到4个时间戳。如果我们进一步假定网络上行和下行的延迟是一致的，我们可以直接计算出RTT的时间长短以及两个设备之间的时间偏差。当然需要注意的是在实际中网络上行和下行的带宽往往是不一致的，因此这个算法也不是十分的严谨。<br><img src="/images/article/Games104/18/Games104_18_44.png"><span class="image-caption">NTP算法</span><br><img src="/images/article/Games104/18/Games104_18_45.png"><span class="image-caption">NTP算法2</span><br><img src="/images/article/Games104/18/Games104_18_46.png"><span class="image-caption">NTP算法3</span></p><p>实际上我们可以证明在不可靠的通信中是无法严格校准时间的。不过在实践中我们可以通过不断的使用NTP算法来得到一系列RTT值，然后把高于平均值50%的部分丢弃，剩下的RTT平均值的1.5倍就可以作为真实RTT的估计。<br><img src="/images/article/Games104/18/Games104_18_47.png"><span class="image-caption">基于流的时间同步与消除更高阶模式</span><br><img src="/images/article/Games104/18/Games104_18_48.png"><span class="image-caption">基于流的时间同步与消除更高阶模式2</span></p><h2 id="远程过程调用（Remote-Procedure-Call-RPC）"><a href="#远程过程调用（Remote-Procedure-Call-RPC）" class="headerlink" title="远程过程调用（Remote Procedure Call - RPC）"></a>远程过程调用（Remote Procedure Call - RPC）</h2><h3 id="套接字编程（Socket-Programming）"><a href="#套接字编程（Socket-Programming）" class="headerlink" title="套接字编程（Socket Programming）"></a>套接字编程（Socket Programming）</h3><p>尽管利用socket我们可以实现客户端和服务器的通信，但对于网络游戏来说完全基于socket的通信是非常复杂的。这主要是因为网络游戏中客户端需要向服务器发送大量不同类型的消息，同时客户端也需要解析相应类型的反馈，这就会导致游戏逻辑变得无比复杂。<br><img src="/images/article/Games104/18/Games104_18_49.png"><span class="image-caption">套接字编程：仍然不是很好</span><br><img src="/images/article/Games104/18/Games104_18_50.png"><span class="image-caption">与消息通信</span><br><img src="/images/article/Games104/18/Games104_18_51.png"><span class="image-caption">通信方式</span></p><p>另一方面客户端和服务器往往有着不同的硬件和操作系统，这些差异会使得游戏逻辑更加复杂且难以调试。<br><img src="/images/article/Games104/18/Games104_18_52.png"><span class="image-caption">逻辑通信所面临的更多挑战</span></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>因此在现代网络游戏中一般会使用<b>RPC(remote procedure call)</b>的方式来实现客户端和服务器的通信。基于RPC的技术在客户端可以像本地调用函数的方式来向服务器发送请求，这样使得开发人员可以专注于游戏逻辑而不是具体底层的实现。<br><img src="/images/article/Games104/18/Games104_18_53.png"><span class="image-caption">RPC</span><br><img src="/images/article/Games104/18/Games104_18_54.png"><span class="image-caption">RPC示例</span><br><img src="/images/article/Games104/18/Games104_18_55.png"><span class="image-caption">为什么RPC？</span></p><p>在RPC中会大量使用<b>IDL(interface definiton language)</b>来定义不同的消息形式。<br><img src="/images/article/Games104/18/Games104_18_56.png"><span class="image-caption">IDL</span></p><p>然后在启动时通过<b>RPC stubs</b>来通知客户端有哪些RPC是可以进行调用的。<br><img src="/images/article/Games104/18/Games104_18_57.png"><span class="image-caption">RPC 存根</span><br><img src="/images/article/Games104/18/Games104_18_58.png"><span class="image-caption">存根编译程序</span></p><p>当然真实游戏中的RPC在实际进行调用时还有很多的消息处理和加密工作。<br><img src="/images/article/Games104/18/Games104_18_59.png"><span class="image-caption">真正的RPC包之旅</span></p><h2 id="网络拓扑（Network-Topology）"><a href="#网络拓扑（Network-Topology）" class="headerlink" title="网络拓扑（Network Topology）"></a>网络拓扑（Network Topology）</h2><h3 id="点对点（Peer-to-Peer-P2P）"><a href="#点对点（Peer-to-Peer-P2P）" class="headerlink" title="点对点（Peer-to-Peer - P2P）"></a>点对点（Peer-to-Peer - P2P）</h3><p>在设计网络游戏时还需要考虑网络自身的架构。最经典的网络架构是<b>P2P(peer-to-peer)</b>，此时每个客户端之间会直接建立通信。<br><img src="/images/article/Games104/18/Games104_18_60.png"><span class="image-caption">P2P</span></p><p>当P2P需要集中所有玩家的信息时则可以选择其中一个客户端作为主机，这样其它的客户端可以通过连接主机的方式来实现联机。<br><img src="/images/article/Games104/18/Games104_18_61.png"><span class="image-caption">带主机服务器的P2P</span></p><p>很多早期经典的游戏都是使用这样的网络架构来实现联网功能。<br><img src="/images/article/Games104/18/Games104_18_62.png"><span class="image-caption">P2P游戏</span></p><h3 id="专用服务器（Dedicated-Server）"><a href="#专用服务器（Dedicated-Server）" class="headerlink" title="专用服务器（Dedicated Server）"></a>专用服务器（Dedicated Server）</h3><p>在现代网络游戏中更多地会使用<b>dedicated server</b>这样的网络架构，此时网络中有一个专门的服务器向其它客户端提供服务。<br><img src="/images/article/Games104/18/Games104_18_63.png"><span class="image-caption">专用服务器</span></p><p>从实践结果来看，对于小型的网络游戏P2P是一个足够好的架构，而对于大型的商业网络游戏则必须使用dedicated server这样的形式。<br><img src="/images/article/Games104/18/Games104_18_64.png"><span class="image-caption">P2P与专用服务器</span><br><img src="/images/article/Games104/18/Games104_18_65.png"><span class="image-caption">当RTT太高时</span></p><h2 id="游戏同步（Game-Synchronization）"><a href="#游戏同步（Game-Synchronization）" class="headerlink" title="游戏同步（Game Synchronization）"></a>游戏同步（Game Synchronization）</h2><p>在前面的课程中我们介绍过游戏世界是分层的。从玩家的角度来看，玩家的操作通过输入层一路向下到达游戏逻辑层，然后通过渲染器展示给玩家。<br><img src="/images/article/Games104/18/Games104_18_66.png"><span class="image-caption">单人游戏</span></p><p>而在网络游戏中，除了单机游戏都需要的分层外我们还需要考虑不同玩家之间的同步。在理想情况下我们希望客户端只负责处理玩家的输入，整个游戏逻辑都放在服务器端。<br><img src="/images/article/Games104/18/Games104_18_67.png"><span class="image-caption">网络游戏</span></p><p>由于延迟的存在，不同玩家视角下的对方可能会有不同的行为表现。<br><img src="/images/article/Games104/18/Games104_18_68.png"><span class="image-caption">游戏同步</span></p><p>因此我们需要使用游戏同步技术来保证玩家的游戏体验是一致的。目前常用的同步技术包括快照同步、帧同步以及状态同步等。<br><img src="/images/article/Games104/18/Games104_18_69.png"><span class="image-caption">同步方法</span></p><h3 id="快照同步（Snapshot-Synchronization）"><a href="#快照同步（Snapshot-Synchronization）" class="headerlink" title="快照同步（Snapshot Synchronization）"></a>快照同步（Snapshot Synchronization）</h3><p><b>快照同步(snapshot synchronization)</b>是一种相对古老的同步技术。在快照同步中客户端只负责向服务器发送当前玩家的数据，由服务器完成整个游戏世界的运行。然后服务器会为游戏世界生成一张快照，再发送给每个客户端来给玩家反馈。<br><img src="/images/article/Games104/18/Games104_18_70.png"><span class="image-caption">快照同步</span></p><p>快照同步可以严格保证每个玩家的状态都是准确的，但其缺陷在于它给服务器提出了非常巨大的挑战。因此在实际游戏中一般会降低服务器上游戏运行的帧率来平衡带宽，然后在客户端上通过插值的方式来获得高帧率。<br><img src="/images/article/Games104/18/Games104_18_71.png"><span class="image-caption">快照同步-抖动和挂接</span><br><img src="/images/article/Games104/18/Games104_18_72.png"><span class="image-caption">快照插值</span></p><p>由于每次生成快照的成本是相对较高的，为了压缩数据我们可以使用状态的变化量来对游戏状态进行表示。<br><img src="/images/article/Games104/18/Games104_18_73.png"><span class="image-caption">差值压缩</span><br><img src="/images/article/Games104/18/Games104_18_74.png"><span class="image-caption">差值压缩2</span></p><p>快照同步非常简单也易于实现，但它基本浪费掉了客户端上的算力同时在服务器上会产生过大的压力。因此在现代网络游戏中基本不会使用快照同步的方式。<br><img src="/images/article/Games104/18/Games104_18_75.png"><span class="image-caption">快照同步</span></p><h3 id="帧同步（Lockstep-Synchronization）"><a href="#帧同步（Lockstep-Synchronization）" class="headerlink" title="帧同步（Lockstep Synchronization）"></a>帧同步（Lockstep Synchronization）</h3><p><b>帧同步(lockstep synchronization)</b>是现代网络游戏中非常常用的同步技术。不同于快照同步完全通过服务器来运行游戏世界，在帧同步中服务器更多地是完成数据的分发工作。玩家的操作通过客户端发送到服务器上，经过服务器汇总后将当前游戏世界的状态返还给客户端，然后在每个客户端上运行游戏世界。<br><img src="/images/article/Games104/18/Games104_18_76.png"><span class="image-caption">帧同步的在线游戏</span></p><h4 id="帧同步初始化（Lockstep-Initialization）"><a href="#帧同步初始化（Lockstep-Initialization）" class="headerlink" title="帧同步初始化（Lockstep Initialization）"></a>帧同步初始化（Lockstep Initialization）</h4><p>使用帧同步时首先需要进行初始化，将客户端上所有的游戏数据与服务器进行同步。这一过程一般是在游戏loading阶段来实现的。<br><img src="/images/article/Games104/18/Games104_18_77.png"><span class="image-caption">帧同步初始化</span></p><h4 id="确定性的帧同步（Deterministic-Lockstep）"><a href="#确定性的帧同步（Deterministic-Lockstep）" class="headerlink" title="确定性的帧同步（Deterministic Lockstep）"></a>确定性的帧同步（Deterministic Lockstep）</h4><p>在游戏过程中客户端会在每一帧将玩家数据发送到服务器上，服务器接收到所有玩家的数据后再统一转发到玩家客户端上，然后由玩家客户端执行游戏逻辑。当然这种同步方式也存在一定的缺陷，当某个玩家的数据滞后了所有玩家都必须要进行等待。这种情况在一些早期的联网游戏中都很常见。<br><img src="/images/article/Games104/18/Games104_18_78.png"><span class="image-caption">确定性的帧同步</span><br><img src="/images/article/Games104/18/Games104_18_79.png"><span class="image-caption">确定性的帧同步2</span><br><img src="/images/article/Games104/18/Games104_18_80.png"><span class="image-caption">玩家脱机在确定性的锁定步骤</span></p><h4 id="存储桶同步（Bucket-Synchronization）"><a href="#存储桶同步（Bucket-Synchronization）" class="headerlink" title="存储桶同步（Bucket Synchronization）"></a>存储桶同步（Bucket Synchronization）</h4><p>为了克服这样的问题，人们提出了<b>bucket synchronization</b>这样的策略。此时服务器只会等待bucket长度的时间，如果超时没有收到客户端发来的数据就越过去，看下一个bucket时间段能否接收到。通过这样的方式其它玩家就无需一直等待了。<br><img src="/images/article/Games104/18/Games104_18_81.png"><span class="image-caption">存储桶同步</span></p><p>bucket synchronization本质是对玩家数据的一致性以及游戏体验进行的一种权衡。<br><img src="/images/article/Games104/18/Games104_18_82.png"><span class="image-caption">在一致性和交互性维护之间的良好权衡</span></p><h4 id="确定性困难（Deterministic-Difficulties）"><a href="#确定性困难（Deterministic-Difficulties）" class="headerlink" title="确定性困难（Deterministic Difficulties）"></a>确定性困难（Deterministic Difficulties）</h4><p>帧同步的一大难点在于它要保证不同客户端上游戏世界在相同输入的情况下有着完全一致的输出。<br><img src="/images/article/Games104/18/Games104_18_83.png"><span class="image-caption">确定性困难</span></p><p>为了保证输出的确定性我们首先要保证浮点数在不同客户端上的一致性，这可以使用IEEE 754标准来实现。<br><img src="/images/article/Games104/18/Games104_18_84.png"><span class="image-caption">浮点数</span></p><p>其次在不同的设备上我们需要保证相关的数学运算函数有一致的行为，对于这种问题则可以使用查表的方式来避免实际的计算。<br><img src="/images/article/Games104/18/Games104_18_85.png"><span class="image-caption">浮点数2</span><br><img src="/images/article/Games104/18/Games104_18_86.png"><span class="image-caption">浮点数3</span></p><p>除此之外还可以使用定点数来替换浮点数，从而避免浮点数导致的各种问题。<br><img src="/images/article/Games104/18/Games104_18_87.png"><span class="image-caption">浮点数4</span></p><p>除了浮点数之外还要考虑随机数的问题，我们要求随机数在不同的客户端上也必须是完全一致的。因此在游戏客户端和服务器进行同步时需要将随机数种子以及随机数生成算法进行同步。<br><img src="/images/article/Games104/18/Games104_18_88.png"><span class="image-caption">随机数</span><br><img src="/images/article/Games104/18/Games104_18_89.png"><span class="image-caption">随机数2</span></p><p>总结一下，保证客户端上游戏世界模拟一致的常用方法如下：<br><img src="/images/article/Games104/18/Games104_18_90.png"><span class="image-caption">确定性困难</span></p><h4 id="跟踪和调试（Tracing-and-Debugging）"><a href="#跟踪和调试（Tracing-and-Debugging）" class="headerlink" title="跟踪和调试（Tracing and Debugging）"></a>跟踪和调试（Tracing and Debugging）</h4><p>现代网络游戏的逻辑往往非常复杂，在玩家进行游玩时可能无法避免地出现一些bug，因此对于服务器来说检测客户端发送的数据是否存在bug就非常重要。一般来说我们会要求客户端每隔一段时间就上传本地的log，由服务器来检查上传数据是否存在bug。<br><img src="/images/article/Games104/18/Games104_18_91.png"><span class="image-caption">跟踪和调试</span></p><h4 id="滞后和延迟（Lag-and-Delay）"><a href="#滞后和延迟（Lag-and-Delay）" class="headerlink" title="滞后和延迟（Lag and Delay）"></a>滞后和延迟（Lag and Delay）</h4><p>为了处理网络延迟的问题我们还可以在客户端上缓存若干帧，当然缓存的大小会在一定程度上影响玩家的游戏体验。<br><img src="/images/article/Games104/18/Games104_18_92.png"><span class="image-caption">滞后和延迟</span></p><p>另一方面我们还可以把游戏逻辑帧和渲染帧进行分离，然后通过插值的方式来获得更加平滑的渲染效果。<br><img src="/images/article/Games104/18/Games104_18_93.png"><span class="image-caption">区分游戏逻辑和渲染功能</span><br><img src="/images/article/Games104/18/Games104_18_94.png"><span class="image-caption">区分游戏逻辑和渲染功能2</span></p><h4 id="重新连接问题（Reconnection-Problem）"><a href="#重新连接问题（Reconnection-Problem）" class="headerlink" title="重新连接问题（Reconnection Problem）"></a>重新连接问题（Reconnection Problem）</h4><p>由于网络的不稳定，玩家可能会不可避免地遇到断线的情况，此时我们还需要设计断线重连的机制。<br><img src="/images/article/Games104/18/Games104_18_95.png"><span class="image-caption">重新连接问题</span></p><p>实际上再进行帧同步时每个若干帧会设置一个关键帧。在关键帧进行同步时还会更新游戏世界的快照，这样可保证即使游戏崩溃了也可以从快照中恢复。<br><img src="/images/article/Games104/18/Games104_18_96.png"><span class="image-caption">客户端游戏状态快照</span></p><p>为了实现这样的功能可以使用<b>quick catch up</b>技术，此时我们暂停游戏的渲染把所有的计算资源用来执行游戏逻辑。<br><img src="/images/article/Games104/18/Games104_18_97.png"><span class="image-caption">快速追赶</span></p><p>而在服务器端也可以使用类似的技术，从而帮助掉线的玩家快速恢复到游戏的当前状态。实际上网络游戏的观战和回放功能也是使用这样的技术来实现的。<br><img src="/images/article/Games104/18/Games104_18_98.png"><span class="image-caption">服务器状态快照优化</span><br><img src="/images/article/Games104/18/Games104_18_99.png"><span class="image-caption">临时脱机，无崩溃</span><br><img src="/images/article/Games104/18/Games104_18_100.png"><span class="image-caption">观战</span><br><img src="/images/article/Games104/18/Games104_18_101.png"><span class="image-caption">重播</span></p><h4 id="帧同步作弊问题（Lockstep-Cheating-Issues）"><a href="#帧同步作弊问题（Lockstep-Cheating-Issues）" class="headerlink" title="帧同步作弊问题（Lockstep Cheating Issues）"></a>帧同步作弊问题（Lockstep Cheating Issues）</h4><p>网络游戏中作弊行为的检查是非常重要的。对于帧同步的游戏，玩家可以通过发送虚假的状态来实现作弊行为，这就要求我们实现一些反作弊机制。<br><img src="/images/article/Games104/18/Games104_18_102.png"><span class="image-caption">帧同步作弊问题</span><br><img src="/images/article/Games104/18/Games104_18_103.png"><span class="image-caption">帧同步作弊问题2</span><br><img src="/images/article/Games104/18/Games104_18_104.png"><span class="image-caption">帧同步作弊问题3</span></p><h4 id="帧同步总结（Lockstep-Summary）"><a href="#帧同步总结（Lockstep-Summary）" class="headerlink" title="帧同步总结（Lockstep Summary）"></a>帧同步总结（Lockstep Summary）</h4><p>总结一下，帧同步会占用更少的带宽也比较适合各种需要实时反馈的游戏。而帧同步的难点主要集中在如何保证在不同客户端上游戏运行的一致性，如何设计断线重连机制等。<br><img src="/images/article/Games104/18/Games104_18_105.png"><span class="image-caption">帧同步总结</span><br><img src="/images/article/Games104/18/Games104_18_106.png"><span class="image-caption">帧同步总结2</span></p><h3 id="状态同步（State-Synchronization）"><a href="#状态同步（State-Synchronization）" class="headerlink" title="状态同步（State Synchronization）"></a>状态同步（State Synchronization）</h3><p><b>状态同步(state synchronization)</b>是目前大型网游非常流行的同步技术，它的基本思想是把玩家的状态和事件进行同步。<br><img src="/images/article/Games104/18/Games104_18_107.png"><span class="image-caption">状态同步</span><br><img src="/images/article/Games104/18/Games104_18_108.png"><span class="image-caption">状态同步2</span></p><p>进行状态同步时由客户端提交玩家的状态数据，而服务器则会在收集到所有玩家的数据后运行游戏逻辑，然后把下一时刻的状态分发给所有的客户端。<br><img src="/images/article/Games104/18/Games104_18_109.png"><span class="image-caption">状态同步3</span><br><img src="/images/article/Games104/18/Games104_18_110.png"><span class="image-caption">服务器授权的游戏世界</span></p><h4 id="授权和复制的客户端（Authorized-and-Replicated-Clients）"><a href="#授权和复制的客户端（Authorized-and-Replicated-Clients）" class="headerlink" title="授权和复制的客户端（Authorized and Replicated Clients）"></a>授权和复制的客户端（Authorized and Replicated Clients）</h4><p>状态同步中服务器称为<b>authorized server</b>，它是整个游戏世界的绝对权威；而玩家的本地客户端称为<b>authorized client</b>，它是玩家操作游戏角色的接口；在其他玩家视角下的同一角色则称为<b>replicated client</b>，表示它们仅仅是authorized client的一个副本。<br><img src="/images/article/Games104/18/Games104_18_111.png"><span class="image-caption">授权和复制的客户端</span></p><h4 id="状态同步示例（State-Synchronization-Example）"><a href="#状态同步示例（State-Synchronization-Example）" class="headerlink" title="状态同步示例（State Synchronization Example）"></a>状态同步示例（State Synchronization Example）</h4><p>当authorized client执行了某种行为时首先会向服务发送相关的数据，然后由服务器驱动游戏逻辑并把相应的状态发布给所有的玩家。当其他客户端接收到更新后的状态时，再驱动replicated client执行authorized client的行为。类似地，authorized client行为产生的后果也是由服务器进行计算再发布给所有的客户端。这样的好处在于我们无需要求每个客户端上的模拟是严格一致的，整个游戏世界本质上仍然是由统一的服务器进行驱动。<br><img src="/images/article/Games104/18/Games104_18_112.png"><span class="image-caption">状态同步示例</span><br><img src="/images/article/Games104/18/Games104_18_113.png"><span class="image-caption">状态同步示例2</span><br><img src="/images/article/Games104/18/Games104_18_114.png"><span class="image-caption">状态同步示例3</span><br><img src="/images/article/Games104/18/Games104_18_115.png"><span class="image-caption">状态同步示例4</span></p><h4 id="滞后的客户端问题（Dumb-Client-Problem）"><a href="#滞后的客户端问题（Dumb-Client-Problem）" class="headerlink" title="滞后的客户端问题（Dumb Client Problem）"></a>滞后的客户端问题（Dumb Client Problem）</h4></b><p><b>由于游戏角色的所有行为都需要经过服务器的确认才能执行，状态同步会产生</b>dumb client<b>的问题，即玩家视角下角色的行为可能是滞后的。<br><img src="/images/article/Games104/18/Games104_18_116.png"><span class="image-caption">滞后的客户端问题</span></b></p><b><p>要缓解这样的问题可以在客户端上对玩家的行为进行预测。比如说当角色需要进行移动时首先在本地移动半步，然后等服务器传来确定的消息后再进行对齐，这样就可以改善玩家的游戏体验。在守望先锋中就使用了这样的方式来保证玩家顺畅的游玩。<br><img src="/images/article/Games104/18/Games104_18_117.png"><span class="image-caption">客户端预测</span><br><img src="/images/article/Games104/18/Games104_18_118.png"><span class="image-caption">监督-客户端预测</span></p><p>由于网络波动的存在，来自服务器的确认消息往往会滞后于本地的预测。因此我们可以使用一个buffer来缓存游戏角色的状态，这样当收到服务器的消息时首先跟buffer中的状态进行检验。当buffer中的状态和服务器的数据不一致时就需要根据服务器的数据来矫正玩家状态。<br><img src="/images/article/Games104/18/Games104_18_119.png"><span class="image-caption">服务器调整</span><br><img src="/images/article/Games104/18/Games104_18_120.png"><span class="image-caption">服务器调整2</span><br><img src="/images/article/Games104/18/Games104_18_121.png"><span class="image-caption">服务器调整3</span><br><img src="/images/article/Games104/18/Games104_18_122.png"><span class="image-caption">服务器调整4</span></p><p>当然这样的机制对于网络条件不好的玩家是不太公平的，他们的角色状态会不断地被服务器修正。<br><img src="/images/article/Games104/18/Games104_18_123.png"><span class="image-caption">服务器对齐示例</span></p><h4 id="丢包（Packet-Loss）"><a href="#丢包（Packet-Loss）" class="headerlink" title="丢包（Packet Loss）"></a>丢包（Packet Loss）</h4><p>对于丢包的问题在服务器端也会维护一个小的buffer来储存玩家的状态。如果buffer被清空则说明可能出现了掉线的情况，此时服务器会复制玩家上一个输入来维持游戏的运行。<br><img src="/images/article/Games104/18/Games104_18_124.png"><span class="image-caption">丢包</span></p><p>帧同步和状态同步两种主流同步技术的对比如下：<br><img src="/images/article/Games104/18/Games104_18_125.png"><span class="image-caption">状态同步与帧同步</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/08/10/GAMES104-NOTES-18.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1La411o7kG/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV1HN4y157Zq/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_PPT_Lecture%2018_Online%20Gaming%20Architecture-Fundamentals.pdf">课件PPT</a></p></b>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 高级AI（十七）</title>
      <link href="/posts/3f39b042.html"/>
      <url>/posts/3f39b042.html</url>
      
        <content type="html"><![CDATA[<h2 id="高级AI大纲"><a href="#高级AI大纲" class="headerlink" title="高级AI大纲"></a>高级AI大纲</h2><p><img src="/images/article/Games104/17/Games104_17_01.png"><span class="image-caption">高级AI大纲</span></p><h2 id="层次任务网络（Hierarchical-Tasks-Network）"><a href="#层次任务网络（Hierarchical-Tasks-Network）" class="headerlink" title="层次任务网络（Hierarchical Tasks Network）"></a>层次任务网络（Hierarchical Tasks Network）</h2><p><b>层次任务网络(hierarchical tasks network, HTN)</b>是经典的游戏AI技术，和上一节介绍过的行为树相比HTN可以更好地表达AI自身的意志和驱动力。<br><img src="/images/article/Games104/17/Games104_17_02.png"><span class="image-caption">概括</span></p><p>HTN的思想是把总体目标分解成若干个步骤，其中每个步骤可以包含不同的选项。AI在执行时需要按照顺序完成每个步骤，并且根据自身的状态选择合适的行为。<br><img src="/images/article/Games104/17/Games104_17_03.png"><span class="image-caption">像人一样制定一个计划</span></p><h3 id="分层任务网络框架（HTN-Framework）"><a href="#分层任务网络框架（HTN-Framework）" class="headerlink" title="分层任务网络框架（HTN Framework）"></a>分层任务网络框架（HTN Framework）</h3><p>HTN框架中包含两部分，<b>world state</b>和<b>sensor</b>两部分。其中world state是AI对于游戏世界的认知，而sensor则是AI从游戏世界获取信息的渠道。<br><img src="/images/article/Games104/17/Games104_17_04.png"><span class="image-caption">分层任务网络框架</span></p><p>除此之外HTN还包括<b>domain</b>，<b>planner</b>以及<b>plan runner</b>来表示AI的规划以及执行规划的过程。<br><img src="/images/article/Games104/17/Games104_17_05.png"><span class="image-caption">分层任务网络框架2</span></p><h3 id="分层网络任务类型（HTN-Task-Types）"><a href="#分层网络任务类型（HTN-Task-Types）" class="headerlink" title="分层网络任务类型（HTN Task Types）"></a>分层网络任务类型（HTN Task Types）</h3><p>在HTN中我们将任务分为两类，<b>primitive task</b>和<b>compound task</b>。<br><img src="/images/article/Games104/17/Games104_17_06.png"><span class="image-caption">分层网络任务类型</span></p><p>primitive task一般表示一个具体的动作或行为。在HTN中每个primitive task需要包含precondition、action以及effects三个要素。<br><img src="/images/article/Games104/17/Games104_17_07.png"><span class="image-caption">原始任务</span><br><img src="/images/article/Games104/17/Games104_17_08.png"><span class="image-caption">原始任务2</span></p><p>而compound task则包含不同的方法，我们把这些方法按照一定的优先级组织起来并且在执行时按照优先级高到低的顺序进行选择。每个方法还可以包含其它的primitive task或者compound task，当方法内所有的task都执行完毕则表示任务完成。<br><img src="/images/article/Games104/17/Games104_17_09.png"><span class="image-caption">复合任务</span><br><img src="/images/article/Games104/17/Games104_17_10.png"><span class="image-caption">复合任务2</span></p><p>在此基础上就可以构造出整个HTN的domain，从而实现AI的行为逻辑。<br><img src="/images/article/Games104/17/Games104_17_11.png"><span class="image-caption">HTN域</span><br><img src="/images/article/Games104/17/Games104_17_12.png"><span class="image-caption">HTN域2</span></p><h3 id="规划（Planning）"><a href="#规划（Planning）" class="headerlink" title="规划（Planning）"></a>规划（Planning）</h3><p>接下来就可以进行规划了，我们从root task出发不断进行展开逐步完成每个任务。<br><img src="/images/article/Games104/17/Games104_17_13.png"><span class="image-caption">规划</span><br><img src="/images/article/Games104/17/Games104_17_14.png"><span class="image-caption">规划2</span><br><img src="/images/article/Games104/17/Games104_17_15.png"><span class="image-caption">规划3</span><br><img src="/images/article/Games104/17/Games104_17_16.png"><span class="image-caption">规划4</span><br><img src="/images/article/Games104/17/Games104_17_17.png"><span class="image-caption">规划5</span><br><img src="/images/article/Games104/17/Games104_17_18.png"><span class="image-caption">规划6</span><br><img src="/images/article/Games104/17/Games104_17_19.png"><span class="image-caption">规划7</span></p><h3 id="重新规划（Replan）"><a href="#重新规划（Replan）" class="headerlink" title="重新规划（Replan）"></a>重新规划（Replan）</h3><p>执行plan时需要注意有时任务会失败，这就需要我们重新进行规划，这一过程称为<b>replan</b>。<br><img src="/images/article/Games104/17/Games104_17_20.png"><span class="image-caption">运行规划</span></p><p>当plan执行完毕或是发生失败，亦或是world state发生改变后就需要进行replan。<br><img src="/images/article/Games104/17/Games104_17_21.png"><span class="image-caption">重新规划</span></p><p>总结一下HTN和BT非常相似，但它更加符合人的直觉也更易于设计师进行掌握。<br><img src="/images/article/Games104/17/Games104_17_22.png"><span class="image-caption">总结</span></p><h2 id="目标导向的AI系统（Goal-Oriented-Action-Planning-GOAP）"><a href="#目标导向的AI系统（Goal-Oriented-Action-Planning-GOAP）" class="headerlink" title="目标导向的AI系统（Goal-Oriented Action Planning - GOAP）"></a>目标导向的AI系统（Goal-Oriented Action Planning - GOAP）</h2><p><b>goal-oriented action planning(GOAP)</b>是一种基于规划的AI技术，和前面介绍过的方法相比GOAP一般会更适合动态的环境。<br><img src="/images/article/Games104/17/Games104_17_23.png"><span class="image-caption">目标导向的AI系统</span></p><h3 id="结构（Structure）"><a href="#结构（Structure）" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h3><p>GOAP的整体结构与HTN非常相似，不过在GOAP中domain被替换为<b>goal set</b>和<b>action set</b>。<br><img src="/images/article/Games104/17/Games104_17_24.png"><span class="image-caption">结构</span></p><p>goal set表示AI所有可以达成的目标。在GOAP中需要显式地定义可以实现的目标，这要求我们把目标使用相应的状态来进行表达。<br><img src="/images/article/Games104/17/Games104_17_25.png"><span class="image-caption">目标集合</span><br><img src="/images/article/Games104/17/Games104_17_26.png"><span class="image-caption">目标选择</span></p><p>而action set则接近于primitive task的概念，它表示AI可以执行的行为。需要注意的是action set还包含<b>代价(cost)</b>的概念，它表示不同动作的”优劣”程度。在进行规划时我们希望AI尽可能做出代价小的决策。<br><img src="/images/article/Games104/17/Games104_17_27.png"><span class="image-caption">操作集</span></p><h3 id="规划（Planning）-1"><a href="#规划（Planning）-1" class="headerlink" title="规划（Planning）"></a>规划（Planning）</h3><p>GOAP在进行规划时会从目标来倒推需要执行的动作，这一过程称为<b>反向规划(backward planning)</b>。<br><img src="/images/article/Games104/17/Games104_17_28.png"><span class="image-caption">像一个人一样反向规划</span></p><p>在进行规划时首先需要根据优先级来选取一个目标，然后查询实现目标需要满足的状态。为了满足这些状态需求，我们需要从action set中选择一系列动作。需要注意的是很多动作也有自身的状态需求，因此我们在选择动作时也需要把这些需求添加到列表中。最后不断地添加动作和需求直到所有的状态需求都得到了满足，这样就完成了反向规划。<br><img src="/images/article/Games104/17/Games104_17_29.png"><span class="image-caption">规划</span><br><img src="/images/article/Games104/17/Games104_17_30.png"><span class="image-caption">规划2</span><br><img src="/images/article/Games104/17/Games104_17_31.png"><span class="image-caption">规划3</span><br><img src="/images/article/Games104/17/Games104_17_32.png"><span class="image-caption">规划4</span></p><p>GOAP的难点在于如何从action set进行选择，我们要求状态需求都能够得到满足而且所添加动作的代价要尽可能小。显然这样的问题是一个<b>动态规划(dynamic programming)</b>问题，我们可以利用图这样的数据结构来进行求解。在构造图时把状态的组合作为图上的节点，不同节点之间的有向边表示可以执行的动作，边的权重则是动作的代价。这样整个规划问题就等价于在有向图上的最短路径问题。<br><img src="/images/article/Games104/17/Games104_17_33.png"><span class="image-caption">构建状态-行动成本图</span><br><img src="/images/article/Games104/17/Games104_17_34.png"><span class="image-caption">最低成本路径</span></p><p>总结一下GOAP可以让AI的行为更加动态，而且可以有效地解耦AI的目标与行为；而GOAP的主要缺陷在于它会比较消耗计算资源，一般情况下GOAP需要的计算量会远高于BT和HTN。<br><img src="/images/article/Games104/17/Games104_17_35.png"><span class="image-caption">总结</span></p><h2 id="蒙特卡洛树搜索（Monte-Carlo-Tree-Search）"><a href="#蒙特卡洛树搜索（Monte-Carlo-Tree-Search）" class="headerlink" title="蒙特卡洛树搜索（Monte Carlo Tree Search）"></a>蒙特卡洛树搜索（Monte Carlo Tree Search）</h2><p><b>蒙特卡洛树搜索(Monte Carlo tree search, MCTS)</b>也是经典的AI算法，实际上AlphaGo就是基于MCTS来实现的。简单来说，MCTS的思路是在进行决策时首先模拟大量可行的动作，然后从这些动作中选择最好的那个来执行。<br><img src="/images/article/Games104/17/Games104_17_36.png"><span class="image-caption">蒙特卡洛树搜索</span><br><img src="/images/article/Games104/17/Games104_17_37.png"><span class="image-caption">蒙特卡洛树搜索2</span></p><p>MCTS的核心是<b>Monte Carlo方法(Monte Carlo method)</b>，它指出定积分可以通过随机采样的方法来进行估计。<br><img src="/images/article/Games104/17/Games104_17_38.png"><span class="image-caption">Monte Carlo方法</span></p><p>以围棋为例，MCTS会根据当前棋盘上的状态来估计落子的位置。<br><img src="/images/article/Games104/17/Games104_17_39.png"><span class="image-caption">蒙特卡洛树搜索3</span></p><p>从数学的角度来看，我们把棋盘上棋子的位置称为<b>状态(state)</b>，同时把落子的过程称为<b>行为(action)</b>。这样整个游戏可以建模为从初始节点出发的状态转移过程，而且所有可能的状态转移可以表示为一棵树。<br><img src="/images/article/Games104/17/Games104_17_40.png"><span class="image-caption">状态和行动</span><br><img src="/images/article/Games104/17/Games104_17_41.png"><span class="image-caption">状态转移</span><br><img src="/images/article/Games104/17/Games104_17_42.png"><span class="image-caption">状态空间</span></p><p>显然构造出完整的树结构可能是非常困难的，不过实际上我们并不需要完整的树。在使用MCTS时，完成每一个行为后只需要重新以当前状态构造一棵新树即可。<br><img src="/images/article/Games104/17/Games104_17_43.png"><span class="image-caption">注意：重建每次移动重建状态空间</span></p><h3 id="模拟（Simulation）"><a href="#模拟（Simulation）" class="headerlink" title="模拟（Simulation）"></a>模拟（Simulation）</h3><p><b>模拟(simulation)</b>是MCTS中的重要一环，这里的”模拟”是指AI利用当前的策略快速地完成整个游戏过程。<br><img src="/images/article/Games104/17/Games104_17_44.png"><span class="image-caption">模拟：快速地玩游戏</span></p><h3 id="反向传播（Backpropagate）"><a href="#反向传播（Backpropagate）" class="headerlink" title="反向传播（Backpropagate）"></a>反向传播（Backpropagate）</h3><p>我们从同一节点出发进行不断的模拟就可以估计该节点的价值(胜率)。<br><img src="/images/article/Games104/17/Games104_17_45.png"><span class="image-caption">如何评估这些状态？</span></p><p>然后把模拟的结果从下向上进行传播就可以更新整个决策序列上所有节点的价值。<br><img src="/images/article/Games104/17/Games104_17_46.png"><span class="image-caption">反向传播</span></p><h3 id="迭代步骤（Iteration-Steps）"><a href="#迭代步骤（Iteration-Steps）" class="headerlink" title="迭代步骤（Iteration Steps）"></a>迭代步骤（Iteration Steps）</h3><p>这样我们就可以定义MCTS的迭代步骤如下：<br><img src="/images/article/Games104/17/Games104_17_47.png"><span class="image-caption">迭代步骤</span><br><img src="/images/article/Games104/17/Games104_17_48.png"><span class="image-caption">在“无限”状态空间中进行搜索</span></p><h4 id="选择（Selection）"><a href="#选择（Selection）" class="headerlink" title="选择（Selection）"></a>选择（Selection）</h4><p>在对节点进行选择时，MCTS会优先选择可拓展的节点。<br><img src="/images/article/Games104/17/Games104_17_49.png"><span class="image-caption">选择-可扩展节点</span></p><p>在进行拓展时往往还要权衡一些exploitation和exploration，因此我们可以把UCB可以作为一种拓展的准则。<br><img src="/images/article/Games104/17/Games104_17_50.png"><span class="image-caption">选择-开发与勘探</span><br><img src="/images/article/Games104/17/Games104_17_51.png"><span class="image-caption">UCB（上置信度区间）</span></p><p>这样在进行选择时首先需要从根节点出发然后不断选择当前UCB最大的那个节点向下进行访问，当访问到一个没有拓展过的节点时选择该节点进行展开。<br><img src="/images/article/Games104/17/Games104_17_52.png"><span class="image-caption">选择</span></p><h4 id="拓展（Expansion）"><a href="#拓展（Expansion）" class="headerlink" title="拓展（Expansion）"></a>拓展（Expansion）</h4><p>对节点进行展开时我们需要根据可执行的动作选择一组进行模拟，然后把模拟的结果自下而上进行传播。<br><img src="/images/article/Games104/17/Games104_17_53.png"><span class="image-caption">拓展</span><br><img src="/images/article/Games104/17/Games104_17_54.png"><span class="image-caption">模拟和回溯</span></p><h4 id="最终条件（The-End-Condition）"><a href="#最终条件（The-End-Condition）" class="headerlink" title="最终条件（The End Condition）"></a>最终条件（The End Condition）</h4><p>当对树的探索达到一定程度后就可以终止拓展过程，此时我们就得到了树结构上每个节点的价值。<br><img src="/images/article/Games104/17/Games104_17_55.png"><span class="image-caption">最终条件</span></p><p>然后只需要回到根节点选择一个最优的子节点进行执行即可。<br><img src="/images/article/Games104/17/Games104_17_56.png"><span class="image-caption">如何选择最好的移动？</span></p><p>总结一下，MCTS是一种非常强大的决策算法而且很适合搜索空间巨大的决策问题；而它的主要缺陷在于它具有过大的计算复杂度，而且它的效果很大程度上依赖于状态和行为空间的设计。<br><img src="/images/article/Games104/17/Games104_17_57.png"><span class="image-caption">总结</span></p><h2 id="机器学习基础（Machine-Learning-Basic）"><a href="#机器学习基础（Machine-Learning-Basic）" class="headerlink" title="机器学习基础（Machine Learning Basic）"></a>机器学习基础（Machine Learning Basic）</h2><h3 id="机器学习技术（ML-Types）"><a href="#机器学习技术（ML-Types）" class="headerlink" title="机器学习技术（ML Types）"></a>机器学习技术（ML Types）</h3><p>近几年在<b>机器学习(machine learning, ML)</b>技术的不断发展下有越来越多的游戏AI开始使用机器学习来进行实现。根据学习的方式，机器学习大致可以分为监督学习、无监督学习、半监督学习以及强化学习等几类。<br><img src="/images/article/Games104/17/Games104_17_58.png"><span class="image-caption">四种类型的机器学习</span><br><img src="/images/article/Games104/17/Games104_17_59.png"><span class="image-caption">监督学习</span><br><img src="/images/article/Games104/17/Games104_17_60.png"><span class="image-caption">无监督学习</span><br><img src="/images/article/Games104/17/Games104_17_61.png"><span class="image-caption">半监督学习</span></p><p><b>强化学习(reinforcement learning, RL)</b>是游戏AI技术的基础。在强化学习中我们希望AI能够通过和环境的不断互动来学习到一个合理的策略。<br><img src="/images/article/Games104/17/Games104_17_62.png"><span class="image-caption">强化学习</span><br><img src="/images/article/Games104/17/Games104_17_63.png"><span class="image-caption">强化学习2</span></p><h3 id="Markov决策过程（Markov-Decision-Process）"><a href="#Markov决策过程（Markov-Decision-Process）" class="headerlink" title="Markov决策过程（Markov Decision Process）"></a>Markov决策过程（Markov Decision Process）</h3><p>强化学习的理论基础是<b>Markov决策过程(Markov decision process, MDP)</b>。在MDP中智能体对环境的感知称为<b>状态(state)</b>，环境对于智能体的反馈称为<b>奖励(reward)</b>。MDP的目标是让智能体通过和环境不断的互动来学习到如何在不同的环境下进行决策，这样的一个决策函数称为<b>策略(policy)</b>。<br><img src="/images/article/Games104/17/Games104_17_64.png"><span class="image-caption">Markov决策过程-基本要素</span><br><img src="/images/article/Games104/17/Games104_17_65.png"><span class="image-caption">Markov决策过程-状态</span><br><img src="/images/article/Games104/17/Games104_17_66.png"><span class="image-caption">Markov决策过程-行动</span><br><img src="/images/article/Games104/17/Games104_17_67.png"><span class="image-caption">Markov决策过程-奖励</span><br><img src="/images/article/Games104/17/Games104_17_68.png"><span class="image-caption">MDP数学模型</span><br><img src="/images/article/Games104/17/Games104_17_69.png"><span class="image-caption">策略</span></p><h2 id="构建高级游戏AI（Build-Advanced-Game-AI）"><a href="#构建高级游戏AI（Build-Advanced-Game-AI）" class="headerlink" title="构建高级游戏AI（Build Advanced Game AI）"></a>构建高级游戏AI（Build Advanced Game AI）</h2><p>尽管目前基于机器学习的游戏AI技术大多还处于试验阶段，但已经有一些很优秀的项目值得借鉴和学习，包括DeepMind的AlphaStar以及OpenAI的Five等。<br><img src="/images/article/Games104/17/Games104_17_70.png"><span class="image-caption">为什么游戏人工智能需要机器学习</span></p><p>这些基于<b>深度强化学习(deep reinforcement learning, DRL)</b>的游戏AI都是使用一个深度神经网络来进行决策，整个框架包括接收游戏环境的观测，利用神经网络获得行为，以及从游戏环境中得到反馈。<br><img src="/images/article/Games104/17/Games104_17_71.png"><span class="image-caption">游戏中的机器学习框架</span></p><h3 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h3><p>以AlphaStar为例，智能体可以直接从游戏环境获得的信息包括地图、统计数据、场景中的单位以及资源数据等。<br><img src="/images/article/Games104/17/Games104_17_72.png"><span class="image-caption">DRL示例-状态</span><br><img src="/images/article/Games104/17/Games104_17_73.png"><span class="image-caption">状态-地图</span><br><img src="/images/article/Games104/17/Games104_17_74.png"><span class="image-caption">状态2-地图</span></p><h3 id="行动（Actions）"><a href="#行动（Actions）" class="headerlink" title="行动（Actions）"></a>行动（Actions）</h3><p>在AlphaStar中智能体的行为还取决于当前选中的单位。<br><img src="/images/article/Games104/17/Games104_17_75.png"><span class="image-caption">行动</span></p><h3 id="奖励（Rewards）"><a href="#奖励（Rewards）" class="headerlink" title="奖励（Rewards）"></a>奖励（Rewards）</h3><p>奖励函数的设计对于模型的训练以及最终的性能都有着重要的影响。在AlphaStar中使用了非常简单的奖励设计，智能体仅在获胜时获得+1的奖励；而在OpenAI Five中则采用了更加复杂的奖励函数并以此来鼓励AI的进攻性。<br><img src="/images/article/Games104/17/Games104_17_76.png"><span class="image-caption">奖励</span><br><img src="/images/article/Games104/17/Games104_17_77.png"><span class="image-caption">奖励2</span></p><h3 id="神经网络（Network）"><a href="#神经网络（Network）" class="headerlink" title="神经网络（Network）"></a>神经网络（Network）</h3><p>在AlphaStar中使用了不同种类的神经网络来处理不同类型的输入数据，比如说对于定长的输入使用了MLP，对于图像数据使用了CNN，对于非定长的序列使用了Transformer，而对于整个决策过程还使用了LSTM进行处理。<br><img src="/images/article/Games104/17/Games104_17_78.png"><span class="image-caption">NN体系结构</span><br><img src="/images/article/Games104/17/Games104_17_79.png"><span class="image-caption">DRL示例——多层感知器（MLP）</span><br><img src="/images/article/Games104/17/Games104_17_80.png"><span class="image-caption">DRL示例-卷积神经网络（CNN）</span><br><img src="/images/article/Games104/17/Games104_17_81.png"><span class="image-caption">DRL示例-转换器</span><br><img src="/images/article/Games104/17/Games104_17_82.png"><span class="image-caption">DRL示例-长短期记忆递归（LSTM）</span><br><img src="/images/article/Games104/17/Games104_17_83.png"><span class="image-caption">DRL示例——神经网络架构的选择</span></p><h3 id="训练策略（Training-Strategy）"><a href="#训练策略（Training-Strategy）" class="headerlink" title="训练策略（Training Strategy）"></a>训练策略（Training Strategy）</h3><p>除此之外，AlphaStar还对模型的训练过程进行了大规模的革新。在AlphaStar的训练过程中首先使用了监督学习的方式来从人类玩家的录像中进行学习。<br><img src="/images/article/Games104/17/Games104_17_84.png"><span class="image-caption">训练策略-监督学习</span></p><p>接着，AlphaStar使用了强化学习的方法来进行自我训练。<br><img src="/images/article/Games104/17/Games104_17_85.png"><span class="image-caption">训练策略-强化学习</span><br><img src="/images/article/Games104/17/Games104_17_86.png"><span class="image-caption">训练代理-自我游戏和对抗性</span></p><p>试验结果分析表明基于监督学习训练的游戏AI其行为会比较接近于人类玩家，但基本无法超过人类玩家的水平；而基于强化学习训练的AI则可能会有超过玩家的游戏水平，不过需要注意的是使用强化学习可能需要非常多的训练资源。<br><img src="/images/article/Games104/17/Games104_17_87.png"><span class="image-caption">RL还是SL？——SL分析</span><br><img src="/images/article/Games104/17/Games104_17_88.png"><span class="image-caption">RL还是SL？——RL分析</span></p><p>因此对于游戏AI到底是使用监督学习还是使用强化学习进行训练需要结合实际的游戏环境进行考虑。对于奖励比较密集的环境可以直接使用强化学习进行训练，而对于奖励比较稀疏的环境则推荐使用监督学习。<br><img src="/images/article/Games104/17/Games104_17_89.png"><span class="image-caption">RL还是SL？——密集的奖励</span><br><img src="/images/article/Games104/17/Games104_17_90.png"><span class="image-caption">RL还是SL？——总结</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/07/28/GAMES104-NOTES-17.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1iG4y1i78Q/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV1ja411U7zK/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAME104_Lecture17_Gameplay%20Systems-Advanced%20Artificial%20Intelligence.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 基础AI（十六）</title>
      <link href="/posts/bd4c9b3a.html"/>
      <url>/posts/bd4c9b3a.html</url>
      
        <content type="html"><![CDATA[<h2 id="AI课程大纲"><a href="#AI课程大纲" class="headerlink" title="AI课程大纲"></a>AI课程大纲</h2><p><img src="/images/article/Games104/16/Games104_16_01.png"><span class="image-caption">AI课程大纲</span></p><h2 id="寻路系统（Navigation）"><a href="#寻路系统（Navigation）" class="headerlink" title="寻路系统（Navigation）"></a>寻路系统（Navigation）</h2><p>游戏AI是玩法系统重要的组成部分，其中最基本的功能是允许玩家选择目的地进行<b>导航(navigation)</b>。<br><img src="/images/article/Games104/16/Games104_16_02.png"><span class="image-caption">游戏中导航</span></p><p>导航算法需要考虑游戏地图的不同表达形式，然后寻找到从起点到目的地的最短路径，有时还需要结合一些其它算法来获得更加光滑的路线。<br><img src="/images/article/Games104/16/Games104_16_03.png"><span class="image-caption">导航步骤</span></p><h3 id="地图制图表达（Map-Representation）"><a href="#地图制图表达（Map-Representation）" class="headerlink" title="地图制图表达（Map Representation）"></a>地图制图表达（Map Representation）</h3><p>因此我们首先需要考虑游戏中如何来表达地图，我们可以认为地图是玩家和NPC可以行动的区域。游戏中常见的地图形式包括路点<b>网络图(waypoint network)</b>、<b>网格(grid)</b>、<b>寻路网格(navigation mesh)</b>以及<b>八叉树(sparse voxel octree)</b>等<br><img src="/images/article/Games104/16/Games104_16_04.png"><span class="image-caption">地图表达-可走区域</span><br><img src="/images/article/Games104/16/Games104_16_05.png"><span class="image-caption">地图表达-格式</span></p><h4 id="网络图（Waypoint-Network）"><a href="#网络图（Waypoint-Network）" class="headerlink" title="网络图（Waypoint Network）"></a>网络图（Waypoint Network）</h4><p>waypoint network是早期游戏中最常用的地图表示方式。我们可以把地图上的路标使用节点来表示，然后可通行的节点使用边来连接起来就形成了一个网络结构。<br><img src="/images/article/Games104/16/Games104_16_06.png"><span class="image-caption">航路点网络</span></p><p>当玩家需要进行导航时只需要选择距离起点和目的地最近的两个路标，然后在网络图上进行导航即可。<br><img src="/images/article/Games104/16/Games104_16_07.png"><span class="image-caption">航路点网络2</span></p><p>waypoint network的优势在于它非常易于实现，而且我们有成熟的路径搜索算法可以直接应用在网络图上；但它的缺陷在于路网图需要不断地和开发中的地图进行更新，而且使用路网进行导航时角色会倾向于沿路径中心前进而无法利用两边的通道。因此在现代游戏中路网的应用并不是很多。<br><img src="/images/article/Games104/16/Games104_16_08.png"><span class="image-caption">航路点网络3</span></p><h4 id="网格（Grid）"><a href="#网格（Grid）" class="headerlink" title="网格（Grid）"></a>网格（Grid）</h4><p>网格同样是表达游戏地图的经典方法，常用的网格地图包括方格地图、三角形地图或是六边形地图等。<br><img src="/images/article/Games104/16/Games104_16_09.png"><span class="image-caption">网格</span></p><p>使用网格来表示地图时只需要把不可通行的区域遮挡住就可以了，因此网格可以动态地反映地图环境的变化。<br><img src="/images/article/Games104/16/Games104_16_10.png"><span class="image-caption">网格2</span></p><p>显然网格地图同样非常容易实现，而且支持动态更新，也便于调试；而它的缺陷在于网格地图的精度受制于地图分辨率，而且比较占用存储空间，最严重的问题是网格很难表示重叠区域之间的连接关系。<br><img src="/images/article/Games104/16/Games104_16_11.png"><span class="image-caption">网格3</span></p><h4 id="寻路网格（Navigation-Mesh）"><a href="#寻路网格（Navigation-Mesh）" class="headerlink" title="寻路网格（Navigation Mesh）"></a>寻路网格（Navigation Mesh）</h4><p>为了克服网格地图的这些问题，人们开发出了寻路网格这样的地图表达形式。在寻路网格中可通行的区域会使用多边形来进行覆盖，这样可以方便地表达不同区域直接相互连接的拓扑关系。<br><img src="/images/article/Games104/16/Games104_16_12.png"><span class="image-caption">寻路网格</span><br><img src="/images/article/Games104/16/Games104_16_13.png"><span class="image-caption">寻路网格例子</span></p><p>在寻路网格中我们还会要求每个多边形都必须是凸多边形，这样才能保证角色在行进中不会穿过网格。<br><img src="/images/article/Games104/16/Games104_16_14.png"><span class="image-caption">寻路网格多边形</span></p><p>寻路网格是现代游戏中广泛应用的地图表达形式，而它的缺陷主要在于生成寻路网格的算法相对比较复杂，而且它无法表达三维空间的拓扑连接关系。<br><img src="/images/article/Games104/16/Games104_16_15.png"><span class="image-caption">寻路网格优点和缺点</span></p><h4 id="八叉树（Sparse-Voxel-Octree）"><a href="#八叉树（Sparse-Voxel-Octree）" class="headerlink" title="八叉树（Sparse Voxel Octree）"></a>八叉树（Sparse Voxel Octree）</h4><p>如果要制作三维空间中的地图则可以考虑八叉树这样的数据结构。<br><img src="/images/article/Games104/16/Games104_16_16.png"><span class="image-caption">八叉树</span></p><h3 id="寻路（Path-Finding）"><a href="#寻路（Path-Finding）" class="headerlink" title="寻路（Path Finding）"></a>寻路（Path Finding）</h3><p>得到游戏地图后就可以使用寻路算法来计算路径了，当然无论我们使用什么样的地图表达方式我们首先都需要把游戏地图转换为拓扑地图，然后再使用相应的算法进行寻路。<br><img src="/images/article/Games104/16/Games104_16_17.png"><span class="image-caption">寻路</span><br><img src="/images/article/Games104/16/Games104_16_18.png"><span class="image-caption">寻路2</span></p><h4 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth-First Search）"></a>深度优先搜索（Depth-First Search）</h4><p>寻路算法的本质是在图上进行搜索，因此我们可以使用<b>深度优先搜索(depth-first search, DFS)</b>来进行求解。<br><img src="/images/article/Games104/16/Games104_16_19.png"><span class="image-caption">深度优先搜索</span></p><h4 id="广度优先搜索（Breadth-First-Search）"><a href="#广度优先搜索（Breadth-First-Search）" class="headerlink" title="广度优先搜索（Breadth-First Search）"></a>广度优先搜索（Breadth-First Search）</h4><p>另一种常用的图搜索算法是<b>广度优先搜索(breadth-first search, BSF)</b>。<br><img src="/images/article/Games104/16/Games104_16_20.png"><span class="image-caption">广度优先搜索</span></p><h4 id="Dijkstra算法（Dijkstra-Algorithm）"><a href="#Dijkstra算法（Dijkstra-Algorithm）" class="headerlink" title="Dijkstra算法（Dijkstra Algorithm）"></a>Dijkstra算法（Dijkstra Algorithm）</h4><p>直接使用DFS或是BFS往往是过于低效的，实践中更常用的寻路算法是<b>Dijkstra算法(Dijkstra algorithm)</b>。<br><img src="/images/article/Games104/16/Games104_16_21.png"><span class="image-caption">Dijkstra算法</span><br><img src="/images/article/Games104/16/Games104_16_22.png"><span class="image-caption">Dijkstra算法2</span><br><img src="/images/article/Games104/16/Games104_16_23.png"><span class="image-caption">Dijkstra算法3</span></p><h4 id="A-Star（A-）"><a href="#A-Star（A-）" class="headerlink" title="A Star（A*）"></a>A Star（A*）</h4><p>Dijkstra算法可以计算从起始节点出发到图上任意节点的最短路径，但它的缺陷在于图上很多节点对于我们想要计算的路径是没有意义的。因此人们还提出了A star算法来进行改进，在<b>A star</b>算法中通过引入一个启发式函数来控制节点访问的倾向性，使得路径的搜索会更倾向于访问目标点。<br><img src="/images/article/Games104/16/Games104_16_24.png"><span class="image-caption">A*</span><br><img src="/images/article/Games104/16/Games104_16_25.png"><span class="image-caption">A*-成本计算</span></p><p>在网格地图中常用的启发函数包括Manhattan距离等。<br><img src="/images/article/Games104/16/Games104_16_26.png"><span class="image-caption">A*-网格上的启发</span></p><p>而在寻路网格中则可以使用欧氏距离作为启发函数。<br><img src="/images/article/Games104/16/Games104_16_27.png"><span class="image-caption">A*-寻路网格上的启发</span><br><img src="/images/article/Games104/16/Games104_16_28.png"><span class="image-caption">A*-寻路网格上的启发2</span><br><img src="/images/article/Games104/16/Games104_16_29.png"><span class="image-caption">A*-寻路网格预排</span></p><p>显然启发式算法的设计对于最终计算得到的路径会产生显著的影响。当启发函数的值过低时可能会需要更多次循环才能寻找到路径，而当启发函数值过高时则可能无法找到最短路径。因此在实际应用中需要进行一定的权衡。<br><img src="/images/article/Games104/16/Games104_16_30.png"><span class="image-caption">A*-启发</span></p><h3 id="路径平滑（Path-Smoothing）"><a href="#路径平滑（Path-Smoothing）" class="headerlink" title="路径平滑（Path Smoothing）"></a>路径平滑（Path Smoothing）</h3><p>直接使用寻路算法得到的路径往往包含各种各样的折线不够光滑，因此我们还需要使用一些路径平滑的算法来获得更加光滑的路径。<br><img src="/images/article/Games104/16/Games104_16_31.png"><span class="image-caption">路径平滑</span></p><p>游戏导航中比较常用funnel算法来对折线路径进行平滑，它不仅可以应用在二维平面上也可以应用在寻路网格上。<br><img src="/images/article/Games104/16/Games104_16_32.png"><span class="image-caption">路径平滑-漏斗算法</span><br><img src="/images/article/Games104/16/Games104_16_33.png"><span class="image-caption">路径平滑-漏斗算法2</span></p><h3 id="导航网格生成（NavMesh-Generation）"><a href="#导航网格生成（NavMesh-Generation）" class="headerlink" title="导航网格生成（NavMesh Generation）"></a>导航网格生成（NavMesh Generation）</h3><p>如何从游戏地图上生成寻路网格是一个相对困难的问题。<br><img src="/images/article/Games104/16/Games104_16_34.png"><span class="image-caption">导航网格生成</span></p><p>一般来说想要生成寻路网格首先需要将地图转换为体素，然后在体素地图上计算距离场得到区域的划分，最后就可以在划分好的区域中生成一个凸多边形网格作为寻路网格。<br><img src="/images/article/Games104/16/Games104_16_35.png"><span class="image-caption">导航网格生成-区域分割</span><br><img src="/images/article/Games104/16/Games104_16_36.png"><span class="image-caption">导航网格生成-区域分割2</span><br><img src="/images/article/Games104/16/Games104_16_37.png"><span class="image-caption">导航网格生成-区域分割3</span><br><img src="/images/article/Games104/16/Games104_16_38.png"><span class="image-caption">导航网格生成-区域分割4</span><br><img src="/images/article/Games104/16/Games104_16_39.png"><span class="image-caption">导航网格生成-网格生成</span></p><p>除此之外我们还可以在多边形上设置不同的flag来触发不同的动画、声效以及粒子效果。<br><img src="/images/article/Games104/16/Games104_16_40.png"><span class="image-caption">导航网格高级特征-多边形标志</span></p><p>对于动态的环境我们可以把巨大的场景地图划分为若干个tile。当某个tile中的环境发生改变时只需要重新计算该处的路径就可以得到新的路径。<br><img src="/images/article/Games104/16/Games104_16_41.png"><span class="image-caption">导航网格高级特征-瓦片</span></p><p>还需要注意的是使用自动化算法生成的寻路网格是不包括传送点这样的信息的，有时为了提升玩家和场景的互动我们还需要手动设置这些传送点。当然这会导致寻路算法更加复杂。<br><img src="/images/article/Games104/16/Games104_16_42.png"><span class="image-caption">导航网格高级特征-非网格链接</span></p><h2 id="转向系统（Steering）"><a href="#转向系统（Steering）" class="headerlink" title="转向系统（Steering）"></a>转向系统（Steering）</h2><p>得到最优路径后就可以根据路径来控制角色前进了。但在实际游戏中角色可能包含自身的运动学约束使得我们无法严格按照计算出的路径进行运动，这一点对于各种载具尤为明显。因此我们还需要结合<b>steering</b>算法来调整实际的行进路径。<br><img src="/images/article/Games104/16/Games104_16_43.png"><span class="image-caption">从路径到运动</span></p><p>steering算法可以按照行为分为以下几种：<b>追赶和逃脱(seek/flee)</b>、<b>速度匹配(velocity match)</b>以及<b>对齐(align)</b>。<br><img src="/images/article/Games104/16/Games104_16_44.png"><span class="image-caption">转向行为</span></p><h3 id="躲避或巡逻（Seek-Flee）"><a href="#躲避或巡逻（Seek-Flee）" class="headerlink" title="躲避或巡逻（Seek/Flee）"></a>躲避或巡逻（Seek/Flee）</h3><p>seek/flee的要求是根据自身和目标当前的位置来调整自身的加速度从而实现追赶或是逃脱的行为，像游戏中的跟踪、躲避或是巡逻等行为都可以使用seek/flee来实现。<br><img src="/images/article/Games104/16/Games104_16_45.png"><span class="image-caption">躲避或巡逻</span><br><img src="/images/article/Games104/16/Games104_16_46.png"><span class="image-caption">躲避或巡逻变化</span></p><h3 id="速度匹配（Velocity-Match）"><a href="#速度匹配（Velocity-Match）" class="headerlink" title="速度匹配（Velocity Match）"></a>速度匹配（Velocity Match）</h3><p>velocity match的目的是利用当前自身和目标的相对速度以及匹配时间来进行控制，使得自身可以按指定的速度到达目标位置。<br><img src="/images/article/Games104/16/Games104_16_47.png"><span class="image-caption">速度匹配</span></p><h3 id="对齐（Align）"><a href="#对齐（Align）" class="headerlink" title="对齐（Align）"></a>对齐（Align）</h3><p>align则是从角度和角加速度的层面进行控制，使得自身的朝向可以接近目标。<br><img src="/images/article/Games104/16/Games104_16_48.png"><span class="image-caption">对齐</span></p><h2 id="群体模拟（Crowd-Simulation）"><a href="#群体模拟（Crowd-Simulation）" class="headerlink" title="群体模拟（Crowd Simulation）"></a>群体模拟（Crowd Simulation）</h2><p><b>群体模拟(crowd simulation)</b>是游戏AI必须要处理的问题。在游戏场景中往往会具有大量的NPC，如何控制和模拟群体性的行为是现代游戏的一大挑战。<br><img src="/images/article/Games104/16/Games104_16_49.png"><span class="image-caption">群体</span></p><p>游戏场景中群体模拟的先驱是Reynolds，他同时也是steering系统的提出者。目前游戏中群体行为模拟的方法主要可以分为三种：<b>微观模型(microscopic models)</b>、<b>宏观模型(macroscopic models)</b>以及<b>混合模型(mesoscopic models)</b>。<br><img src="/images/article/Games104/16/Games104_16_50.png"><span class="image-caption">群体模拟模型</span></p><h3 id="微观模型（Microscopic-Models）"><a href="#微观模型（Microscopic-Models）" class="headerlink" title="微观模型（Microscopic Models）"></a>微观模型（Microscopic Models）</h3><p>微观模型的思想是对群体中每一个个体进行控制从而模拟群体的行为，通常情况下我们可以设计一些规则来控制个体的行为。<br><img src="/images/article/Games104/16/Games104_16_51.png"><span class="image-caption">微观模型-基于规则的模型</span><br><img src="/images/article/Games104/16/Games104_16_52.png"><span class="image-caption">微观模型-基于规则的模型2</span></p><h3 id="宏观模型（Macroscopic-Models）"><a href="#宏观模型（Macroscopic-Models）" class="headerlink" title="宏观模型（Macroscopic Models）"></a>宏观模型（Macroscopic Models）</h3><p>宏观模型的思想则是在场景中设计一个势场或流场来控制群体中每个个体的行为。<br><img src="/images/article/Games104/16/Games104_16_53.png"><span class="image-caption">宏观模型</span></p><h3 id="混合模型（Mesoscopic-Models）"><a href="#混合模型（Mesoscopic-Models）" class="headerlink" title="混合模型（Mesoscopic Models）"></a>混合模型（Mesoscopic Models）</h3><p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种RTS游戏中有着广泛的应用。<br><img src="/images/article/Games104/16/Games104_16_54.png"><span class="image-caption">混合模型</span></p><h3 id="碰撞（Collision-Avoidance）"><a href="#碰撞（Collision-Avoidance）" class="headerlink" title="碰撞（Collision Avoidance）"></a>碰撞（Collision Avoidance）</h3><p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种RTS游戏中有着广泛的应用。<br><img src="/images/article/Games104/16/Games104_16_55.png"><span class="image-caption">碰撞-基于力的模型</span><br><img src="/images/article/Games104/16/Games104_16_56.png"><span class="image-caption">碰撞-基于力的模型2</span></p><p>另一种处理的方法是基于<b>速度障碍(velocity obstacle, VO)</b>来进行控制。<br><img src="/images/article/Games104/16/Games104_16_57.png"><span class="image-caption">碰撞-速度障碍</span></p><p>VO的思想是当两个物体将要发生碰撞时相当于在速度域上形成了一定的障碍，因此需要调整自身的速度来避免相撞。<br><img src="/images/article/Games104/16/Games104_16_58.png"><span class="image-caption">速度障碍</span></p><p>当参与避让的个体数比较多时还需要进行一些整体的优化，此时可以使用ORCA等算法进行处理。<br><img src="/images/article/Games104/16/Games104_16_59.png"><span class="image-caption">反向速度障碍</span></p><h2 id="感知（Sensing）"><a href="#感知（Sensing）" class="headerlink" title="感知（Sensing）"></a>感知（Sensing）</h2><p><b>感知(sensing)</b>是游戏AI的基础，根据获得信息的不同我们可以把感知的内容分为<b>内部信息(internal information)</b>和<b>外部信息(external information)</b>。<br><img src="/images/article/Games104/16/Games104_16_60.png"><span class="image-caption">感测或感知</span></p><p>内部信息包括AI自身的位置、HP以及各种状态。这些信息一般可以被AI直接访问到，而且它们是AI进行决策的基础。<br><img src="/images/article/Games104/16/Games104_16_61.png"><span class="image-caption">内部信息</span></p><p>而外部信息则主要包括AI所处的场景中的信息，它会随着游戏进程和场景变化而发生改变。<br><img src="/images/article/Games104/16/Games104_16_62.png"><span class="image-caption">静态空间信息</span></p><p>外部信息的一种常用表达方式是influence map，场景的变化会直接反映在<b>influence map</b>上。当AI需要进行决策时会同时考虑自身的状态并且查询当前的influence map来选择自身的行为。<br><img src="/images/article/Games104/16/Games104_16_63.png"><span class="image-caption">动态空间信息-影响图</span><br><img src="/images/article/Games104/16/Games104_16_64.png"><span class="image-caption">动态空间信息-游戏对象</span></p><p>游戏AI进行感知时还需要注意我们不能假设AI可以直接获得所有游戏的信息，而是希望AI能够像玩家一样只利用局部感知的信息来进行决策。<br><img src="/images/article/Games104/16/Games104_16_65.png"><span class="image-caption">传感仿真</span></p><h2 id="经典决策算法（Classic-Decision-Making-Algorithms）"><a href="#经典决策算法（Classic-Decision-Making-Algorithms）" class="headerlink" title="经典决策算法（Classic Decision Making Algorithms）"></a>经典决策算法（Classic Decision Making Algorithms）</h2><p>在上面这些知识的基础上就可以开始构建游戏AI系统了。游戏AI算法的核心是<b>决策(decision making)</b>系统，经典的决策系统包括<b>有限状态机(finite state machine, FSM)</b>和<b>行为树(behavior tree, BT)</b>两种。<br><img src="/images/article/Games104/16/Games104_16_66.png"><span class="image-caption">决策算法</span></p><h3 id="有限状态机（Finite-State-Machine）"><a href="#有限状态机（Finite-State-Machine）" class="headerlink" title="有限状态机（Finite State Machine）"></a>有限状态机（Finite State Machine）</h3><p>在有限状态机模型中我们认为AI的行为可以建模为在不同状态之间的游走，不同状态之间的切换称为<b>转移(transition)</b>。以吃豆人游戏为例，游戏AI可以使用一个包含3个状态的状态机来表示。<br><img src="/images/article/Games104/16/Games104_16_67.png"><span class="image-caption">有限状态机</span><br><img src="/images/article/Games104/16/Games104_16_68.png"><span class="image-caption">有限状态机2</span></p><p>有限状态机的缺陷在于现代游戏中AI的状态空间可能是非常巨大的，因此状态之间的转移会无比复杂。<br><img src="/images/article/Games104/16/Games104_16_69.png"><span class="image-caption">有限状态机-利弊</span></p><p>为了克服有限状态机过于复杂的问题，人们还提出了<b>hierarchical finite state machine(HFSM)</b>这样的模型。在HFSM中我们把整个复杂的状态机分为若干层，不同层之间通过有向的接口进行连接，这样可以增加模型的可读性。<br><img src="/images/article/Games104/16/Games104_16_70.png"><span class="image-caption">分层有限状态机</span></p><h3 id="行为树（Behavior-Tree）"><a href="#行为树（Behavior-Tree）" class="headerlink" title="行为树（Behavior Tree）"></a>行为树（Behavior Tree）</h3><p>在现代游戏中更为常用的决策算法是行为树，它的决策行为更接近人脑的决策过程。<br><img src="/images/article/Games104/16/Games104_16_71.png"><span class="image-caption">行为树</span></p><p>行为树中的<b>执行节点(excution node)</b>表示AI执行的过程，它包括条件判断以及具体执行的动作两种节点。<br><img src="/images/article/Games104/16/Games104_16_72.png"><span class="image-caption">行为树-执行节点</span></p><p>行为树中的另一种节点是<b>控制节点(control node)</b>，它用来表示决策过程的控制流。control node包括sequence、selector、parallel以及decorator等几种。<br><img src="/images/article/Games104/16/Games104_16_73.png"><span class="image-caption">行为树-控制节点</span></p><p><b>sequence</b>是表示对当前节点的子节点依次进行访问和执行，一般可以用来表示AI在当前状态下的行为计划。<br><img src="/images/article/Games104/16/Games104_16_74.png"><span class="image-caption">控制节点-序列</span><br><img src="/images/article/Games104/16/Games104_16_75.png"><span class="image-caption">控制节点-序列2</span></p><p><b>selector</b>同样会遍历当前节点的子节点，但不同于sequence的地方是如果某个子节点返回True则会终止遍历。<br><img src="/images/article/Games104/16/Games104_16_76.png"><span class="image-caption">控制节点-选择器</span><br><img src="/images/article/Games104/16/Games104_16_77.png"><span class="image-caption">控制节点-选择器2</span></p><p><b>parallel</b>会同时执行当前节点下的所有子节点。<br><img src="/images/article/Games104/16/Games104_16_78.png"><span class="image-caption">控制节点-并行</span><br><img src="/images/article/Games104/16/Games104_16_79.png"><span class="image-caption">控制节点-并行2</span><br><img src="/images/article/Games104/16/Games104_16_80.png"><span class="image-caption">行为树</span></p><p>行为树在进行执行时需要注意每一次执行时都需要返回根节点。<br><img src="/images/article/Games104/16/Games104_16_81.png"><span class="image-caption">执行行为树</span></p><p>在现代游戏中还提出了<b>decorator</b>节点来丰富可以执行的行为。<br><img src="/images/article/Games104/16/Games104_16_82.png"><span class="image-caption">行为树-装饰器</span><br><img src="/images/article/Games104/16/Games104_16_83.png"><span class="image-caption">行为树-装饰器2</span></p><p>我们还可以使用<b>precondition</b>和<b>blackborad</b>来提升决策过程的可读性。<br><img src="/images/article/Games104/16/Games104_16_84.png"><span class="image-caption">行为树-先决条件</span><br><img src="/images/article/Games104/16/Games104_16_85.png"><span class="image-caption">行为树-黑板</span></p><p>行为树的决策过程非常符合人的决策行为而且也易于调试，因此广泛应用在各种游戏AI中。当然行为树也有一些缺点，比如说每次调用时都必须从根节点出发重新执行，这样的效率是比较低的。<br><img src="/images/article/Games104/16/Games104_16_86.png"><span class="image-caption">行为树-优点</span><br><img src="/images/article/Games104/16/Games104_16_87.png"><span class="image-caption">行为树-优点2</span><br><img src="/images/article/Games104/16/Games104_16_88.png"><span class="image-caption">行为树-缺点</span></p><p>目前随着AI技术的发展，游戏AI也开始使用一些<b>规划(planning)</b>算法来进行决策。这些更先进的算法我们会在后面的课程进行介绍。<br><img src="/images/article/Games104/16/Games104_16_89.png"><span class="image-caption">即将到来的目标是：人工智能规划和目标</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/07/26/GAMES104-NOTES-16.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV19N4y1T7eU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7a2542c6c909b3ee1fab551277360826">课程视频</a></p><p><a href="https://www.bilibili.com/video/BV1r34y1J7Sg/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture16_GameplaySystemsBasicArtificialIntelligence.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎的Gameplay玩法系统基础（十五）</title>
      <link href="/posts/12878169.html"/>
      <url>/posts/12878169.html</url>
      
        <content type="html"><![CDATA[<h2 id="游戏性课程框架（Overview）"><a href="#游戏性课程框架（Overview）" class="headerlink" title="游戏性课程框架（Overview）"></a>游戏性课程框架（Overview）</h2><p>玩法系统是游戏引擎最重要的部分，它是区分游戏引擎和渲染器以及物理引擎的核心。<br>实际上玩法系统往往会贯穿整个游戏引擎，与引擎的其它系统进行交互，这样才能满足游戏设计师的需求。<br><img src="/images/article/Games104/15/Games104_15_01.png"><span class="image-caption">游戏玩法中的挑战</span></p><p>另一方面现代游戏的玩法是极其丰富的，即使是同一类型的游戏也具有多种多样的表现形式。<br>这些丰富的游戏内容都需要通过玩法系统来进行实现。<br><img src="/images/article/Games104/15/Games104_15_02.png"><span class="image-caption">游戏玩法中的挑战2</span></p><p>而在游戏行业中玩法系统还面临着快速迭代的问题，同一个游戏的核心玩法在开发运营初期和后期可能会有着巨大的差别。<br>因此玩法系统在设计时也需要考虑需求变更和快速迭代。<br><img src="/images/article/Games104/15/Games104_15_03.png"><span class="image-caption">游戏玩法中的挑战3</span></p><h2 id="事件机制（Event-Mechanism）"><a href="#事件机制（Event-Mechanism）" class="headerlink" title="事件机制（Event Mechanism）"></a>事件机制（Event Mechanism）</h2><p>玩法系统的核心是<b>事件机制(event mechanism)</b>，在游戏世界中不同类型的GO会通过事件/消息的方式进行通信从而驱动游戏世界的运行。<br><img src="/images/article/Games104/15/Games104_15_04.png"><span class="image-caption">事件机制</span></p><h3 id="发布-订阅模式（Publish-Subscribe-Pattern）"><a href="#发布-订阅模式（Publish-Subscribe-Pattern）" class="headerlink" title="发布-订阅模式（Publish-Subscribe Pattern）"></a>发布-订阅模式（Publish-Subscribe Pattern）</h3><p>在游戏引擎中一般会使用<b>publish-subscribe</b>这样的模式来实现具体的通信过程。在publish-subscribe模式中每个GO有着自己的publish功能来向其它GO发送事件，<br>同时自身的subscribe功能来实现接收事件以及相应的反馈。当然在publish-subscribe模式中还需要一个<b>event dispatcher</b>来执行高效的事件派送。<br>因此在publish-subscribe模式中的三要素为<b>事件定义(event definition)</b>、<b>注册回调(callback registration)</b>以及<b>事件派送(event dispatching)</b>。<br><img src="/images/article/Games104/15/Games104_15_05.png"><span class="image-caption">发布-订阅</span><br><img src="/images/article/Games104/15/Games104_15_06.png"><span class="image-caption">发布-订阅的三个关键组件</span></p><h3 id="事件定义（Event-Definition）"><a href="#事件定义（Event-Definition）" class="headerlink" title="事件定义（Event Definition）"></a>事件定义（Event Definition）</h3><p>事件定义是实现事件机制的第一步，最简单的定义方式是为事件定义一个类型以及相应的参数。<br><img src="/images/article/Games104/15/Games104_15_07.png"><span class="image-caption">事件定义</span></p><p>因此我们可以使用继承的方式来实现不同类型事件的定义。但这种方式的缺陷在于玩法系统往往是由设计师来实现的，而对于游戏引擎来说一般无法由程序员事先确定。<br><img src="/images/article/Games104/15/Games104_15_08.png"><span class="image-caption">事件定义2</span></p><p>在现代游戏引擎中会使用反射和代码渲染的方式来允许设计师自定义事件类型和相关的数据。<br><img src="/images/article/Games104/15/Games104_15_09.png"><span class="image-caption">事件定义3</span></p><h3 id="回调注册（Callback-Registration）"><a href="#回调注册（Callback-Registration）" class="headerlink" title="回调注册（Callback Registration）"></a>回调注册（Callback Registration）</h3><p>当GO接收到事件后就会激活调用相应的回调函数来改变自身的状态，而为了正确地使用回调函数则首先需要对不同的回调函数进行注册。<br><img src="/images/article/Games104/15/Games104_15_10.png"><span class="image-caption">回调注册</span></p><p>回调函数的一大特点在于它的注册和执行往往是分开的。这一特点可能会导致回调函数调用时相关的一些GO可能已经结束了生命周期，因此回调函数的安全性是整个事件系统的一大难题。<br><img src="/images/article/Games104/15/Games104_15_11.png"><span class="image-caption">对象生命周期和回调注册</span><br><img src="/images/article/Games104/15/Games104_15_12.png"><span class="image-caption">对象生命周期和回调注册2</span></p><p>为了处理这样的问题我们可以使用<b>强引用(strong reference)</b>这样的机制来锁定相关GO的生命周期。强引用会保证所有和回调函数相关的资源在回调函数调用前不会被回收，从而确保系统的安全。<br><img src="/images/article/Games104/15/Games104_15_13.png"><span class="image-caption">对象强引用</span></p><p>当然强引用的方式在一些场景下可能是不合适的，很多时候我们希望某些资源可以正确的卸载掉。因此我们还可以使用<b>弱引用(weak reference)</b>的机制在调用回调函数时判断资源是否已经被卸载掉。当然弱引用机制的滥用可能会影响整个系统的性能。<br><img src="/images/article/Games104/15/Games104_15_14.png"><span class="image-caption">对象弱引用</span></p><h3 id="事件调度（Event-Dispatching）"><a href="#事件调度（Event-Dispatching）" class="headerlink" title="事件调度（Event Dispatching）"></a>事件调度（Event Dispatching）</h3><p>事件会通过分发系统来实现消息的传递。由于游戏中每一时刻往往存在着成千上万个GO和相应的回调函数，我们需要一个非常高效的分发系统才能保证游戏的实时性。<br><img src="/images/article/Games104/15/Games104_15_15.png"><span class="image-caption">事件调度</span></p><p>最简单的分发机制是把消息瞬时发出去。这种方式的缺陷在于它会阻塞前一个函数的执行，从而形成一个巨大的调用栈使得系统难以调试；此外很多回调函数在执行时会申请一些额外的资源，这就容易导致游戏的帧率很难稳定。<br><img src="/images/article/Games104/15/Games104_15_16.png"><span class="image-caption">事件调度：立即</span><br><img src="/images/article/Games104/15/Games104_15_17.png"><span class="image-caption">事件调度：立即2</span><br><img src="/images/article/Games104/15/Games104_15_18.png"><span class="image-caption">事件调度：立即3</span></p><p>现代游戏引擎中更常用的分发方式是使用<b>事件队列(event queue)</b>来收集当前帧上所有的事件，然后在下一帧再进行分发和处理。<br><img src="/images/article/Games104/15/Games104_15_19.png"><span class="image-caption">事件队列</span></p><p>由于event queue中有不同类型的事件，因此我们还需要结合序列化和反序列化的操作来进行存储。<br><img src="/images/article/Games104/15/Games104_15_20.png"><span class="image-caption">事件序列化和反序列化</span></p><p>event queue一般会使用ring buffer这样的数据结构来实现，这样可以重用一块统一的内存空间来提升效率。<br><img src="/images/article/Games104/15/Games104_15_21.png"><span class="image-caption">事件队列-环形缓冲器</span></p><p>现代游戏引擎中往往会同时有多个不同的event queue来处理不同类型的事件，每个queue用来保存一些相对独立的事件。这种方式可以便于我们进行调试，也可以提升系统的性能。<br><img src="/images/article/Games104/15/Games104_15_22.png"><span class="image-caption">事件队列-定量</span></p><p>当然event queue也有一些自身的问题。首先event queue无法保证event执行的顺序，同时对于一些实时性的事件event queue可能会导致执行的延误。<br><img src="/images/article/Games104/15/Games104_15_23.png"><span class="image-caption">事件队列问题</span></p><h2 id="游戏逻辑与脚本系统（Game-Logic）"><a href="#游戏逻辑与脚本系统（Game-Logic）" class="headerlink" title="游戏逻辑与脚本系统（Game Logic）"></a>游戏逻辑与脚本系统（Game Logic）</h2><p>在事件机制的基础上就可以开始设计游戏的逻辑了。在早期的游戏开发中会直接使用C++来编写游戏的逻辑来获得更高的运行效率，而随着游戏系统变得越来越复杂这种直接基于高级语言的开发方式就不能满足开发者的需求了。<br><img src="/images/article/Games104/15/Games104_15_24.png"><span class="image-caption">早期阶段的游戏逻辑编程</span><br><img src="/images/article/Games104/15/Games104_15_25.png"><span class="image-caption">编译语言问题</span></p><p>除此之外游戏引擎面对的用户往往是设计师而不是程序员，对于设计师来说直接使用编程语言来设计游戏可能是过于复杂的。<br><img src="/images/article/Games104/15/Games104_15_26.png"><span class="image-caption">设计师和程序员</span></p><p>因此在现代游戏引擎中往往会使用脚本语言来实现游戏的开发工作，它的优势在于它可以直接在虚拟机上运行。<br><img src="/images/article/Games104/15/Games104_15_27.png"><span class="image-caption">脚本语言</span><br><img src="/images/article/Games104/15/Games104_15_28.png"><span class="image-caption">脚本语言的工作原理</span></p><p>因此我们可以把游戏中的很多逻辑使用脚本语言来实现。<br><img src="/images/article/Games104/15/Games104_15_29.png"><span class="image-caption">脚本和引擎之间的对象管理</span><br><img src="/images/article/Games104/15/Games104_15_30.png"><span class="image-caption">脚本和引擎之间的对象管理2</span><br><img src="/images/article/Games104/15/Games104_15_31.png"><span class="image-caption">脚本系统的架构</span><br><img src="/images/article/Games104/15/Games104_15_32.png"><span class="image-caption">脚本系统的架构2</span></p><p>脚本语言的另一大特点是可以进行热更新。<br><img src="/images/article/Games104/15/Games104_15_33.png"><span class="image-caption">高级脚本功能-热更新</span></p><p>当然脚本语言也有许多缺点，比如说它的效率一般会比较低，因此选择合适的脚本语言是十分重要的。<br><img src="/images/article/Games104/15/Games104_15_34.png"><span class="image-caption">脚本语言的问题</span><br><img src="/images/article/Games104/15/Games104_15_35.png"><span class="image-caption">正确选择脚本语言</span></p><p>目前游戏行业中常用的脚本语言包括Lua、Python、C#等。<br><img src="/images/article/Games104/15/Games104_15_36.png"><span class="image-caption">流行的脚本语言</span><br><img src="/images/article/Games104/15/Games104_15_37.png"><span class="image-caption">流行的脚本语言2</span></p><h2 id="可视化脚本（Visual-Scripting）"><a href="#可视化脚本（Visual-Scripting）" class="headerlink" title="可视化脚本（Visual Scripting）"></a>可视化脚本（Visual Scripting）</h2><p>可视化脚本(visual scripting)是现代游戏引擎几乎必备的功能。和传统的脚本语言相比可视化脚本无需开发者直接进行编程，因此它对于设计师和艺术家而言更容易进行掌握。像虚幻和unity这样的商业级游戏引擎都实现了自身的可视化脚本功能。<br><img src="/images/article/Games104/15/Games104_15_38.png"><span class="image-caption">为什么我们需要可视化的脚本</span></p><p>当然可视化脚本本身也是一种编程语言，它需要实现相应的变量、语句、表达式、控制流程、函数甚至面向对象编程等功能。<br><img src="/images/article/Games104/15/Games104_15_39.png"><span class="image-caption">视觉脚本是一种程序语言</span></p><p>以虚幻引擎的blueprint功能为例，每个变量需要封装数据类型以及作用域两种属性。而在可视化脚本中，不同类型的数据会使用不同的颜色来方便用户进行区分。<br><img src="/images/article/Games104/15/Games104_15_40.png"><span class="image-caption">变量</span><br><img src="/images/article/Games104/15/Games104_15_41.png"><span class="image-caption">变量可视化-数据插针和导线</span></p><p>在变量的基础上可以构造表达式，在可视化脚本中会使用节点来进行表示。<br><img src="/images/article/Games104/15/Games104_15_42.png"><span class="image-caption">语句和表达式</span><br><img src="/images/article/Games104/15/Games104_15_43.png"><span class="image-caption">语句和表达式可视化-节点</span></p><p>而控制语句则会使用三角形的符号来表示。<br><img src="/images/article/Games104/15/Games104_15_44.png"><span class="image-caption">控制流</span><br><img src="/images/article/Games104/15/Games104_15_45.png"><span class="image-caption">控制流程可视化-执行销钉和电线</span></p><p>类似于高级语言中函数的概念，我们可以在可视化脚本中把节点按照一定的顺序连接起来形成一张图。<br><img src="/images/article/Games104/15/Games104_15_46.png"><span class="image-caption">函数</span><br><img src="/images/article/Games104/15/Games104_15_47.png"><span class="image-caption">函数可视化-函数图</span></p><p>我们还可以把数据和函数打包在一起，这样就形成了类的概念。<br><img src="/images/article/Games104/15/Games104_15_48.png"><span class="image-caption">类</span><br><img src="/images/article/Games104/15/Games104_15_49.png"><span class="image-caption">类可视化-蓝图</span></p><p>除此之外在可视化脚本中往往还需要提供一些方便用户操作的功能，如查找节点、调试等功能。<br><img src="/images/article/Games104/15/Games104_15_50.png"><span class="image-caption">使图形用户友好</span><br><img src="/images/article/Games104/15/Games104_15_51.png"><span class="image-caption">视觉脚本调试器</span></p><p>可视化脚本也有一些自身的问题。首先可视化脚本很难进行协作，在大型开发团队中很难把每个开发者定义的脚本直接组装到一起，往往需要通过大量人工的重新排序才能得到正确的结果；同时当脚本中的节点过多时整个脚本在视觉上可能会非常繁琐，让人难以阅读。<br><img src="/images/article/Games104/15/Games104_15_52.png"><span class="image-caption">可视化脚本的问题</span><br><img src="/images/article/Games104/15/Games104_15_53.png"><span class="image-caption">可视化脚本的问题2</span><br><img src="/images/article/Games104/15/Games104_15_54.png"><span class="image-caption">脚本和图表都是双胞胎</span></p><h2 id="游戏性开发中的3C"><a href="#游戏性开发中的3C" class="headerlink" title="游戏性开发中的3C"></a>游戏性开发中的3C</h2><p><b>角色(character)</b>、<b>控制(control)</b>以及<b>镜头(camera)</b>是构成玩家体验最重要的元素。<br><img src="/images/article/Games104/15/Games104_15_55.png"><span class="image-caption">什么是3C</span></p><h3 id="角色（Character）"><a href="#角色（Character）" class="headerlink" title="角色（Character）"></a>角色（Character）</h3><p>角色是指游戏中如何设置玩家控制角色以及NPC的运动和各种状态。<br><img src="/images/article/Games104/15/Games104_15_56.png"><span class="image-caption">角色</span></p><p>在现代游戏中角色的运动往往涉及大量不同的动画和状态改变，我们需要非常多的细节才能设计出符合人认知的角色运动。同时在游戏世界中角色还需要和环境中的各种元素进行互动，往往需要结合游戏引擎其它系统进行设计。<br><img src="/images/article/Games104/15/Games104_15_57.png"><span class="image-caption">特点：精心设计的运动</span><br><img src="/images/article/Games104/15/Games104_15_58.png"><span class="image-caption">扩展特征：更复杂和多样的状态</span><br><img src="/images/article/Games104/15/Games104_15_59.png"><span class="image-caption">扩展性能：与其他系统合作</span><br><img src="/images/article/Games104/15/Games104_15_60.png"><span class="image-caption">扩展特性：更真实的物理运动</span></p><p>因此角色系统一般需要一个非常复杂的状态机模型来描述角色状态的切换和转移。<br><img src="/images/article/Games104/15/Games104_15_61.png"><span class="image-caption">运动状态机</span></p><h3 id="控制（Control）"><a href="#控制（Control）" class="headerlink" title="控制（Control）"></a>控制（Control）</h3><p>控制系统的核心问题是要兼容玩家不同的输入设备。<br><img src="/images/article/Games104/15/Games104_15_62.png"><span class="image-caption">控制</span><br>来自控制器的信号通过控制系统会转换成游戏可以识别的输入，然后通过事件机制来控制角色。<br><img src="/images/article/Games104/15/Games104_15_63.png"><span class="image-caption">从输入到游戏逻辑</span><br><img src="/images/article/Games104/15/Games104_15_64.png"><span class="image-caption">控制：放大和缩小</span><br><img src="/images/article/Games104/15/Games104_15_65.png"><span class="image-caption">控制：目标协助</span></p><p>同时我们还可以利用控制器的反馈功能来进一步提升玩家的游戏体验。<br><img src="/images/article/Games104/15/Games104_15_66.png"><span class="image-caption">控制：反馈</span><br><img src="/images/article/Games104/15/Games104_15_67.png"><span class="image-caption">控件：上下文识别</span><br><img src="/images/article/Games104/15/Games104_15_68.png"><span class="image-caption">控制：组合键序列</span></p><h3 id="镜头（Camera）"><a href="#镜头（Camera）" class="headerlink" title="镜头（Camera）"></a>镜头（Camera）</h3><p>镜头会直接描述玩家视角中看到的场景和事物。<br><img src="/images/article/Games104/15/Games104_15_69.png"><span class="image-caption">镜头：主观感受</span></p><p>从实现角度来说，我们只要设置好相机的位置和视角就可以直接利用渲染系统来实现镜头的功能。<br><img src="/images/article/Games104/15/Games104_15_70.png"><span class="image-caption">相机基本： POV &amp; FOV</span></p><p>在游戏场景中最常见的情况是相机要绑定在玩家控制的角色身上，随着角色的运动一起运动。同时我们还需要保证相机在运动的过程中不要出现穿墙等各种问题。<br><img src="/images/article/Games104/15/Games104_15_71.png"><span class="image-caption">相机绑定</span><br><img src="/images/article/Games104/15/Games104_15_72.png"><span class="image-caption">相机控制</span></p><p>镜头系统的一大难点在于如何根据角色的状态来调整相机的相关参数，使游戏画面更接近于人眼的真实反映。<br><img src="/images/article/Games104/15/Games104_15_73.png"><span class="image-caption">相机轨道</span></p><p>同时镜头系统也需要考虑各种相机特效的实现，包括镜头抖动、动态模糊等。<br><img src="/images/article/Games104/15/Games104_15_74.png"><span class="image-caption">相机特效</span></p><p>在复杂场景中往往还会有多个相机同时存在，因此我们也需要管理这些相机和相关参数。<br><img src="/images/article/Games104/15/Games104_15_75.png"><span class="image-caption">多个照相机：相机管理器</span></p><p>整个镜头系统对于提升和改善玩家的游戏体验起着至关重要的作用。<br><img src="/images/article/Games104/15/Games104_15_76.png"><span class="image-caption">相机：主观感受</span><br><img src="/images/article/Games104/15/Games104_15_77.png"><span class="image-caption">相机：主观感受2</span></p><p>因此游戏引擎中的镜头系统需要允许用户使用脚本或是可视化脚本来编辑相机的各种属性和参数。<br><img src="/images/article/Games104/15/Games104_15_78.png"><span class="image-caption">相机</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/07/24/GAMES104-NOTES-15.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1u34y1H7jd/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture15_Gameplay%20Complexity%20and%20Building%20Blocks.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 引擎工具链高级概念与应用（十四）</title>
      <link href="/posts/beb0dcfb.html"/>
      <url>/posts/beb0dcfb.html</url>
      
        <content type="html"><![CDATA[<h2 id="工具链大纲"><a href="#工具链大纲" class="headerlink" title="工具链大纲"></a>工具链大纲</h2><p><img src="/images/article/Games104/14/Games104_14_01.png"><span class="image-caption">工具链大纲</span></p><h2 id="游戏制作一览（Glance-of-Game-Production）"><a href="#游戏制作一览（Glance-of-Game-Production）" class="headerlink" title="游戏制作一览（Glance of Game Production）"></a>游戏制作一览（Glance of Game Production）</h2><p>在现代游戏的开发过程中，设计师和艺术家往往需要使用大量的第三方工具来辅助进行游戏角色和场景的建模。<br>同时对于不同类型的游戏，游戏玩法和关卡设计也往往存在着巨大的差别。因此对于工具链来说，它需要实现和不同开发工具的通信也要考虑不同用户的使用需求。<br>除此之外WYSIWYG原则又要求开发者在引擎中的体验必须和实际游戏时完全一致的， 这对工具链的设计提出了更大的挑战。<br><img src="/images/article/Games104/14/Games104_14_02.png"><span class="image-caption">适应不同的游戏类型</span><br><img src="/images/article/Games104/14/Games104_14_03.png"><span class="image-caption">实际生产带来的挑战</span></p><h2 id="世界编辑器"><a href="#世界编辑器" class="headerlink" title="世界编辑器"></a>世界编辑器</h2><p><b>世界编辑器(world editor)</b>是整合了游戏引擎中几乎所有功能的平台。以虚幻引擎为例，虚幻中的世界编辑器界面包括各种不同的面板以服务不同的开发者：<br><img src="/images/article/Games104/14/Games104_14_04.png"><span class="image-caption">世界编辑器</span></p><h3 id="编辑器视口（Editor-Viewport）"><a href="#编辑器视口（Editor-Viewport）" class="headerlink" title="编辑器视口（Editor Viewport）"></a>编辑器视口（Editor Viewport）</h3><p><b>viewport</b>可以说是整个编辑器最重要的窗口，它是连接开发者与所构建的游戏世界的接口。<br>实际上在viewport中所展示的正是游戏世界在运行时的状态，从而方便开发者对游戏内容进行各种调整。<br><img src="/images/article/Games104/14/Games104_14_05.png"><span class="image-caption">编辑器视口</span></p><h3 id="可编辑对象（Editable-Object）"><a href="#可编辑对象（Editable-Object）" class="headerlink" title="可编辑对象（Editable Object）"></a>可编辑对象（Editable Object）</h3><p>在编辑器中所有的对象都是<b>可编辑对象(editable object)</b>，开发者可以根据需要调整这些对象的位置、姿态、材质等属性。<br>因此游戏中所有的元素都必须抽象为这样的可编辑对象。<br><img src="/images/article/Games104/14/Games104_14_06.png"><span class="image-caption">可编辑对象</span></p><p>在同一个游戏场景中可能有成千上万个对象，因此我们需要一些高效的管理工具。在编辑器中往往会使用树状结构或是分层的方式来管理场景中的对象，有时还会根据对象自身的特点设计相应的管理工具。<br><img src="/images/article/Games104/14/Games104_14_07.png"><span class="image-caption">对象的不同视图</span></p><p>当开发者选中某个对象时需要使用<font color="red">schema</font>来获取该对象自身的信息。<br><img src="/images/article/Games104/14/Games104_14_08.png"><span class="image-caption">模式驱动的对象属性编辑</span></p><h3 id="内容浏览器（Content-Browser）"><a href="#内容浏览器（Content-Browser）" class="headerlink" title="内容浏览器（Content Browser）"></a>内容浏览器（Content Browser）</h3><p>在编辑器中还需要实现<b>content browser</b>用来管理开发过程中设计的各种美术、场景资产。在游戏开发过程中很多的资产是可以重复利用的，<br>通过content browser可以方便地查看、检索以及分享现有的资产，从而提升游戏开发的效率<br><img src="/images/article/Games104/14/Games104_14_09.png"><span class="image-caption">内容浏览器</span></p><h3 id="编辑（Editing）"><a href="#编辑（Editing）" class="headerlink" title="编辑（Editing）"></a>编辑（Editing）</h3><p>因此世界编辑器的核心功能是方便开发者去编辑游戏场景中的各种对象。<br><img src="/images/article/Games104/14/Games104_14_10.png"><span class="image-caption">编辑</span></p><p>而在编辑器的实现中，首先也是最重要的功能是如何实现通过鼠标来选取物体。最简单的实现方法是使用渲染系统中的ray casting功能，利用鼠标的位置来发射光线并通过与物体bounding box求交来来选择物体。<br>这种实现的缺陷在于当物体比较复杂时bounding box是不能完全反应物体的几何形状的，此时使用ray casting的效率可能会比较低。另一种实现方法是在渲染流程中添加一个额外的选取帧，<br>为图像上每一个像素赋予一个物体编号，这样使用鼠标进行选取时只需根据物体编号进行查询即可。当然这种实现方式对计算机的硬件提出了更高的要求，同时需要注意在游戏发布时去掉这部分编辑环境下的代码。<br><img src="/images/article/Games104/14/Games104_14_11.png"><span class="image-caption">鼠标选中</span></p><p>选取得到物体后一般还会对物体进行一些几何变换，包括平移、旋转和缩放等，这些操作的具体实现往往还需要根据使用者的习惯来进行设计。<br><img src="/images/article/Games104/14/Games104_14_12.png"><span class="image-caption">对象转换编辑</span></p><p>对地形进行设计时需要结合高度场、地形纹理以及各种装饰件等。<br><img src="/images/article/Games104/14/Games104_14_13.png"><span class="image-caption">地形</span></p><p>对于边界器来说地形设计最常用的工具是<b>高度笔刷(height brush)</b>，如何对设计出的高度场进行平滑需要很多相关的经验。当然很多商业级引擎中还提供了自定义的工具来帮助设计师对效果进行定制。<br><img src="/images/article/Games104/14/Games104_14_14.png"><span class="image-caption">高度笔刷</span></p><p>另一种常用的笔刷是instance brush，它通常用来在设计好的地形上添加各种装饰件。<br><img src="/images/article/Games104/14/Games104_14_15.png"><span class="image-caption">实例笔刷</span></p><p>除此之外编辑器还需要提供各种环境元素的实现。<br><img src="/images/article/Games104/14/Games104_14_16.png"><span class="image-caption">环境</span></p><h3 id="规则系统（Rule-System）"><a href="#规则系统（Rule-System）" class="headerlink" title="规则系统（Rule System）"></a>规则系统（Rule System）</h3><p>游戏中的各种对象需要按照一定的规则来组织起来，因此<b>规则系统(rule system)</b>也是编辑器的重要组件。<br><img src="/images/article/Games104/14/Games104_14_17.png"><span class="image-caption">环境编辑中的规则系统</span></p><p>早期的游戏引擎往往不包括这样的系统，为了保证游戏世界的合理性需要设计师人工调整游戏中的各种对象。<br>而在现代游戏引擎中则需要提供自动化的规则系统，通过程序化的方式来保证游戏中的各种对象遵循相互之间的规则。<br><img src="/images/article/Games104/14/Games104_14_18.png"><span class="image-caption">规则系统</span></p><h2 id="编辑器插件架构（Editor-Plugin-Architecture）"><a href="#编辑器插件架构（Editor-Plugin-Architecture）" class="headerlink" title="编辑器插件架构（Editor Plugin Architecture）"></a>编辑器插件架构（Editor Plugin Architecture）</h2><p>显然整个世界编辑器是一个非常复杂的软件程序，我们很难直接在开发过程中实现所有需要的功能。因此在现代游戏引擎中一般会设计相应的插件系统来帮助用户根据自身的需求来丰富编辑器的功能。<br>实际上不仅是游戏引擎，很多现代软件都使用了类似的策略来允许用户对系统进行定制。<br><img src="/images/article/Games104/14/Games104_14_19.png"><span class="image-caption">商业软件中的插件模块的示例</span></p><p>而对于游戏引擎而言，插件系统需要考虑的一个问题是如何对插件种类进行划分。我们可以按照游戏对象的种类(网格、粒子、动画等)对插件进行分类，也可以根据对象的内容(NPC、建筑、人群等)进行分类。<br>因此现代游戏引擎的编辑器往往需要支持这种矩阵式的分类方法，允许用户根据喜好来选择和定制插件。<br><img src="/images/article/Games104/14/Games104_14_20.png"><span class="image-caption">系统和对象之间的交叉矩阵</span></p><p>在对插件系统进行整合时还需要考虑不同插件之间的版本问题。 不同的版本之间可以按照<b>覆盖(covered)</b>或是<b>分布式(distributed)</b>的方式进行协作。<br><img src="/images/article/Games104/14/Games104_14_21.png"><span class="image-caption">多个插件的组合</span></p><p>除了上面提到的两种模式外，对于几何数据往往还会使用<b>流水线(pipeline)</b>的模式将几何体的操作进行分解；<br>而对于更加复杂的对象有时还会使用<b>洋葱圈(onion ring)</b>的模式同时和其他的插件进行协作。<br><img src="/images/article/Games104/14/Games104_14_22.png"><span class="image-caption">多个插件的组合2</span></p><p>随着编辑器以及各种插件之间版本的迭代，插件系统一般还需要考虑版本控制的问题。<br><img src="/images/article/Games104/14/Games104_14_23.png"><span class="image-caption">版本控制</span></p><h2 id="设计叙事工具（Design-Narrative-Tools）"><a href="#设计叙事工具（Design-Narrative-Tools）" class="headerlink" title="设计叙事工具（Design Narrative Tools）"></a>设计叙事工具（Design Narrative Tools）</h2><p>除了游戏资产的设计外，<b>叙事(story telling)</b>在整个游戏开发流程中同样是非常重要的一环。<br>叙事可以看做一个线性的过程，相关的游戏资产需要在一个时间轴上按照顺序进行调度。<br><img src="/images/article/Games104/14/Games104_14_24.png"><span class="image-caption">游戏引擎中的讲故事</span></p><p>在虚幻引擎中使用了sequencer来跟踪游戏对象及其属性在时间轴上的变化。当我们把不同的对象利用sequencer在时间轴上组织起来就实现了简单的叙事。<br><img src="/images/article/Games104/14/Games104_14_25.png"><span class="image-caption">音序器</span></p><p>要使用sequencer首先需要选中对象然后把sequencer绑定到对象上，然后选择相关的属性并利用关键帧设置这些属性的变化，最后利用插值就完成了叙事。<br><img src="/images/article/Games104/14/Games104_14_26.png"><span class="image-caption">将对象绑定到轨迹</span><br><img src="/images/article/Games104/14/Games104_14_27.png"><span class="image-caption">将对象属性绑定到属性轨迹</span><br><img src="/images/article/Games104/14/Games104_14_28.png"><span class="image-caption">设置关键帧</span><br><img src="/images/article/Games104/14/Games104_14_29.png"><span class="image-caption">设置关键帧2</span><br><img src="/images/article/Games104/14/Games104_14_30.png"><span class="image-caption">沿着关键帧插入属性</span></p><h2 id="反射和游戏逻辑（Reflection-and-Gameplay）"><a href="#反射和游戏逻辑（Reflection-and-Gameplay）" class="headerlink" title="反射和游戏逻辑（Reflection and Gameplay）"></a>反射和游戏逻辑（Reflection and Gameplay）</h2><p><b>反射(reflection)</b>是sequencer乃至整个游戏引擎编程中都非常重要的技术，通过反射我们可以让游戏引擎在运行阶段获取操作对象具有的各种属性。<br>实际上对于游戏开发流程而言，游戏引擎的开发者很难实现预判用户的需求。因此反射对于现代游戏引擎而言几乎是一个必备的工具。<br><img src="/images/article/Games104/14/Games104_14_31.png"><span class="image-caption">反射和游戏逻辑</span></p><p>早期的游戏引擎是不基于反射技术来实现的，这导致开发者在进行编程时必须手动为游戏对象添加所有需要的属性和数据，使得工具链的开发很难与游戏开发进行匹配。<br><img src="/images/article/Games104/14/Games104_14_32.png"><span class="image-caption">为获取更多特性而采用的硬代码方法</span><br><img src="/images/article/Games104/14/Games104_14_33.png"><span class="image-caption">为获取更多特性而采用的硬代码方法2</span></p><p>反射是现代高级语言中引入的一个非常实用的概念。通过反射，系统可以获知每个新实现的类提供的接口。<br><img src="/images/article/Games104/14/Games104_14_34.png"><span class="image-caption">一个常见的解决方案 - 反射</span></p><p>反射可以理解为沟通代码和工具之间的一座桥梁。<br><img src="/images/article/Games104/14/Games104_14_35.png"><span class="image-caption">反射建立了代码和工具之间的桥梁</span></p><p>在C++中默认是不支持反射的，不过可以基于编译器来实现反射的功能。<br><img src="/images/article/Games104/14/Games104_14_36.png"><span class="image-caption">如何在C++中实现反射</span><br><img src="/images/article/Games104/14/Games104_14_37.png"><span class="image-caption">如何从代码中获取类型信息</span><br><img src="/images/article/Games104/14/Games104_14_38.png"><span class="image-caption">如何从代码中获取类型信息2</span></p><p>在本课程提供的小引擎中使用了clang编译器来实现反射。<br><img src="/images/article/Games104/14/Games104_14_39.png"><span class="image-caption">为什么Piccolo使用Clang</span><br><img src="/images/article/Games104/14/Games104_14_40.png"><span class="image-caption">从AST生成架构</span><br><img src="/images/article/Games104/14/Games104_14_41.png"><span class="image-caption">反射范围的精确控制</span><br><img src="/images/article/Games104/14/Games104_14_42.png"><span class="image-caption">使用Marco来添加反射控件</span><br><img src="/images/article/Games104/14/Games104_14_43.png"><span class="image-caption">反射访问器</span></p><p>除此之外，在小引擎中还使用了<b>代码渲染(code rendering)</b>的技术来自动生成相关的代码。<br><img src="/images/article/Games104/14/Games104_14_44.png"><span class="image-caption">代码渲染</span><br><img src="/images/article/Games104/14/Games104_14_45.png"><span class="image-caption">代码渲染2</span><br><img src="/images/article/Games104/14/Games104_14_46.png"><span class="image-caption">代码渲染 - Mustache</span></p><h2 id="协同编辑（Collaborative-Editing）"><a href="#协同编辑（Collaborative-Editing）" class="headerlink" title="协同编辑（Collaborative Editing）"></a>协同编辑（Collaborative Editing）</h2><p><b>协同编辑(collaborative editing)</b>是现代游戏在开发过程中所需要面对的挑战。<br>在复杂的游戏场景中往往需要大量的开发工作者进行协作，如何保证协作开发中各种资源的合理调度并避免相互之间的冲突是一个相等复杂的问题。<br><img src="/images/article/Games104/14/Games104_14_47.png"><span class="image-caption">大型项目的瓶颈</span><br><img src="/images/article/Games104/14/Games104_14_48.png"><span class="image-caption">合并冲突是最大的问题</span></p><p>避免冲突最简单直接的方法是对整个任务按照内容进行分解，然后安排不同的开发者独立地进行开发。<br>但这种管理方式的问题在于有时很难进行合理的划分，而且在很多情况下不同的任务之间存在相互依赖。<br><img src="/images/article/Games104/14/Games104_14_49.png"><span class="image-caption">如何减少冲突</span><br><img src="/images/article/Games104/14/Games104_14_50.png"><span class="image-caption">拆分资产-分层的世界</span><br><img src="/images/article/Games104/14/Games104_14_51.png"><span class="image-caption">拆分资产-分层的世界2</span></p><p>另一种常见的处理方法是直接对任务进行分解，但这种处理方法的效果同样不够理想，容易产生场景的割裂。<br><img src="/images/article/Games104/14/Games104_14_52.png"><span class="image-caption">拆分资产-分割世界</span><br><img src="/images/article/Games104/14/Games104_14_53.png"><span class="image-caption">拆分资产-分割世界2</span></p><p>在虚幻引擎中提出了OFPA的策略来生成大量的文件来进行管理。<br><img src="/images/article/Games104/14/Games104_14_54.png"><span class="image-caption">每个参与者一个文件</span><br><img src="/images/article/Games104/14/Games104_14_55.png"><span class="image-caption">一种特殊的拆分资产方法 - OFPA</span></p><p>实际上协同编辑的终极目标是允许不同的开发者同时在同一个系统上进行编辑。尽管这个问题仍然非常复杂，但它已经成为了现代大型软件系统的研究热点。<br><img src="/images/article/Games104/14/Games104_14_56.png"><span class="image-caption">在一个场景中进行坐标编辑</span><br><img src="/images/article/Games104/14/Games104_14_57.png"><span class="image-caption">如何同步我的操作</span><br><img src="/images/article/Games104/14/Games104_14_58.png"><span class="image-caption">这是一个非常大的挑战</span><br><img src="/images/article/Games104/14/Games104_14_59.png"><span class="image-caption">两个用户不能同时编辑同一个实例</span><br><img src="/images/article/Games104/14/Games104_14_60.png"><span class="image-caption">两个用户不能同时编辑同一个资产</span><br><img src="/images/article/Games104/14/Games104_14_61.png"><span class="image-caption">但锁并不是万能的</span><br><img src="/images/article/Games104/14/Games104_14_62.png"><span class="image-caption">如何彻底解决这些问题</span><br><img src="/images/article/Games104/14/Games104_14_63.png"><span class="image-caption">传统的工作流 VS 协作编辑工作流</span><br><img src="/images/article/Games104/14/Games104_14_64.png"><span class="image-caption">服务器是最重要的角色</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/07/08/GAMES104-NOTES-14.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1QN4y1u78P/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture14_Tool%20Chains_Applications%20&amp;%20Advanced%20Topic.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 引擎工具链基础（十三）</title>
      <link href="/posts/9696e8dc.html"/>
      <url>/posts/9696e8dc.html</url>
      
        <content type="html"><![CDATA[<h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p><b>工具链(tool chain)</b>是沟通游戏引擎用户以及更底层run time(渲染系统、物理引擎、网络通信等)之间的桥梁。<br>对于商业级游戏引擎来说，工具链的工程量往往要比run time大得多。<br><img src="/images/article/Games104/13/Games104_13_01.png"><span class="image-caption">用户与引擎运行时之间的图层</span></p><p>另一方面，工具链也是连接游戏引擎以及第三方DCC工具的核心。在现代游戏工业中需要使用到大量的第三方工具如MAYA、3DS MAX等，<br>在进行游戏开发时需要通过工具链将这些第三方DCC的资源加载到游戏引擎中。<br><img src="/images/article/Games104/13/Games104_13_02.png"><span class="image-caption">DCC工具和游戏引擎之间的桥梁</span></p><p>从更高级的视角来看，工具链的本质是调和不同背景和思维方式用户的一套平台。对于开发者，工具链需要方便开发者管理游戏中大量资源和对象；<br>对于设计师，工具链需要帮助他们快速实现不同的游戏逻辑；而对于艺术家，工具链则需要帮助他们表达不同的创意。工具链需要服务这些拥有不同知识背景的用户以便更好地完成游戏开发的过程。<br><img src="/images/article/Games104/13/Games104_13_03.png"><span class="image-caption">让不同背景和思维方式的用户一起工作</span></p><h2 id="复杂的工具"><a href="#复杂的工具" class="headerlink" title="复杂的工具"></a>复杂的工具</h2><h3 id="图像用户接口（GUI）"><a href="#图像用户接口（GUI）" class="headerlink" title="图像用户接口（GUI）"></a>图像用户接口（GUI）</h3><p>GUI是工具链与用户直接进行交互的接口，在现代软件工程中GUI是人机交互的必要模块。<br><img src="/images/article/Games104/13/Games104_13_04.png"><span class="image-caption">图像用户接口</span></p><p>目前GUI主要有两大类实现方式，其一是<b>immediate mode</b>。在immediate mode中用户的操作会直接调用GUI模块进行绘制，让用户立刻看到操作后的效果。<br>这种模式的特点是它非常直观而且易于实现，但它的效率和可拓展性往往不尽如人意。<br><img src="/images/article/Games104/13/Games104_13_05.png"><span class="image-caption">即时模式</span><br><img src="/images/article/Games104/13/Games104_13_06.png"><span class="image-caption">即时模式2</span></p><p>在现代游戏引擎中更常用的GUI实现方式是<b>retained mode</b>。在retained mode中用户的操作不会直接进行绘制，而是会把用户提交的指令先存储到一个buffer中，然后在引擎的绘制系统中再进行绘制。<br>这样做的好处是可以极大地提高系统的运行效率和可拓展性，当然代价是这种方式的实现要更加复杂。<br><img src="/images/article/Games104/13/Games104_13_07.png"><span class="image-caption">保留模式</span><br><img src="/images/article/Games104/13/Games104_13_08.png"><span class="image-caption">保留模式2</span></p><h3 id="设计模式（Design-Pattern）"><a href="#设计模式（Design-Pattern）" class="headerlink" title="设计模式（Design Pattern）"></a>设计模式（Design Pattern）</h3><p>在设计GUI系统时需要<b>设计模式(design pattern)</b>相关的知识，这里简要介绍一些在GUI设计中常用的设计模式。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC是经典的人机交互设计模式。MVC的思想是把<b>用户(user)</b>、<b>视图(view)</b>和<b>模型(model)</b>进行分离，<br>当用户想要修改视图时只能通过控制器(controller)进行操作并由控制器转发给模型，从而避免用户直接操作数据产生各种冲突。<br><img src="/images/article/Games104/13/Games104_13_09.png"><span class="image-caption">MVC模式</span></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP可以看做是对MVC的演变。MVP模式对视图和模型进行了更彻底的分离，视图只负责对数据进行展示而模型只负责对数据进行处理，<br>它们之间的通信则通过<b>展示者(presenter)</b>来实现。当用户想要修改数据时，用户的请求会通过视图提交给展示者，然后再由它转发给模型进行处理。<br><img src="/images/article/Games104/13/Games104_13_10.png"><span class="image-caption">MVP模式</span></p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM是目前游戏引擎中大量使用的UI设计模式，在MVVM中视图和模型的中间层称为<b>ViewModel</b>。在MVVM模式中，<br>视图只包含简单的UI状态数据，这些数据通过ViewModel解析成合适的数据结构再提交给模型进行处理<br><img src="/images/article/Games104/13/Games104_13_11.png"><span class="image-caption">MVVM模式</span><br><img src="/images/article/Games104/13/Games104_13_12.png"><span class="image-caption">MVVM模式2</span><br><img src="/images/article/Games104/13/Games104_13_13.png"><span class="image-caption">MVVM模式3</span></p><h3 id="加载和保存（Load-and-Save）"><a href="#加载和保存（Load-and-Save）" class="headerlink" title="加载和保存（Load and Save）"></a>加载和保存（Load and Save）</h3><p>加载和保存各种不同类型的数据是工具链的核心功能。在保存数据时需要使用<b>序列化(serialization)</b>的技术来将各种不同的数据结构或是GO转换成二进制格式，<br>而当需要加载数据时则需要通过<b>反序列化(deserialization)</b>从二进制格式恢复原始的数据。<br><img src="/images/article/Games104/13/Games104_13_14.png"><span class="image-caption">序列化和反序列化</span></p><p>最简单的序列化方法是把数据打包成text文件。text文件虽然简单，但实际上目前很多系统仍然是使用text文件进行信息的传输。目前常用的text文件格式包括json、yaml、xml等。<br><img src="/images/article/Games104/13/Games104_13_15.png"><span class="image-caption">Text文件</span></p><p>text文件可以方便开发人员理解存储数据的内容，但计算机对于文本的读取和处理往往是比较低效的。当需要序列化的数据不断增长时就需要使用更加高效的存储格式，<br>通常情况下我们会使用二进制格式来对数据进行存储。<br><img src="/images/article/Games104/13/Games104_13_16.png"><span class="image-caption">Binary文件</span></p><p>和text文件相比，二进制文件往往只占用非常小的存储空间，而且对数据进行读取也要高效得多。因此在现代游戏引擎中一般都会使用二进制文件来进行数据的保存和加载。<br><img src="/images/article/Games104/13/Games104_13_17.png"><span class="image-caption">Binary和Text对比</span></p><h3 id="资源引用（Asset-Reference）"><a href="#资源引用（Asset-Reference）" class="headerlink" title="资源引用（Asset Reference）"></a>资源引用（Asset Reference）</h3><p>在很多情况下游戏的资产是重复的，此时为每一个实例单独进行保存就会浪费系统的资源。<br><img src="/images/article/Games104/13/Games104_13_18.png"><span class="image-caption">资产数据重复</span></p><p>因此，在现代游戏引擎中会使用<b>资产引用(asset reference)</b>的方式来管理各种重复的资产。实际上资产的引用和去重是游戏引擎工具链最重要的底层逻辑之一。<br><img src="/images/article/Games104/13/Games104_13_19.png"><span class="image-caption">资产引用</span></p><p>在游戏开发过程中工具链往往还需要提供对GO进行修改，从而实现不同的艺术效果。<br><img src="/images/article/Games104/13/Games104_13_20.png"><span class="image-caption">场景中的对象实例</span><br><img src="/images/article/Games104/13/Games104_13_21.png"><span class="image-caption">对象实例差异</span></p><p>在调整和修改数据时直接进行复制很可能会破坏GO之间的关联而且容易造成数据的冗余，因此在现代游戏引擎中对于数据引入了<b>继承(inheritance)</b>的概念。<br>数据之间的继承可以很方便地派生出更多更复杂的游戏对象，从而方便设计师和艺术家实现不同的效果。<br><img src="/images/article/Games104/13/Games104_13_22.png"><span class="image-caption">通过复制生成差异</span><br><img src="/images/article/Games104/13/Games104_13_23.png"><span class="image-caption">通过数据继承生成方差</span></p><h2 id="资产加载"><a href="#资产加载" class="headerlink" title="资产加载"></a>资产加载</h2><h3 id="解析（Parsing）"><a href="#解析（Parsing）" class="headerlink" title="解析（Parsing）"></a>解析（Parsing）</h3><p>在上一节我们主要是考虑如何对数据进行保存，而游戏引擎中工具链的一大难点在于如何加载不同的资产，即反序列化的过程。<br>反序列化的过程可以理解为对文件进行<b>解析(parsing)</b>，文件中的不同字段往往有着不同的关键字以及域。我们需要对整个文件进行扫描来获得整个文件的结构。<br><img src="/images/article/Games104/13/Games104_13_24.png"><span class="image-caption">解析资产文件</span></p><p>对文件完成解析后可以得到一棵由&lt; key-value &gt;对组成的树来表达不同类型的数据。<br><img src="/images/article/Games104/13/Games104_13_25.png"><span class="image-caption">构建键值对树</span></p><p>实际上这样的过程与对文本文件的解析过程是非常类似的。<br><img src="/images/article/Games104/13/Games104_13_26.png"><span class="image-caption">Binary VS Text</span></p><h3 id="字节序（Endianness）"><a href="#字节序（Endianness）" class="headerlink" title="字节序（Endianness）"></a>字节序（Endianness）</h3><p>对二进制文件进行反序列化和解析时需要额外注意endianness的问题。在不同的硬件和操作系统上同样的二进制文件可能会被解析为不同的数据，这对于跨平台的应用需要额外注意。<br><img src="/images/article/Games104/13/Games104_13_27.png"><span class="image-caption">字节序</span></p><h3 id="版本兼容性（Version-Compatibility）"><a href="#版本兼容性（Version-Compatibility）" class="headerlink" title="版本兼容性（Version Compatibility）"></a>版本兼容性（Version Compatibility）</h3><p>在工具链的反序列化过程中还需要考虑资产的兼容性问题。游戏的开发周期往往是比较长的，在这一过程中可能会不可避免地出现引擎以及各种工具的升级。<br>而我们希望新版本可以对旧版本中设计好的资源进行兼容，从而避免重复的劳动。<br><img src="/images/article/Games104/13/Games104_13_28.png"><span class="image-caption">资源的版本兼容性</span></p><p>在版本更迭中最常见的情况是数据的域发生了修改，新版本的数据定义可能会添加或删去老版本定义的域。<br><img src="/images/article/Games104/13/Games104_13_29.png"><span class="image-caption">添加或删除字段</span></p><p>为了处理这种问题可以手动为数据添加版本号，在加载数据时根据版本号来控制加载过程。<br><img src="/images/article/Games104/13/Games104_13_30.png"><span class="image-caption">通过版本硬代码来解决兼容性问题</span></p><p>更好的处理方法是使用guid来进行管理。如Google就提出了使用protocol来为每一个域赋予一个uid，在进行反序列化时只需要对域的uid进行比较即可。<br><img src="/images/article/Games104/13/Games104_13_31.png"><span class="image-caption">通过字段UID解决兼容性问题</span></p><h2 id="如何制作高鲁棒性的工具"><a href="#如何制作高鲁棒性的工具" class="headerlink" title="如何制作高鲁棒性的工具"></a>如何制作高鲁棒性的工具</h2><p>在游戏引擎中工具链对于鲁棒性有非常高的要求，一旦游戏引擎的工具链出现问题会对整个游戏开发流程产生巨大的影响。<br>鲁棒性最基本的要求是允许程序从崩溃中进行恢复，从而还原初始的开发状态。为了实现这样的功能我们需要将用户所有的行为抽象为原子化的<b>命令(command)</b>，通过命令的序列来表示整个开发的过程。<br><img src="/images/article/Games104/13/Games104_13_32.png"><span class="image-caption">命令</span></p><p>对command类进行抽象时需要为每一个command实例赋予单调的UID从而保证顺序的正确性，<br>同时每一个command定义都需要实现<code>Invoke()</code>和<code>Revoke()</code>方法表示执行命令以及恢复到执行命令前的状态。<br>除此之外还需要实现<code>Serialize()</code>和<code>Deserialize()</code>方法来控制生成的数据序列化以及反序列化过程。<br><img src="/images/article/Games104/13/Games104_13_33.png"><span class="image-caption">命令定义</span><br><img src="/images/article/Games104/13/Games104_13_34.png"><span class="image-caption">命令UID</span><br><img src="/images/article/Games104/13/Games104_13_35.png"><span class="image-caption">命令序列号和反序列化</span></p><p>整个command系统可以划分为三种不同类型的指令，包括添加数据、删除数据以及更新数据。实际上几乎所有的command都可以视为这三种基本指令的组合。<br><img src="/images/article/Games104/13/Games104_13_36.png"><span class="image-caption">三个关键命令</span></p><h2 id="如何制作工具链"><a href="#如何制作工具链" class="headerlink" title="如何制作工具链"></a>如何制作工具链</h2><p>现代游戏引擎的工具链往往包含成百上千个不同的工具程序，这些程序会面向不同背景的开发人员并实现相应的功能。<br><img src="/images/article/Games104/13/Games104_13_37.png"><span class="image-caption">针对不同用户的各种工具</span></p><p>而对于工具链来说，一个基本要求是要保证不同工具之间的沟通以及整个系统的可拓展性。<br>我们不希望每个工具程序都使用单独的一套数据定义方式，这会导致整个工具链系统过于庞大而且难以进行维护。<br><img src="/images/article/Games104/13/Games104_13_38.png"><span class="image-caption">单独开发所有工具？</span></p><p>因此我们需要去寻找不同工具中的一些共性，并把这些共同的数据封装为基本的单元。利用对这些基本单元的组合来描述更加复杂的数据结构。<br><img src="/images/article/Games104/13/Games104_13_39.png"><span class="image-caption">查找公用块</span></p><h3 id="提要（Schema）"><a href="#提要（Schema）" class="headerlink" title="提要（Schema）"></a>提要（Schema）</h3><p><b>schema</b>是一种对数据进行描述的结构，它描述了具体的数据结构是由哪些基本单元构成的。<br>在工具链系统中所有流动的数据都要通过schema来进行描述，从而保证不同的程序都可以对数据进行解读。<br><img src="/images/article/Games104/13/Games104_13_40.png"><span class="image-caption">描述结构</span><br><img src="/images/article/Games104/13/Games104_13_41.png"><span class="image-caption">基本要素</span></p><p>在schema的实现中一般也需要实现继承和引用功能来方便定义新的数据类型。<br><img src="/images/article/Games104/13/Games104_13_42.png"><span class="image-caption">继承</span><br><img src="/images/article/Games104/13/Games104_13_43.png"><span class="image-caption">数据引用</span></p><p>不难发现schema与高级语言有着很多相似之处，实际上schema确实可以直接使用高级语言来进行定义。<br>目前游戏引擎中的schema系统主要有两种实现方式，其一是单独实现schema的定义，而另一种则是使用高级语言进行定义。<br><img src="/images/article/Games104/13/Games104_13_44.png"><span class="image-caption">两种实现方式</span></p><p>这两种实现方式各有各的优缺点，它们的特点可以总结如下：<br><img src="/images/article/Games104/13/Games104_13_45.png"><span class="image-caption">两种实现方式优缺点</span></p><h3 id="引擎数据的三个视图（Three-Views-for-Engine-Data）"><a href="#引擎数据的三个视图（Three-Views-for-Engine-Data）" class="headerlink" title="引擎数据的三个视图（Three Views for Engine Data）"></a>引擎数据的三个视图（Three Views for Engine Data）</h3><p>基于schema系统我们可以发现同样的数据在游戏引擎的不同系统和工具中可能会有不同的表现形式。<br><img src="/images/article/Games104/13/Games104_13_46.png"><span class="image-caption">引擎数据的三个视图</span></p><p>在runtime中一般会以运行和计算效率为第一要务。<br><img src="/images/article/Games104/13/Games104_13_47.png"><span class="image-caption">运行时视图</span></p><p>而在进行存储时则要游戏考虑数据的读写速度和空间需求。<br><img src="/images/article/Games104/13/Games104_13_48.png"><span class="image-caption">储藏视图</span></p><p>而在面向开发者的工具程序中需要根据不同使用者的背景和需求来设计不同的数据表现形式。<br><img src="/images/article/Games104/13/Games104_13_49.png"><span class="image-caption">工具视图</span><br><img src="/images/article/Games104/13/Games104_13_50.png"><span class="image-caption">工具视图 - 容易理解的</span><br><img src="/images/article/Games104/13/Games104_13_51.png"><span class="image-caption">工具视图 - 各种编辑器模式</span></p><h2 id="所见即所得"><a href="#所见即所得" class="headerlink" title="所见即所得"></a>所见即所得</h2><p><b>所见即所得(what you see is what you get, WYSIWYG)</b>是我们设计构建整个工具链系统的核心精神，<br>它的目标是保证设计师和艺术家在工具链中的设计结果能完美地重现在实际的游戏场景中。 在早期的游戏引擎中一般会设计一个独立工具层用来辅助开发者进行设计，<br>但这种设计方式往往会违背WYSIWYG原则因此在现代游戏引擎中基本已经被弃用。<br><img src="/images/article/Games104/13/Games104_13_52.png"><span class="image-caption">独立的工具</span></p><p>目前商用级游戏引擎一般会把工具层设计在整个游戏引擎的最上层，换句话说工具层会调用底层的模块来辅助游戏开发者的工作。<br>这种设计方式的好处是可以严格遵循WYSIWYG原则，提高开发效率。当然其缺陷在于此时的工具层依赖于整个引擎的实现，当引擎崩溃时工具链也会直接崩溃。<br><img src="/images/article/Games104/13/Games104_13_53.png"><span class="image-caption">游戏中的工具</span></p><h3 id="在编辑器中播放（Play-in-Editor）"><a href="#在编辑器中播放（Play-in-Editor）" class="headerlink" title="在编辑器中播放（Play in Editor）"></a>在编辑器中播放（Play in Editor）</h3><p>基于in game的设计模式就可以实现在工具层中进行游戏，当然这也要求我们在工具层上再设置一个编辑器来编辑游戏的功能<br><img src="/images/article/Games104/13/Games104_13_54.png"><span class="image-caption">游戏中的工具 - 编辑模式</span></p><p>在编辑器中进行游玩时同样有两种实现方式，包括直接在编辑器中进行游戏或是基于编辑器当前的状态生成一个新的游戏窗口进行游戏。<br><img src="/images/article/Games104/13/Games104_13_55.png"><span class="image-caption">PIE</span></p><p>直接在编辑器中进行游戏可以无缝地对当前游戏场景进行编辑，但需要注意在进行编辑时不要污染游戏场景中的数据。<br><img src="/images/article/Games104/13/Games104_13_56.png"><span class="image-caption">PIE模式-在编辑器世界中播放</span></p><p>另一种实现方式是新建一个沙盒来重现当前的游戏环境，整个游戏过程都在沙盒中进行。<br>这种设计方式可以保证编辑器中的数据与实际游戏中的数据保持相互独立，避免出现数据污染的情况。在大型游戏引擎的开发中一般会使用这种模式。<br><img src="/images/article/Games104/13/Games104_13_57.png"><span class="image-caption">PIE模式-在PIE世界中播放</span></p><h2 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h2><p>在工具链中我们往往还需要允许用户根据自身的需要自行设计并开发新的工具，也即<b>插件(plugin)</b>。<br>实际上这些插件定义了整个游戏引擎的可拓展性，在现代游戏开发过程中需要使用到各种各样的插件以实现不同的功能。<br><img src="/images/article/Games104/13/Games104_13_58.png"><span class="image-caption">可拓展性</span><br><img src="/images/article/Games104/13/Games104_13_59.png"><span class="image-caption">插件展示</span></p><p>目前市面上的商业级游戏引擎都对插件有很好的支持，方便用户自行开发和分享各种插件。<br><img src="/images/article/Games104/13/Games104_13_60.png"><span class="image-caption">插件框架</span><br><img src="/images/article/Games104/13/Games104_13_61.png"><span class="image-caption">插件框架2</span><br><img src="/images/article/Games104/13/Games104_13_62.png"><span class="image-caption">插件-添加一个工具栏按钮</span><br><img src="/images/article/Games104/13/Games104_13_63.png"><span class="image-caption">插件-在Unreal5中添加一个插件菜单</span><br><img src="/images/article/Games104/13/Games104_13_64.png"><span class="image-caption">插件概要</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/07/06/GAMES104-NOTES-13.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV11T411G7qB/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/Lecture%2013%EF%BC%9ATool%20Chain.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎中的粒子和声效系统（十二）</title>
      <link href="/posts/277d96a5.html"/>
      <url>/posts/277d96a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="游戏引擎中的粒子和声效系统"><a href="#游戏引擎中的粒子和声效系统" class="headerlink" title="游戏引擎中的粒子和声效系统"></a>游戏引擎中的粒子和声效系统</h1><h2 id="粒子系统（Particle-System）"><a href="#粒子系统（Particle-System）" class="headerlink" title="粒子系统（Particle System）"></a>粒子系统（Particle System）</h2><p><b>粒子系统(particle system)</b>是现代游戏中非常重要的组成部分，游戏中大量的特效都是基于粒子系统来实现的。<br><img src="/images/article/Games104/12/Games104_12_01.png"><span class="image-caption">粒子系统</span></p><h3 id="粒子基础（Fundamentals）"><a href="#粒子基础（Fundamentals）" class="headerlink" title="粒子基础（Fundamentals）"></a>粒子基础（Fundamentals）</h3><p>实际上粒子系统来自于电影行业对于视觉特效的追求，它最早可以追溯到1982年的电影《星际迷航2：可汗之怒》。<br><img src="/images/article/Games104/12/Games104_12_02.png"><span class="image-caption">粒子系统的历史</span></p><p>所谓的粒子是指具有一些物理信息的物体，常见的物理量包括位置、速度、大小、颜色等。<br><img src="/images/article/Games104/12/Games104_12_03.png"><span class="image-caption">粒子</span></p><p>同时粒子还需要考虑自身的<b>生命周期(life cycle)</b>，当粒子的生命周期结束后需要被系统回收。<br><img src="/images/article/Games104/12/Games104_12_04.png"><span class="image-caption">粒子生命周期</span></p><h4 id="粒子发射器（Particle-Emitter）"><a href="#粒子发射器（Particle-Emitter）" class="headerlink" title="粒子发射器（Particle Emitter）"></a>粒子发射器（Particle Emitter）</h4><p>每一种不同的粒子都是由相应的<b>粒子发射器(particle emitter)</b>生成的。每一种粒子发射器需要指定自身的生成规则同时为粒子赋予相应的仿真逻辑。<br><img src="/images/article/Games104/12/Games104_12_05.png"><span class="image-caption">粒子发射器</span></p><p>在一个粒子系统中往往会同时具有多个不同的例子发射器进行工作，它们之间相互配合就实现了丰富的粒子效果。<br><img src="/images/article/Games104/12/Games104_12_06.png"><span class="image-caption">粒子系统</span></p><h4 id="粒子生成（Particle-Spawn）"><a href="#粒子生成（Particle-Spawn）" class="headerlink" title="粒子生成（Particle Spawn）"></a>粒子生成（Particle Spawn）</h4><p>粒子系统在生成粒子时可以根据需求使用不同的生成策略。比较简单的生成方式是从单点生成粒子，而在现代粒子生成器中则可以从某个区域甚至从物体的网格来生成粒子。<br>同时粒子生成器也可以根据需求只产生一次性的粒子，或是源源不断地生成新的粒子。<br><img src="/images/article/Games104/12/Games104_12_07.png"><span class="image-caption">粒子生成位置</span><br><img src="/images/article/Games104/12/Games104_12_08.png"><span class="image-caption">粒子生成模式</span></p><h4 id="模拟（Simulation）"><a href="#模拟（Simulation）" class="headerlink" title="模拟（Simulation）"></a>模拟（Simulation）</h4><p>完成粒子的生成后就可以利用质点运动学的相关方法对粒子进行仿真。由于粒子系统一般不需要严格地遵守物理规律，<br>在实践中往往只会使用最简单的前向积分来实现对粒子状态进行更新。<br><img src="/images/article/Games104/12/Games104_12_09.png"><span class="image-caption">模拟</span><br><img src="/images/article/Games104/12/Games104_12_10.png"><span class="image-caption">模拟2</span></p><h4 id="粒子类型（Particle-Type）"><a href="#粒子类型（Particle-Type）" class="headerlink" title="粒子类型（Particle Type）"></a>粒子类型（Particle Type）</h4><p>早期的粒子系统会假定粒子都位于某个平面上进行运动，这种方法称为billboard particle。当观察者的视角发生变化时，<br>billboard会随着观察者的视角一起变化从而保证它一直位于观察者的正前方。<br><img src="/images/article/Games104/12/Games104_12_11.png"><span class="image-caption">粒子面片</span></p><p>随着游戏技术的进步，后来还出现了mesh particle这种带有几何信息的粒子。这种形式的粒子可以用来模拟岩石、碎屑等带有明显几何信息的颗粒。<br><img src="/images/article/Games104/12/Games104_12_12.png"><span class="image-caption">网格粒子</span></p><p>在很多游戏中还使用了ribbon particle这种带状的粒子用来模拟各种拖动的效果，比如说游戏中各种武器的特效一般都是使用这种技术来制作的。<br>在使用ribbon particle时一般还会结合Catmull曲线来形成光滑连贯的特效。<br><img src="/images/article/Games104/12/Games104_12_13.png"><span class="image-caption">带状粒子</span><br><img src="/images/article/Games104/12/Games104_12_14.png"><span class="image-caption">带状粒子2</span><br><img src="/images/article/Games104/12/Games104_12_15.png"><span class="image-caption">带状粒子3</span><br><img src="/images/article/Games104/12/Games104_12_16.png"><span class="image-caption">带状粒子4</span></p><h3 id="粒子渲染（Particle-System-Rendering）"><a href="#粒子渲染（Particle-System-Rendering）" class="headerlink" title="粒子渲染（Particle System Rendering）"></a>粒子渲染（Particle System Rendering）</h3><h4 id="粒子排序（Particle-Sort）"><a href="#粒子排序（Particle-Sort）" class="headerlink" title="粒子排序（Particle Sort）"></a>粒子排序（Particle Sort）</h4><p>粒子在进行渲染时的一大难点在于如何进行排序。按照alpha混合的理论，我们需要从最远端开始由远及近地对场景中的物体进行绘制。<br><img src="/images/article/Games104/12/Games104_12_17.png"><span class="image-caption">alpha混合</span></p><p>由于场景中往往同时存在巨量的粒子，对这些粒子进行排序往往会耗费大量的计算资源。目前对于粒子进行排序主要有两种做法：<br>其一是全局排序即无考虑发射器的信息单纯对所有的粒子进行排序，这种做法可以获得正确的结果但需要非常多的计算资源；<br>另一种做法是按照发射器进行排序，这种方法可以极大地减少计算资源但可能会出现错误的排序结果。<br><img src="/images/article/Games104/12/Games104_12_18.png"><span class="image-caption">alpha混合</span></p><h4 id="分辨率（Resolution）"><a href="#分辨率（Resolution）" class="headerlink" title="分辨率（Resolution）"></a>分辨率（Resolution）</h4><p>当粒子充满场景时非透明的粒子会导致我们必须在同一像素上进行反复的绘制，这往往会导致帧数极大的下降。<br><img src="/images/article/Games104/12/Games104_12_19.png"><span class="image-caption">全分辨率粒子</span></p><p>因此在对粒子进行渲染时还会结合降采样的技术来减少需要进行绘制的像素数。<br>把降采样后的图像和非透明的粒子按照透明度混合后在通过上采样来恢复原始分辨率。<br><img src="/images/article/Games104/12/Games104_12_20.png"><span class="image-caption">低分辨率粒子</span></p><h3 id="GPU粒子"><a href="#GPU粒子" class="headerlink" title="GPU粒子"></a>GPU粒子</h3><p>显然粒子系统这种天然并行的系统非常适合使用GPU进行计算，在现代游戏中也确实是使用GPU来实现对粒子系统的仿真。<br>稍后我们会看到使用GPU来对粒子系统进行计算不仅可以节约CPU的计算资源，更可以加速整个渲染的流程。<br><img src="/images/article/Games104/12/Games104_12_21.png"><span class="image-caption">GPU处理粒子</span><br><img src="/images/article/Games104/12/Games104_12_22.png"><span class="image-caption">GPU粒子</span></p><h4 id="粒子列表（Particle-Lists）"><a href="#粒子列表（Particle-Lists）" class="headerlink" title="粒子列表（Particle Lists）"></a>粒子列表（Particle Lists）</h4><p>我们可以通过维护若干个列表来实现对粒子系统的仿真。首先我们把系统中所有可能的粒子及其携带的信息放入particle pool中，并且在deal list中初始化所有的粒子编号。<br><img src="/images/article/Games104/12/Games104_12_23.png"><span class="image-caption">初始化状态</span></p><p>当emitter生成新的粒子时只需要将dead list中的粒子推入当前帧的alive list即可。<br><img src="/images/article/Games104/12/Games104_12_24.png"><span class="image-caption">生成新粒子</span></p><p>对粒子进行仿真时只需要考虑alive list中的粒子。如果某个粒子的生命周期结束了，则需要把该粒子编号重新放入dead list中，<br>然后在写入下一帧的alive list时跳过该编号。当需要切换到下一帧时只需交换两个alive list即可。<br><img src="/images/article/Games104/12/Games104_12_25.png"><span class="image-caption">模拟</span></p><p>由于所有的数据都在GPU上，我们还可以方便地对粒子进行frustum culling以及排序。<br><img src="/images/article/Games104/12/Games104_12_26.png"><span class="image-caption">排序</span></p><h4 id="并行合并排序（Parallel-Mergesort）"><a href="#并行合并排序（Parallel-Mergesort）" class="headerlink" title="并行合并排序（Parallel Mergesort）"></a>并行合并排序（Parallel Mergesort）</h4><p>在GPU上进行排序时需要使用并行的排序算法，其中比较经典的算法是<b>parallel mergesort</b>。<br><img src="/images/article/Games104/12/Games104_12_27.png"><span class="image-caption">并行合并排序</span></p><p>在合并两个有序数组时还可以使用从目标队列出发寻找源队列的方式进一步提升性能。<br><img src="/images/article/Games104/12/Games104_12_28.png"><span class="image-caption">并行合并排序2</span></p><h4 id="深度缓冲区碰撞（Depth-Buffer-Collision）"><a href="#深度缓冲区碰撞（Depth-Buffer-Collision）" class="headerlink" title="深度缓冲区碰撞（Depth Buffer Collision）"></a>深度缓冲区碰撞（Depth Buffer Collision）</h4><p>除此之外还可以在GPU中进行粒子和场景的碰撞检测。出于计算效率方面的考虑，<br>在对粒子进行碰撞检测时一般只会使用屏幕空间和深度图来简化计算。<br><img src="/images/article/Games104/12/Games104_12_29.png"><span class="image-caption">深度缓冲区碰撞</span></p><h3 id="粒子应用（Advanced-Particles）"><a href="#粒子应用（Advanced-Particles）" class="headerlink" title="粒子应用（Advanced Particles）"></a>粒子应用（Advanced Particles）</h3><h4 id="人群模拟（Crowd-Simulation）"><a href="#人群模拟（Crowd-Simulation）" class="headerlink" title="人群模拟（Crowd Simulation）"></a>人群模拟（Crowd Simulation）</h4><p>现代游戏的粒子系统已经远不局限于实现不同的视觉特效，实际上我们可以基于粒子系统来实现更加丰富的功能。<br>比如说游戏中大量NPC的运动行为就可以利用粒子系统进行实现。此时每个粒子不仅仅具有常见的物理属性， 还会携带顶点等几何信息。<br><img src="/images/article/Games104/12/Games104_12_30.png"><span class="image-caption">动画粒子网格</span></p><p>基于粒子的几何信息还可以让NPC动起来，甚至可以利用状态机的理论制作简单的动画。<br><img src="/images/article/Games104/12/Games104_12_31.png"><span class="image-caption">粒子动画贴图</span></p><p>基于SDF的相关技术还可以控制群体的运动行为。<br><img src="/images/article/Games104/12/Games104_12_32.png"><span class="image-caption">导航贴图</span><br><img src="/images/article/Games104/12/Games104_12_33.png"><span class="image-caption">人群运行时行为</span></p><p>在虚幻5引擎中就实现了非常强大的粒子系统，从而方便开发者设计各种复杂的玩法和场景。<br><img src="/images/article/Games104/12/Games104_12_34.png"><span class="image-caption">高级粒子展示</span><br><img src="/images/article/Games104/12/Games104_12_35.png"><span class="image-caption">高级粒子展示2</span></p><h4 id="在游戏中使用粒子系统（Utilizing-Particle-System-in-Games）"><a href="#在游戏中使用粒子系统（Utilizing-Particle-System-in-Games）" class="headerlink" title="在游戏中使用粒子系统（Utilizing Particle System in Games）"></a>在游戏中使用粒子系统（Utilizing Particle System in Games）</h4><p><img src="/images/article/Games104/12/Games104_12_36.png"><span class="image-caption">设计理念-预设堆叠式模块</span><br><img src="/images/article/Games104/12/Games104_12_37.png"><span class="image-caption">设计理念-基于图形的设计</span><br><img src="/images/article/Games104/12/Games104_12_38.png"><span class="image-caption">混合动力设计</span></p><h2 id="声音系统（Sound-System）"><a href="#声音系统（Sound-System）" class="headerlink" title="声音系统（Sound System）"></a>声音系统（Sound System）</h2><h3 id="声音基础"><a href="#声音基础" class="headerlink" title="声音基础"></a>声音基础</h3><p>音效是影响游戏氛围和玩家体验的重要一环，很多游戏都需要使用大量的音效来调动玩家的情绪。<br><img src="/images/article/Games104/12/Games104_12_39.png"><span class="image-caption">声音</span></p><p>声音的大小称为<b>音量(volume)</b>，它表示声波的振幅。<br><img src="/images/article/Games104/12/Games104_12_40.png"><span class="image-caption">音量</span></p><p>从物理的角度上讲，声音的本质是空气的振动。当空气发生振动时会产生相应的压强，这个压强的大小就对应人感知到的音量。<br>音量的单位是分贝(dB)，它是基于人对于声音的感知来定义的。<br><img src="/images/article/Games104/12/Games104_12_41.png"><span class="image-caption">音量术语</span><br><img src="/images/article/Games104/12/Games104_12_42.png"><span class="image-caption">音量术语2</span></p><p><b>音高(pitch)</b>是描述人耳对声音调子感受的物理量，它取决于声音振动的频率。音高越高，声音就越尖锐。<br><img src="/images/article/Games104/12/Games104_12_43.png"><span class="image-caption">音高</span></p><p><b>音色(timbre)</b>是描述声波形状的量。不同的乐器在演奏时会产生不同形式的基波，因此即使声波的频率相同也会产生不同的音色。<br><img src="/images/article/Games104/12/Games104_12_44.png"><span class="image-caption">音色</span></p><p>由于声音的本质是空气振动，我们可以在接收端叠加一个与当前振动相反的振动从而产生静音的效果。这就是现代降噪耳机的基本原理。<br><img src="/images/article/Games104/12/Games104_12_45.png"><span class="image-caption">降噪</span></p><p>人耳对不同频率声音的感受范围可参考下图：<br><img src="/images/article/Games104/12/Games104_12_46.png"><span class="image-caption">降噪</span></p><h4 id="数字声音（Digital-Sound）"><a href="#数字声音（Digital-Sound）" class="headerlink" title="数字声音（Digital Sound）"></a>数字声音（Digital Sound）</h4><p>自然界中的声音是连续的信号，因此要使用计算机存储或者表达声音就需要对连续的信号进行离散。<br>最常用的声音采样设备是<b>PCM(pulse-code modulation)</b>，它可以把连续的信号量化为离散的数字信号。<br><img src="/images/article/Games104/12/Games104_12_47.png"><span class="image-caption">PCM</span></p><p>根据Nyquist采样定理，我们只需要2倍于人耳接收频率的采样频率就可以完美的重建原始信号。<br>不过在实际采样时往往会使用更高一些的采样频率来获得更好的音质。<br><img src="/images/article/Games104/12/Games104_12_48.png"><span class="image-caption">取样</span></p><p>采样后的信号需要通过量化的过程编码为数字。<br><img src="/images/article/Games104/12/Games104_12_49.png"><span class="image-caption">量化</span></p><p>基于上面介绍的过程就可以把声音使用计算机可以识别和保存的数据。目前常用的声音格式如下：<br><img src="/images/article/Games104/12/Games104_12_50.png"><span class="image-caption">音频格式</span></p><h3 id="三维音频渲染"><a href="#三维音频渲染" class="headerlink" title="三维音频渲染"></a>三维音频渲染</h3><p>在游戏设计中我们需要在三维的环境里设置音效从而让玩家有身临其境的感受，因此我们需要设置一个虚拟的麦克风来采集场景中的声音。<br>通常情况下这个虚拟麦克风需要包含位置、速度以及朝向等物理信息。<br><img src="/images/article/Games104/12/Games104_12_51.png"><span class="image-caption">3D声源</span><br><img src="/images/article/Games104/12/Games104_12_52.png"><span class="image-caption">接收</span></p><p>对于人耳而言，我们可以利用双耳之间接收声音细微的变化来判断声源的大致位置。因此在游戏音效系统中可以利用人耳的这种效应来制造空间感。<br><img src="/images/article/Games104/12/Games104_12_53.png"><span class="image-caption">空间定位</span></p><h4 id="位移（Panning）"><a href="#位移（Panning）" class="headerlink" title="位移（Panning）"></a>位移（Panning）</h4><p>当音响有多个通道时我们可以调整不同音响的参数来产生空间感，这种方法称为panning。最简单的panning是进行线性插值<br>，假设有某个声源从前方经过，我们可以对左右两通道的声音进行线性插值来模拟这种效果。<br><img src="/images/article/Games104/12/Games104_12_54.png"><span class="image-caption">扇形位移</span><br><img src="/images/article/Games104/12/Games104_12_55.png"><span class="image-caption">线性位移</span></p><p>实际上人耳对于声音的感知是一个非线性函数，因此我们可以使用平方函数来改进线性插值的效果。<br>此时会出现当声源经过正前方时接收到的声音会小一点。<br><img src="/images/article/Games104/12/Games104_12_56.png"><span class="image-caption">线性位移2</span><br><img src="/images/article/Games104/12/Games104_12_57.png"><span class="image-caption">线性位移3</span></p><p>更进一步还可以使用三角函数来描述声音的变化，这样可以得到更逼真的效果。<br><img src="/images/article/Games104/12/Games104_12_58.png"><span class="image-caption">线性位移4</span></p><p>当然实际游戏中的panning算法会比上面介绍的要复杂得多，也可以表达更加复杂的空间位置变化。<br><img src="/images/article/Games104/12/Games104_12_59.png"><span class="image-caption">线性位移5</span></p><h4 id="衰减（Attenuation）"><a href="#衰减（Attenuation）" class="headerlink" title="衰减（Attenuation）"></a>衰减（Attenuation）</h4><p>当声源远离麦克风时会出现<b>衰减(attenuation)</b>的现象，随着距离的增加虚拟麦克风能接受到的声音会不断减少。<br>实际上不仅是接收到的音量会发生变化，距离也会对接收到声音的频率产生一定的影响。<br><img src="/images/article/Games104/12/Games104_12_60.png"><span class="image-caption">衰减</span></p><p>最简单的衰减模型是球形衰减，此时声音的变化只与声源和麦克风之间的距离有关。<br><img src="/images/article/Games104/12/Games104_12_61.png"><span class="image-caption">衰减形体 - 球体</span></p><p>更复杂的模型是胶囊形的衰减模型，它主要与麦克风到中心轴的距离相关。当接收端沿轴方向运动时声音的衰减基本保持不变。<br><img src="/images/article/Games104/12/Games104_12_62.png"><span class="image-caption">衰减形体 - 胶囊</span></p><p>对于室内场景可以考虑盒子形的衰减模型。<br><img src="/images/article/Games104/12/Games104_12_63.png"><span class="image-caption">衰减形体 - 盒子</span></p><p>对于高音喇叭这种声源则可以使用锥形的衰减模型描述声源的朝向。<br><img src="/images/article/Games104/12/Games104_12_64.png"><span class="image-caption">衰减形体 - 锥体</span></p><h4 id="障碍和遮挡（Obstruction-and-Occlusion）"><a href="#障碍和遮挡（Obstruction-and-Occlusion）" class="headerlink" title="障碍和遮挡（Obstruction and Occlusion）"></a>障碍和遮挡（Obstruction and Occlusion）</h4><p>由于声音的本质是波，在封闭环境中还需要考虑声波与环境的互动。当声音被场景中的障碍物阻挡时可以通过衍射的方式继续传播，<br>而如果声音的传播被完全阻挡它也可以通过阻挡物自身的振动继续向外传播。<br><img src="/images/article/Games104/12/Games104_12_65.png"><span class="image-caption">障碍和遮挡</span></p><p>因此在复杂的场景中往往需要使用一些采样的方法来模拟声音传播的效果。<br><img src="/images/article/Games104/12/Games104_12_66.png"><span class="image-caption">障碍和遮挡2</span></p><h4 id="混响（Reverb）"><a href="#混响（Reverb）" class="headerlink" title="混响（Reverb）"></a>混响（Reverb）</h4><p>除此之外声音在室内场景中还会出现<b>混响(reverb)</b>的现象，这是由于声波在场景中不断反射所导致的。<br><img src="/images/article/Games104/12/Games104_12_67.png"><span class="image-caption">混响</span></p><p>混响的效果很大程度上取决于材质的吸声特性，不同材质往往在不同的频率上有着巨大的性能差异。另一方面混响也取决于场景的几何特征。<br><img src="/images/article/Games104/12/Games104_12_68.png"><span class="image-caption">混响2</span><br><img src="/images/article/Games104/12/Games104_12_69.png"><span class="image-caption">混响3</span></p><p>通过调整不同的混响组合比例可以实现丰富的声学效果。<br><img src="/images/article/Games104/12/Games104_12_70.png"><span class="image-caption">基于声学参数的混响效果控制</span></p><h4 id="运动中的声（Sound-in-Motion）"><a href="#运动中的声（Sound-in-Motion）" class="headerlink" title="运动中的声（Sound in Motion）"></a>运动中的声（Sound in Motion）</h4><p>当声源发生运动时由于Doppler效应会导致接收端接收到的频率发生变化。<br><img src="/images/article/Games104/12/Games104_12_71.png"><span class="image-caption">运动中的声：多普勒效应</span><br><img src="/images/article/Games104/12/Games104_12_72.png"><span class="image-caption">运动中的声：多普勒效应2</span></p><h4 id="声场（Sound-Field）"><a href="#声场（Sound-Field）" class="headerlink" title="声场（Sound Field）"></a>声场（Sound Field）</h4><p>很多时候还可以对整个声场进行采集。<br><img src="/images/article/Games104/12/Games104_12_73.png"><span class="image-caption">空间化-声场</span></p><p>目前市面上常用的专业级声学引擎包括fmod或wwise等，这些引擎可以更好地辅助专业的声学设计。<br><img src="/images/article/Games104/12/Games104_12_74.png"><span class="image-caption">常见的中间件</span><br><img src="/images/article/Games104/12/Games104_12_75.png"><span class="image-caption">音频中间件如何工作的</span></p><p>目前想要表现大规模场景的声学特性仍是非常复杂的。<br><img src="/images/article/Games104/12/Games104_12_76.png"><span class="image-caption">模拟音频世界</span></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://peng00bo00.github.io/2022/06/15/GAMES104-NOTES-12.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1bU4y1R7x5/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture12_Effects.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎中物理系统的高级应用（十一）</title>
      <link href="/posts/be812c00.html"/>
      <url>/posts/be812c00.html</url>
      
        <content type="html"><![CDATA[<h2 id="角色控制器（Character-Controller）"><a href="#角色控制器（Character-Controller）" class="headerlink" title="角色控制器（Character Controller）"></a>角色控制器（Character Controller）</h2><p><b>角色控制器(character controller)</b>是玩家操作角色和游戏世界进行交互的接口。和很多人直观的认识不同，<br>角色控制器在很多情况下实际上是一个非物理的。最常见的例子是玩家控制角色停止移动时角色会立即停住，<br>而不是严格按照刚体仿真那样通过摩擦力来逐渐停止运动。某种意义上讲，角色控制器虽然是反物理的但却更符合人对物理世界的认知。<br><img src="/images/article/Games104/11/Games104_11_01.png"><span class="image-caption">角色控制 VS 刚体动力学</span></p><h3 id="构建一个控制器（Build-a-Controller-in-Physics-System）"><a href="#构建一个控制器（Build-a-Controller-in-Physics-System）" class="headerlink" title="构建一个控制器（Build a Controller in Physics System）"></a>构建一个控制器（Build a Controller in Physics System）</h3><p>在构建角色控制器时一般会使用简化后的形状来包裹角色，这样便于处理各种场景之间的互动。<br><img src="/images/article/Games104/11/Games104_11_02.png"><span class="image-caption">构建控制器</span></p><h3 id="与环境碰撞（Collide-with-Environment）"><a href="#与环境碰撞（Collide-with-Environment）" class="headerlink" title="与环境碰撞（Collide with Environment）"></a>与环境碰撞（Collide with Environment）</h3><p>在角色和场景进行互动时最常见的情况是玩家控制的角色撞到了墙壁上。如果严格按照物理引擎进行模拟，此时角色会一直停在碰撞的位置；<br>而现代游戏中更常见的处理方式是修改角色的运动方向，使得角色可以沿墙壁方向进行滑动。<br><img src="/images/article/Games104/11/Games104_11_03.png"><span class="image-caption">与环境碰撞</span></p><h3 id="自动步进及其问题（Auto-Stepping）"><a href="#自动步进及其问题（Auto-Stepping）" class="headerlink" title="自动步进及其问题（Auto Stepping）"></a>自动步进及其问题（Auto Stepping）</h3><p>上下楼梯同样也是角色在场景中的一种常见行为。如果严格按照物理仿真进行处理，胶囊的上下楼梯会非常地困难。<br>因此在游戏引擎中需要单独考虑这种情况，当角色上下楼梯时自动修正角色的位置。<br><img src="/images/article/Games104/11/Games104_11_04.png"><span class="image-caption">自动步进及其问题</span></p><p>对于斜坡这种情况，如果按照刚体运动学进行处理会导致角色下坡时直接从斜坡上滑下来，<br>或是在上坡时由于具有过大的速度角色直接冲上它不应该到达的位置。<br>为了避免这些问题需要单独考虑角色停在斜坡或是限制角色的位置。<br><img src="/images/article/Games104/11/Games104_11_05.png"><span class="image-caption">坡度限制和作用力向下滑动</span></p><h3 id="控制器卷更新（Controller-Volume-Update）"><a href="#控制器卷更新（Controller-Volume-Update）" class="headerlink" title="控制器卷更新（Controller Volume Update）"></a>控制器卷更新（Controller Volume Update）</h3><p>角色控制器还需要考虑角色体积发生变化的情况。当玩家控制角色进行下蹲等动作时需要自动更新角色控制体的体积，<br>否则容易出现角色卡在门口无法进入的问题。<br><img src="/images/article/Games104/11/Games104_11_06.png"><span class="image-caption">控制器卷更新</span></p><h3 id="控制器推送对象（Controller-Push-Objects）"><a href="#控制器推送对象（Controller-Push-Objects）" class="headerlink" title="控制器推送对象（Controller Push Objects）"></a>控制器推送对象（Controller Push Objects）</h3><p>当玩家控制角色和场景中的物体互动时需要对动态对象的运动状态加以更新。<br>比较常见的处理方式是发生碰撞时对动态对象施加一个相应的冲量来控制它们的运动。<br><img src="/images/article/Games104/11/Games104_11_07.png"><span class="image-caption">控制器推送对象</span></p><h3 id="站在移动平台上（Standing-on-Moving-Platform）"><a href="#站在移动平台上（Standing-on-Moving-Platform）" class="headerlink" title="站在移动平台上（Standing on Moving Platform）"></a>站在移动平台上（Standing on Moving Platform）</h3><p>除此之外，角色控制器还需要考虑动态场景的情况。当角色位于运动的平台时需要根据平台的运动来调整角色的运动状态，<br>否则会出现平台发生运动时角色的运动没有同步或是滞后的问题。<br><img src="/images/article/Games104/11/Games104_11_08.png"><span class="image-caption">站在移动平台上</span></p><h2 id="布娃娃系统（Ragdoll）"><a href="#布娃娃系统（Ragdoll）" class="headerlink" title="布娃娃系统（Ragdoll）"></a>布娃娃系统（Ragdoll）</h2><p><b>布娃娃(Ragdoll)</b>系统是游戏角色动画的一个重要组成部分，它最常见的例子是角色的处决动画：<br>当玩家控制的角色处决了某个游戏对象时，根据处决场景的不同被处决对象会发生相应场景互动的动作。<br><img src="/images/article/Games104/11/Games104_11_09.png"><span class="image-caption">为什么要使用布偶</span></p><h3 id="将骨架映射到刚体-Map-Skeleton-to-Rigid-Bodies"><a href="#将骨架映射到刚体-Map-Skeleton-to-Rigid-Bodies" class="headerlink" title="将骨架映射到刚体(Map Skeleton to Rigid Bodies)"></a>将骨架映射到刚体(Map Skeleton to Rigid Bodies)</h3><p>实际上ragdoll与前面介绍过的<a href="/posts/b1eb3151.html#骨骼动画-amp-蒙皮"><b><font color="red">骨骼动画</font></b></a>密切相关。在模拟ragdoll的运动时，<br>我们同样会在角色身上设置相应的节点并把不同节点之间的骨骼按照刚体进行模拟。<br>不过出于实时计算上的考虑，ragdoll一般只会使用非常少量的节点和骨骼来进行模拟。<br><img src="/images/article/Games104/11/Games104_11_10.png"><span class="image-caption">将骨架映射到刚体</span></p><h3 id="人体关节约束（Human-Joint-Constraints）"><a href="#人体关节约束（Human-Joint-Constraints）" class="headerlink" title="人体关节约束（Human Joint Constraints）"></a>人体关节约束（Human Joint Constraints）</h3><p>同样地，在ragdoll中需要考虑角色身上不同节点的运动是带有一定约束的。如果忽略了人体骨骼关节的约束则会导致非常扭曲的模拟效果。<br><img src="/images/article/Games104/11/Games104_11_11.png"><span class="image-caption">人体关节约束</span><br><img src="/images/article/Games104/11/Games104_11_12.png"><span class="image-caption">联合约束的重要性</span></p><p>一般来说ragdoll关节的约束会由TA进行设置，如果设置的不好会出现一些反直觉的动画效果。<br><img src="/images/article/Games104/11/Games104_11_13.png"><span class="image-caption">约束属性</span><br><img src="/images/article/Games104/11/Games104_11_14.png"><span class="image-caption">精心调整约束</span></p><h3 id="布娃娃的骨架动画（Animating-Skeleton-by-Ragdoll）"><a href="#布娃娃的骨架动画（Animating-Skeleton-by-Ragdoll）" class="headerlink" title="布娃娃的骨架动画（Animating Skeleton by Ragdoll）"></a>布娃娃的骨架动画（Animating Skeleton by Ragdoll）</h3><p>需要注意的是尽管我们可以使用ragdoll来模拟角色的动画，在实际游戏中仍然是需要通过骨骼关节系统来驱动整个角色的运动。<br>由于ragdoll中的骨骼关节数量一般会少于实际角色的骨骼关节，<br>我们需要使用<a href="/posts/649819f1.html#动画重定向（Animation-Retargeting）"><b><font color="red">动画重定向</font></b></a>技术来将ragdoll计算出的运动映射到实际的角色骨骼上。<br><img src="/images/article/Games104/11/Games104_11_15.png"><span class="image-caption">布娃娃的骨架动画</span></p><h3 id="混合动画和布娃娃（Blending-between-Animation-and-Ragdoll）"><a href="#混合动画和布娃娃（Blending-between-Animation-and-Ragdoll）" class="headerlink" title="混合动画和布娃娃（Blending between Animation and Ragdoll）"></a>混合动画和布娃娃（Blending between Animation and Ragdoll）</h3><p>在使用时还需要注意角色动画切换到ragdoll的过程。还是以角色处决动画为例，在一开始被处决对象是使用预先录制的角色动画，<br>然后在某一时刻会切换成ragdoll使用物理系统来实时计算角色的行为。<br><img src="/images/article/Games104/11/Games104_11_16.png"><span class="image-caption">混合动画和布娃娃</span></p><p>更进一步，在现代3A游戏中还会将角色动画和ragdoll实时计算出的动画进行混合来提升玩家的代入感和游戏体验。<br><img src="/images/article/Games104/11/Games104_11_17.png"><span class="image-caption">物理动画混合</span></p><h2 id="衣料模拟（Cloth）"><a href="#衣料模拟（Cloth）" class="headerlink" title="衣料模拟（Cloth）"></a>衣料模拟（Cloth）</h2><p>布料系统是游戏物理仿真中的重要一环。早期的布料模拟是使用预先录制的动画来实现的，<br>我们可以在角色身上设置一些额外的骨骼来控制衣物的运动，<br>这样就可以实现角色执行不同动作时衣物随之飘动的效果。<br><img src="/images/article/Games104/11/Games104_11_18.png"><span class="image-caption">基于动画的布料模拟</span></p><p>另一种处理衣物的方法是使用刚体运动的方法来模拟衣物和角色以及场景的互动。<br>这样的处理方法虽然需要更多的计算资源，但可以实现相对真实衣物运动的效果。<br><img src="/images/article/Games104/11/Games104_11_19.png"><span class="image-caption">基于刚体的布料模拟</span></p><h3 id="基于网格的布料模拟（Mesh-Based-Cloth-Simulation）"><a href="#基于网格的布料模拟（Mesh-Based-Cloth-Simulation）" class="headerlink" title="基于网格的布料模拟（Mesh-Based Cloth Simulation）"></a>基于网格的布料模拟（Mesh-Based Cloth Simulation）</h3><p>而在现代游戏引擎中衣物运动更多地是使用网格来进行模拟。这里首先要说明的是布料仿真中使用的网格是不同于渲染中所使用的网格，<br>出于计算效率上的考虑布料仿真中使用的网格要比渲染中的网格要稀疏很多。<br><img src="/images/article/Games104/11/Games104_11_20.png"><span class="image-caption">渲染网格 VS 物理网格</span></p><p>同时在布料仿真中往往还会为网格上的每个顶点赋予一定位移的约束，从而获得更符合人直觉的仿真结果。<br><img src="/images/article/Games104/11/Games104_11_21.png"><span class="image-caption">布料模拟约束条件</span></p><h3 id="质量弹簧系统（Mass-Spring-System）"><a href="#质量弹簧系统（Mass-Spring-System）" class="headerlink" title="质量弹簧系统（Mass-Spring System）"></a>质量弹簧系统（Mass-Spring System）</h3><p>使用网格进行布料仿真的基本处理方法是使用质点弹簧系统进行模拟。我们为网格的顶点赋予一定的质量，然后将相邻顶点使用弹簧连接起来就形成了布料仿真的物理系统。<br>这里需要注意的是除了弹簧弹力之外一般还需要为质点施加一定的阻尼来保证质点的运动最终能够停住。<br><img src="/images/article/Games104/11/Games104_11_22.png"><span class="image-caption">质量弹簧系统</span></p><p>在放置弹簧时除了横竖方向外一般还需要在对角方向上也设置一些弹簧，这样可以保证布料具有抵抗对角方向的刚度。<br><img src="/images/article/Games104/11/Games104_11_23.png"><span class="image-caption">质量弹簧系统2</span></p><p>最后把外力施加在质点弹簧系统上就可以进行布料的运动仿真了。这里需要注意的是在进行仿真时不要忘记质点除了弹簧施加的弹力和阻尼外自身还会收到重力以及空气阻力的作用。<br><img src="/images/article/Games104/11/Games104_11_24.png"><span class="image-caption">质量弹簧系统3</span></p><h3 id="韦尔莱积分（Verlet-Integration）"><a href="#韦尔莱积分（Verlet-Integration）" class="headerlink" title="韦尔莱积分（Verlet Integration）"></a>韦尔莱积分（Verlet Integration）</h3><p>对质点弹簧系统进行仿真时不可避免地会使用到一些数值积分的方法，这里我们着重介绍一些Verlet积分算法。Verlet积分本质仍然是半隐式欧拉积分，<br>不过在实际积分时可以将速度项约掉只保留位移和加速度项就能进行计算。因此Verlet积分不需要保存每一时刻的速度，<br>我们只需要位移和力(加速度)就可以进行计算，从而提高布料仿真的效率。<br><img src="/images/article/Games104/11/Games104_11_25.png"><span class="image-caption">韦尔莱积分</span></p><h3 id="自相交（Self-Collision）"><a href="#自相交（Self-Collision）" class="headerlink" title="自相交（Self Collision）"></a>自相交（Self Collision）</h3><p>布料仿真的一大难点在于如何处理<b>自相交(self collision)</b>问题。由于我们使用了没有体积的网格来表示布料，在进行仿真时很容易出现网格直接相互的穿插。<br><img src="/images/article/Games104/11/Games104_11_26.png"><span class="image-caption">自相交</span></p><p>目前布料自相交的问题还没有一个十分完善的解决方法。在工业界会使用一些trick来缓解自相交的问题，<br>比如说对布料进行加厚、减少仿真时的时间步长、限制顶点的速度以及使用SDF进行控制等。<br><img src="/images/article/Games104/11/Games104_11_27.png"><span class="image-caption">自相交的常见解决方案</span><br><img src="/images/article/Games104/11/Games104_11_28.png"><span class="image-caption">自相交的常见解决方案2</span></p><h2 id="破坏模拟（Destruction）"><a href="#破坏模拟（Destruction）" class="headerlink" title="破坏模拟（Destruction）"></a>破坏模拟（Destruction）</h2><p>玩家对场景的破坏是通过破坏系统来进行实现。一个好的破坏系统可以极大地提升玩家的游戏体验，有些游戏甚至是以破坏系统为核心玩法进行设计的。<br><img src="/images/article/Games104/11/Games104_11_29.png"><span class="image-caption">破坏的重要性</span></p><h3 id="区块层次结构（Chunk-Hierarchy）"><a href="#区块层次结构（Chunk-Hierarchy）" class="headerlink" title="区块层次结构（Chunk Hierarchy）"></a>区块层次结构（Chunk Hierarchy）</h3><p>我们可以使用一棵树来描述同一物体不同碎片之间的层次关系：树的根节点表示完整的物体，而它下面的每一层表示物体经受一定程度的冲击后所产生的碎片。<br><img src="/images/article/Games104/11/Games104_11_30.png"><span class="image-caption">区块层次结构</span></p><h3 id="连通性图（Connectivity-Graph）"><a href="#连通性图（Connectivity-Graph）" class="headerlink" title="连通性图（Connectivity Graph）"></a>连通性图（Connectivity Graph）</h3><p>当确定了物体承受的冲击后就可以使用一张图来表示不同碎片之间的连接关系：图的节点表示碎片，<br>而图的边则表示相互连接的碎片能够承受的荷载，当冲击大于边上的值时就会发生物体的破碎。<br><img src="/images/article/Games104/11/Games104_11_31.png"><span class="image-caption">连通性图</span><br><img src="/images/article/Games104/11/Games104_11_32.png"><span class="image-caption">连通性值</span></p><h3 id="损坏计算（Damage-Calculation）"><a href="#损坏计算（Damage-Calculation）" class="headerlink" title="损坏计算（Damage Calculation）"></a>损坏计算（Damage Calculation）</h3><p>需要说明的是虽然我们使用了冲击和荷载这样的字眼，实际上在游戏引擎中却不会去计算这些物理量。<br>它们只是一些人工设置的数值，并不具备真实的物理意义。在游戏开发中一般会使用一些经验公式来对冲击以及物体的承载力进行计算。<br><img src="/images/article/Games104/11/Games104_11_33.png"><span class="image-caption">损坏计算</span><br><img src="/images/article/Games104/11/Games104_11_34.png"><span class="image-caption">损坏计算2</span></p><h3 id="沃罗诺伊图压裂（Fracturing-with-Voronoi-Diagram）"><a href="#沃罗诺伊图压裂（Fracturing-with-Voronoi-Diagram）" class="headerlink" title="沃罗诺伊图压裂（Fracturing with Voronoi Diagram）"></a>沃罗诺伊图压裂（Fracturing with Voronoi Diagram）</h3><p>那么如何去生成这样的一张图呢？在物理引擎中一般会使用<b>沃罗诺伊图(Voronoi diagram)</b>这样的技术来对原始的物体区域进行划分，<br>划分后的每一个区域即为所需的碎片。<br><img src="/images/article/Games104/11/Games104_11_35.png"><span class="image-caption">通过沃罗诺伊图构建块</span><br><img src="/images/article/Games104/11/Games104_11_36.png"><span class="image-caption">沃罗诺伊图 - 2D网格</span></p><p>对于三维的情况则要更加复杂一些，除了需要使用Voronoi图对空间进行划分还需要使用Delaunay三角化来重新生成碎片的三维网格。<br>同时当物体破碎后还需要为碎片的网格赋予内部材质的纹理，这一般需要使用一些程序化的纹理生成算法。<br><img src="/images/article/Games104/11/Games104_11_37.png"><span class="image-caption">沃罗诺伊图 - 3D网格</span><br><img src="/images/article/Games104/11/Games104_11_38.png"><span class="image-caption">沃罗诺伊图 - 3D网格2</span></p><p>在设置Voronoi图的种子时还可以根据需要设置不同模式的种子，这样可以实现相应的破碎效果。<br><img src="/images/article/Games104/11/Games104_11_39.png"><span class="image-caption">不同的沃罗诺伊图</span></p><h3 id="物理系统中的破坏（Destruction-in-Physics-System）"><a href="#物理系统中的破坏（Destruction-in-Physics-System）" class="headerlink" title="物理系统中的破坏（Destruction in Physics System）"></a>物理系统中的破坏（Destruction in Physics System）</h3><p>从物理系统的计算流程上来看，破碎系统一般是仿真碰撞检测后实际解算之前。这主要是因为很多破碎的事件是由碰撞所导致的，<br>同时在物体破碎后往往还会产生新的物体(碎片)需要计算相应的运动。<br><img src="/images/article/Games104/11/Games104_11_40.png"><span class="image-caption">物理系统中的破坏</span></p><h3 id="破坏的问题（Issues-with-Destruction）"><a href="#破坏的问题（Issues-with-Destruction）" class="headerlink" title="破坏的问题（Issues with Destruction）"></a>破坏的问题（Issues with Destruction）</h3><p>除了物理系统的计算外在处理场景破坏时还需要添加相应的声音和粒子效果，这样可以得到更加真实的游戏体验。<br><img src="/images/article/Games104/11/Games104_11_41.png"><span class="image-caption">更加真实的游戏体验</span></p><p>此外破坏系统的计算是相当昂贵的：当一个物体出现破碎后往往会带来成百上千个碎片需要进行物理仿真，<br>这会极大地增加物理系统的计算负载，因此在使用时需要慎重考虑。<br><img src="/images/article/Games104/11/Games104_11_42.png"><span class="image-caption">破坏的问题</span></p><h3 id="流行的破坏实现（Popular-Destruction-Implementations）"><a href="#流行的破坏实现（Popular-Destruction-Implementations）" class="headerlink" title="流行的破坏实现（Popular Destruction Implementations）"></a>流行的破坏实现（Popular Destruction Implementations）</h3><p>目前很多商业引擎都有现成的破坏系统。<br><img src="/images/article/Games104/11/Games104_11_43.png"><span class="image-caption">流行的破坏实现</span><br><img src="/images/article/Games104/11/Games104_11_44.png"><span class="image-caption">流行的破坏实现2</span></p><h2 id="载具模拟（Vehicle）"><a href="#载具模拟（Vehicle）" class="headerlink" title="载具模拟（Vehicle）"></a>载具模拟（Vehicle）</h2><p>载具系统是现代游戏中重要的组成部分。要对载具进行模拟需要推导相应的动力学模型，<br>以汽车为例整个汽车可以看做通过悬挂系统与地面接触的刚体。<br><img src="/images/article/Games104/11/Games104_11_45.png"><span class="image-caption">车辆机构建模</span></p><p>整个汽车的驱动力来自于引擎产生的扭矩，而扭矩的大小则需要查询引擎的相关曲线来计算。<br><img src="/images/article/Games104/11/Games104_11_46.png"><span class="image-caption">牵引力</span></p><p>在竖直方向上由于地面的起伏车身会产生悬挂系统所导致的振动。<br><img src="/images/article/Games104/11/Games104_11_47.png"><span class="image-caption">悬挂力</span></p><p>在平面上汽车的轮胎会产生平行于前进方向的径向力，同时还会产生的切向力控制车辆的转动。<br><img src="/images/article/Games104/11/Games104_11_48.png"><span class="image-caption">轮胎力</span></p><p>根据车身重量的分布我们还需要计算汽车的重心。实际上重心的位置不仅会控制汽车的振动，还会汽车的转向性能有重要的影响。<br><img src="/images/article/Games104/11/Games104_11_49.png"><span class="image-caption">质心</span><br><img src="/images/article/Games104/11/Games104_11_50.png"><span class="image-caption">质心2</span><br><img src="/images/article/Games104/11/Games104_11_51.png"><span class="image-caption">质心3</span></p><p>同时需要注意的是当车辆进行加速或是刹车时重心的位置也会发生一些变化。<br><img src="/images/article/Games104/11/Games104_11_52.png"><span class="image-caption">重心移动</span></p><p>为了更好地实现转向，现代汽车在设计时会让两个转向轮的转动有微小的差异。在进行模拟时也需要考虑这个微小的角度变化。<br><img src="/images/article/Games104/11/Games104_11_53.png"><span class="image-caption">转向角度</span></p><p>最后需要说明的是在计算地面和车轮求交时需要把轮子看做是球，这样才能模拟出车辆在凹凸不平的地面上行驶的效果。<br><img src="/images/article/Games104/11/Games104_11_54.png"><span class="image-caption">高级轮胎接触点</span></p><h2 id="高级：PBD与XPBD"><a href="#高级：PBD与XPBD" class="headerlink" title="高级：PBD与XPBD"></a>高级：PBD与XPBD</h2><h3 id="PBD"><a href="#PBD" class="headerlink" title="PBD"></a>PBD</h3><p>本节课最后讨论了PBD和XPBD两种更高级的物理仿真技术。和前面介绍过的仿真技术相比，<br>PBD和XPBD是建立在<b>拉格朗日力学(Lagrangian mechanics)</b>基础上的仿真方法。<br>在拉格朗日力学的框架中不再考虑力等物理概念，而是把物理定律视为系统的某种约束来描述运动。<br><img src="/images/article/Games104/11/Games104_11_55.png"><span class="image-caption">求解约束</span></p><p>以匀速圆周运动为例，在拉格朗日力学中我们不会去计算各种改变质点运动状态的力，<br>而是考虑质点运动的位置约束以及速度约束。其中位置约束的导数也称为Jacobian矩阵。<br><img src="/images/article/Games104/11/Games104_11_56.png"><span class="image-caption">环状约束</span></p><p>类似地，弹簧质点系统也可以表示为由约束定义的系统。<br><img src="/images/article/Games104/11/Games104_11_57.png"><span class="image-caption">字符串约束</span></p><p>PBD在求解时，PBD会把整个物理系统描述为关于位置的约束。然后通过不断迭代来计算满足约束的解。<br><img src="/images/article/Games104/11/Games104_11_58.png"><span class="image-caption">PBD - 约束投影</span><br><img src="/images/article/Games104/11/Games104_11_59.png"><span class="image-caption">PBD - 约束投影2</span></p><p>整个PBD的求解流程如下：<br><img src="/images/article/Games104/11/Games104_11_60.png"><span class="image-caption">PBD - 求解流程</span><br><img src="/images/article/Games104/11/Games104_11_61.png"><span class="image-caption">PBD - 求解流程2</span><br><img src="/images/article/Games104/11/Games104_11_62.png"><span class="image-caption">PBD - 求解流程3</span><br><img src="/images/article/Games104/11/Games104_11_63.png"><span class="image-caption">PBD - 求解流程4</span><br><img src="/images/article/Games104/11/Games104_11_64.png"><span class="image-caption">PBD - 求解流程5</span><br><img src="/images/article/Games104/11/Games104_11_65.png"><span class="image-caption">PBD - 求解流程6</span></p><p>PBD是目前游戏行业非常热门的物理仿真技术，和传统仿真技术相比PBD往往会得到更稳定的解。<br><img src="/images/article/Games104/11/Games104_11_66.png"><span class="image-caption">PBD应用</span></p><h3 id="XPBD"><a href="#XPBD" class="headerlink" title="XPBD"></a>XPBD</h3><p>XPBD可以看做是对PBD的一种推广，它在PBD的基础上引入了<b>刚度(stiffness)</b>的概念来描述不同约束的强弱。<br><img src="/images/article/Games104/11/Games104_11_67.png"><span class="image-caption">基于动力学的拓展</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/06/05/GAMES104-NOTES-11.html">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1Ya411j7ds/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture11_Physics%20System_Applications.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎中物理系统的基础理论和算法（十）</title>
      <link href="/posts/de5d97c9.html"/>
      <url>/posts/de5d97c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h2><p>物理系统是游戏引擎的重要组成部分。 在游戏中玩家和整个游戏世界的互动都是依赖于物理系统的实现，同时在现代游戏中大量的粒子效果也都是通过物理系统来进行驱动的。<br>显然物理系统非常复杂，甚至于有很多公司专门去研究物理引擎的高效实现。 而在本课程中我们同样把物理系统拆分成两节，<br>这一节课主要介绍物理引擎的基本概念而在下一节课中则会更多地讨论游戏业界更前沿的物理仿真技术。<br><img src="/images/article/Games104/10/Games104_10_01.png"><span class="image-caption">物理系统大纲</span></p><h2 id="物理对象与形状"><a href="#物理对象与形状" class="headerlink" title="物理对象与形状"></a>物理对象与形状</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>静态对象：Static</li><li>动态对象：Dynamic</li><li>Trigger：碰撞检测区域</li><li>Kinematic对象：不符合物理原理，玩法逻辑控制</li></ul><h3 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h3><ul><li>球</li><li>胶囊体</li><li>立方体</li><li>凸多边形 Convex Meshes</li><li>三角面</li><li>高度图：多见于地形</li></ul><p><img src="/images/article/Games104/10/Games104_10_02.png"><span class="image-caption">Actor Shapes</span></p><p>当我们利用这些对象去组成实际需要的物体对象时，有两个原则：</p><ul><li>形状接近就好，不一定要完美</li><li>简单性。要尽量用简单的对象去拼接（比如尽量少用三角网格），且越少越好。<br><img src="/images/article/Games104/10/Games104_10_03.png"><span class="image-caption">用物理形状包裹对象</span></li></ul><p>此外，一些比较重要的物理概念：</p><ul><li>质量和密度 Mass and Density</li><li>质心（做载具时很重要）Center of Mass</li><li>摩擦和恢复（弹性） Friction &amp; Restitution</li></ul><h2 id="力于运动"><a href="#力于运动" class="headerlink" title="力于运动"></a>力于运动</h2><h3 id="力"><a href="#力" class="headerlink" title="力"></a>力</h3><p>一般我们把力分成两种：</p><ul><li>Force 可以理解为直接的重力、拉力、摩擦力等</li></ul><p><img src="/images/article/Games104/10/Games104_10_04.png"><span class="image-caption">力</span></p><ul><li>Impulse 冲量，比如说爆炸导致的冲击力等（虽然其实冲量就是力x时间（恒力条件下））</li></ul><p><img src="/images/article/Games104/10/Games104_10_05.png"><span class="image-caption">冲量</span></p><h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>牛顿第一定律：<br>在没有外力作用下，物体保持匀速直线运动<br><img src="/images/article/Games104/10/Games104_10_06.png"><span class="image-caption">牛顿第一定律</span></p><p>牛顿第二定律：<br>在有外力作用下，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.895ex" height="2.636ex" role="img" focusable="false" viewBox="0 -1083 3489.6 1165"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mo" transform="translate(484.3,269) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1026.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2082.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2960.6,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container>（力 = 质量 * 加速度）<br><img src="/images/article/Games104/10/Games104_10_07.png"><span class="image-caption">牛顿第二定律</span></p><p>在物理引擎中一般无法使用解析的方式来计算物体的运动，因此我们需要一些数值计算方法来进行求解。<br><img src="/images/article/Games104/10/Games104_10_08.png"><span class="image-caption">恒力下的运动</span><br><img src="/images/article/Games104/10/Games104_10_09.png"><span class="image-caption">不同力量下的运动</span><br>其中上图中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.821ex" height="2.48ex" role="img" focusable="false" viewBox="0 -846 3899 1096"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(270.3,32) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(874,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1235,0)"><g data-mml-node="mo"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g></g><g data-mml-node="mo" transform="translate(1510,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(1899,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">中</text></g><g data-mml-node="mi" transform="translate(2899,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g></g></g></svg></mjx-container>t$是二次积分（位移和时间关系公式就是二次的）</p><p>具体以圆周运动为例，如果简单去模拟物体随时间变化，并不是很困难。<br>但实际游戏中时间不是连续的，而是由一帧帧实现的，所以通常需要解决的问题是在已知当前物体位置和速度的前提下获取之后某时刻的物体位置和速度信息。<br><img src="/images/article/Games104/10/Games104_10_10.png"><span class="image-caption">游戏中的模拟</span></p><h3 id="显示欧拉法-Explicit-Forward-Euler’s-Method"><a href="#显示欧拉法-Explicit-Forward-Euler’s-Method" class="headerlink" title="显示欧拉法 Explicit (Forward) Euler’s Method"></a>显示欧拉法 Explicit (Forward) Euler’s Method</h3><p>在进行数值积分时，我们可以把时间间隔设置成一个比较小的值然后对被积函数进行累加来近似实际的积分。<br>具体来说，在计算物体的运动轨迹时我们首先计算物体在当前位置上受到的力并且积分得到加速度，然后再利用加速度来更新速度以及物体的位置。<br>这种计算物体运动轨迹的方法称为<b>Euler方法(Euler’s method)</b>，也称为<b>显式积分(explicit integration)</b>。<br>Euler方法实现起来非常简单，但需要注意的是它的本质是使用物体的当前状态来估计下一时刻的运动状态，此时系统的能量是不守恒的。<br><img src="/images/article/Games104/10/Games104_10_11.png"><span class="image-caption">显示欧拉法</span><br><img src="/images/article/Games104/10/Games104_10_12.png"><span class="image-caption">显示欧拉法2</span><br><img src="/images/article/Games104/10/Games104_10_13.png"><span class="image-caption">显示欧拉法3</span></p><p>这种方法下，由于实际游戏中的时间片<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.701ex" height="1.645ex" role="img" focusable="false" viewBox="0 -716 1194 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container>不可能和现实中一样小，所以会导致能量不守恒（实际位移是偏多的），误差越来越大，物体逐渐甩出去。</p><h3 id="隐式欧拉法-Implicit-Backward-Euler’s-Method"><a href="#隐式欧拉法-Implicit-Backward-Euler’s-Method" class="headerlink" title="隐式欧拉法 Implicit (Backward) Euler’s Method"></a>隐式欧拉法 Implicit (Backward) Euler’s Method</h3><p>为了提高数值积分的稳定性，人们还开发出了<b>隐式积分(implicit integration)</b>的技术。<br>隐式积分的实现也很简单，只需要在求解加速度和速度时使用下一时刻而不是当前时刻的值即可， 同时可以证明此时系统的能量会不断衰减。<br>当然这又引入了另一个问题，即如何计算系统在下一时刻的物理量， 这在很多情况下是比较困难的。<br><img src="/images/article/Games104/10/Games104_10_14.png"><span class="image-caption">隐式欧拉法</span><br><img src="/images/article/Games104/10/Games104_10_15.png"><span class="image-caption">隐式欧拉法2</span></p><p>其中未来的值是假设能够通过解析解强行算出来的。 和显示方法类似，该方法的问题是能量会衰减，<br>但由于这个衰减相对较慢，所以用户可能会认为是摩擦力、空气阻力等其他力的影响导致，<br>从而使得这个衰减在游戏实际中相对不明显。 从另一个角度来说，我们在游戏引擎中设计中认为衰减肯定是好过增多的，<br>前者顶多最后停下来，但后者会不可控会爆炸。 通过一系列复杂计算可以证明这种隐式方法是无条件稳定的。 但其缺点是：</p><ul><li>计算成本高（计算未来值）</li><li>运动非线性时难以计算</li><li>能量衰减。</li></ul><h3 id="半隐式欧拉法-Semi-implicit-Euler’s-Method"><a href="#半隐式欧拉法-Semi-implicit-Euler’s-Method" class="headerlink" title="半隐式欧拉法 Semi-implicit Euler’s Method"></a>半隐式欧拉法 Semi-implicit Euler’s Method</h3><p>在游戏引擎中更常用的积分方法是半隐式Euler方法(semi-implicit Euler’s method)，<br>即在计算加速度时使用当前时刻的力推导下一时刻的速度，而在计算位置时使用刚才计算出的速度再更新位置。<br>半隐式方法有非常高的数值稳定性，广泛应用于各种类型的物理仿真中。<br><img src="/images/article/Games104/10/Games104_10_16.png"><span class="image-caption">半隐式欧拉法</span><br><img src="/images/article/Games104/10/Games104_10_17.png"><span class="image-caption">半隐式欧拉法2</span></p><p>计算未来速度时用当前的力，计算未来位移时用未来的速度。 前提假设：力是不变的（很危险的假设，因为实际上力跟物体位置是相关的）。<br>优点是：</p><ul><li>条件性稳定</li><li>计算简单有效</li><li>随着时间的推移能够保存能量</li></ul><p>缺点是做一些sin cos等运动时，积分出来的周期会比正确值长一点点，所以在相位上会有偏移差。</p><h2 id="刚体动力学"><a href="#刚体动力学" class="headerlink" title="刚体动力学"></a>刚体动力学</h2><p>有了牛顿定律和数值积分算法就可以开始进行物理仿真了，其中最简单的情况是<b>质点动力学(particle dynamics)</b>。<br>在质点动力学中所有的物体都被抽象为没有具体形状的质点，此时我们只需要按照牛顿定律更新质点的运动状态即可。<br><img src="/images/article/Games104/10/Games104_10_18.png"><span class="image-caption">质点动力学</span></p><p>在游戏引擎中更为常见的仿真场景是刚体动力学(rigid body dynamics)。 和质点动力学不同，<br>刚体动力学仿真需要考虑物体自身的形状，也因此需要在质点运动的基础上引入刚体旋转的相关概念。<br><img src="/images/article/Games104/10/Games104_10_19.png"><span class="image-caption">刚体动力学</span></p><h3 id="取向"><a href="#取向" class="headerlink" title="取向"></a>取向</h3><p>刚体的<b>朝向(orientation)</b>可以使用一个旋转矩阵或者四元数来表示，它表示刚体当前姿态相对于初始姿态的旋转。<br><img src="/images/article/Games104/10/Games104_10_20.png"><span class="image-caption">取向</span></p><h3 id="角速度"><a href="#角速度" class="headerlink" title="角速度"></a>角速度</h3><p><b>角速度(angular velocity)</b>表示刚体绕某个旋转轴旋转的速度，需要注意的是在描述角速度时必须要指明旋转轴。<br><img src="/images/article/Games104/10/Games104_10_21.png"><span class="image-caption">角速度</span></p><h3 id="角加速度"><a href="#角加速度" class="headerlink" title="角加速度"></a>角加速度</h3><p><b>角加速度(angular acceleration)</b>类似于加速度，不过它描述的是角速度的变化。<br>这里需要说明的是角速度的变化不仅包括绕当前轴转速的变化，它还包括旋转轴发生变化的情况。<br><img src="/images/article/Games104/10/Games104_10_22.png"><span class="image-caption">角加速度</span></p><h3 id="旋转惯量"><a href="#旋转惯量" class="headerlink" title="旋转惯量"></a>旋转惯量</h3><p><b>转动惯量(rotational inertia)</b>类似于质量，它描述了刚体抵抗旋转的能力。 转动惯量与质量的一大区别在于转动惯量不是一个常数而是一个张量(矩阵)，<br>当刚体的朝向发生改变时需要利用旋转矩阵来计算当前姿态下的转动惯量； 同时转动惯量也与刚体上的质量分布密切相关。<br><img src="/images/article/Games104/10/Games104_10_23.png"><span class="image-caption">旋转惯量</span><br><img src="/images/article/Games104/10/Games104_10_24.png"><span class="image-caption">旋转惯量2</span></p><h3 id="角动量"><a href="#角动量" class="headerlink" title="角动量"></a>角动量</h3><p><b>角动量(angular momentum)</b>则描述了刚体旋转的状态，它是转动惯量与角速度的乘积。<br><img src="/images/article/Games104/10/Games104_10_25.png"><span class="image-caption">角动量</span></p><h3 id="力矩"><a href="#力矩" class="headerlink" title="力矩"></a>力矩</h3><p>当外力不通过刚体的质心时会产生<b>力矩(torque)</b>，从而导致刚体发生旋转。<br><img src="/images/article/Games104/10/Games104_10_26.png"><span class="image-caption">力矩</span></p><p>在质点动力学的基础上把旋转部分也考虑进来对物体的运动状态进行更新就得到了刚体动力学的仿真方法。<br><img src="/images/article/Games104/10/Games104_10_27.png"><span class="image-caption">概要</span></p><h3 id="应用：台球动力学"><a href="#应用：台球动力学" class="headerlink" title="应用：台球动力学"></a>应用：台球动力学</h3><p>以台球游戏模拟为例，我们假设台球自身与桌面没有摩擦，这样台球的运动可以简化为二维平面运动。<br>在进行仿真时需要把球杆给予台球的力(冲量)移动到球心来计算台球沿球杆方向的速度；<br>同时这种移动还会对台球施加一个力矩使台球产生旋转，因此也需要更新台球的角速度。<br><img src="/images/article/Games104/10/Games104_10_28.png"><span class="image-caption">应用：台球动力学</span></p><h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>在进行刚体仿真时我们需要考虑不同刚体之间的相互作用，也即所谓的碰撞问题。<br>要求解碰撞问题的第一步是对刚体碰撞进行检测，目前在物理引擎中注意是使用两阶段的检测方法。<br>碰撞检测一般分为两个阶段</p><ul><li>Broad phase 初筛 – 利用AABB等找到刚体有没有相交</li><li>Narrow phase – 获取进一步信息（碰撞点、方向、深度等）</li></ul><p>Broad Phase一般常见的有两种方法：</p><ul><li>BVH Tree – 更新成本低，适合动态场景。</li><li>Sort and Sweep – 先排序再逐个扫描，效率高，更符合大部分为静态物体小部分为动态物体的现实。更好。</li></ul><p><img src="/images/article/Games104/10/Games104_10_29.png"><span class="image-caption">碰撞检测-分为两个阶段</span><br><img src="/images/article/Games104/10/Games104_10_30.png"><span class="image-caption">宽相和窄相</span></p><h3 id="宽相"><a href="#宽相" class="headerlink" title="宽相"></a>宽相</h3><p>显然场景中大部分的物体是不会同时发生接触的，因此所谓的broad phase就是只利用物体的bounding box来快速筛选出可能发生碰撞的物体。<br>目前物理引擎中常用的碰撞检测包括<b>空间划分(space partitioning)</b>以及<b>sort and sweep</b>两类方法。<br><img src="/images/article/Games104/10/Games104_10_31.png"><span class="image-caption">宽相</span></p><h4 id="BVH树"><a href="#BVH树" class="headerlink" title="BVH树"></a>BVH树</h4><p>我们在介绍渲染技术时就介绍过空间划分的相关概念，它的思想是把场景中的物体使用一个树状的数据结构进行管理从而加速判断物体是否相交的过程。<br>BVH是空间划分的经典算法，它使用一棵二叉树来管理场景中所有物体的bounding box。 BVH的特点是它可以通过动态更新节点来描述场景中物体的变化，<br>因此可以快速地检测场景中的bounding box可能存在的碰撞。<br><img src="/images/article/Games104/10/Games104_10_32.png"><span class="image-caption">BVH树</span><br><img src="/images/article/Games104/10/Games104_10_33.png"><span class="image-caption">BVH树2</span></p><h4 id="排序和扫描"><a href="#排序和扫描" class="headerlink" title="排序和扫描"></a>排序和扫描</h4><p>sort and sweep是使用排序来检测碰撞的算法。 它的思想非常直观：对于使用AABB进行表示的bounding box，<br>两个bounding box出现碰撞时必然会导致它们的边界产生了重叠，而判断是否出现重叠则可以通过对bounding box的边界进行排序来进行计算。<br><img src="/images/article/Games104/10/Games104_10_34.png"><span class="image-caption">排序和扫描</span><br><img src="/images/article/Games104/10/Games104_10_35.png"><span class="image-caption">排序和扫描2</span></p><h3 id="窄相"><a href="#窄相" class="headerlink" title="窄相"></a>窄相</h3><p>筛选出可能发生碰撞的物体后就需要对它们进行实际的碰撞检测，这个阶段称为narrow phase。 除了进一步判断刚体是否相交外，<br>在narrow phase中一般还需要去计算交点、相交深度以及方向等信息。<br><img src="/images/article/Games104/10/Games104_10_36.png"><span class="image-caption">窄相的目标</span><br>目前在narrow phase中一般会使用相交测试、Minkowski距离以及分离轴等方法。<br><img src="/images/article/Games104/10/Games104_10_37.png"><span class="image-caption">窄相的方法</span></p><h4 id="基本形状相交测试"><a href="#基本形状相交测试" class="headerlink" title="基本形状相交测试"></a>基本形状相交测试</h4><p>对于一些简单的几何形状可以使用解析的方法来判断它们是否相交并且计算交点的信息。<br><img src="/images/article/Games104/10/Games104_10_38.png"><span class="image-caption">基本形状相交测试</span><br><img src="/images/article/Games104/10/Games104_10_39.png"><span class="image-caption">基本形状相交测试2</span><br><img src="/images/article/Games104/10/Games104_10_40.png"><span class="image-caption">基本形状相交测试3</span></p><h3 id="闵可夫斯基基于差分的方法"><a href="#闵可夫斯基基于差分的方法" class="headerlink" title="闵可夫斯基基于差分的方法"></a>闵可夫斯基基于差分的方法</h3><p>对于凸多边形的情况则可以使用<b>Minkowski差异(Minkowski distance)</b>来判断它们是否相交。<br>在介绍Minkowski距离之前首先要引入<b>Minkowski和(Minkowski sum)</b>的概念：<br>对于两个点集 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2953.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mi" transform="translate(2194.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>，它们的Minkowski和定义为两个集合中任意一对矢量相加后得到的新的点集。<br><img src="/images/article/Games104/10/Games104_10_41.png"><span class="image-caption">闵可夫斯基基于差分的方法</span><br><img src="/images/article/Games104/10/Games104_10_42.png"><span class="image-caption">闵可夫斯基和</span><br><img src="/images/article/Games104/10/Games104_10_43.png"><span class="image-caption">闵可夫斯基和2</span><br><img src="/images/article/Games104/10/Games104_10_44.png"><span class="image-caption">闵可夫斯基和3</span></p><p>对于凸多边形，它们的Minkowski和也必为一个凸多边形，而且这个新多边形的顶点也是原始多边形顶点的和。<br><img src="/images/article/Games104/10/Games104_10_45.png"><span class="image-caption">闵可夫斯基和凸多边形</span></p><p>在此基础上我们定义点集<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2953.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mi" transform="translate(2194.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>的Minkowski差异为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.188ex;" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>的Minkowski和，<br>即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.188ex;" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container> = <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.825ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4342.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mo" transform="translate(2027.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(2416.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3194.7,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(3953.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br><img src="/images/article/Games104/10/Games104_10_46.png"><span class="image-caption">闵可夫斯基差</span></p><p>可以证明当<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2953.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mi" transform="translate(2194.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>相交时，原点必位于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.188ex;" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>中。<br>这样判断两个凸多边形是否相交的问题就转化为判断原点是否位于凸多边形 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.188ex;" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>中的问题， 这种问题一般可以使用GJK算法来求解。<br><img src="/images/article/Games104/10/Games104_10_47.png"><span class="image-caption">起源和闵可夫斯基差异</span></p><p>GJK算法的主要流程如下:<br><img src="/images/article/Games104/10/Games104_10_48.png"><span class="image-caption">GJK算法</span><br><img src="/images/article/Games104/10/Games104_10_49.png"><span class="image-caption">GJK算法2</span><br><img src="/images/article/Games104/10/Games104_10_50.png"><span class="image-caption">GJK算法3</span><br><img src="/images/article/Games104/10/Games104_10_51.png"><span class="image-caption">GJK算法4</span><br><img src="/images/article/Games104/10/Games104_10_52.png"><span class="image-caption">GJK算法5</span></p><p>当GJK算法判断出两个凸多边形相交后还可以进一步计算交点以及深度等信息。<br><img src="/images/article/Games104/10/Games104_10_53.png"><span class="image-caption">GJK算法6</span><br><img src="/images/article/Games104/10/Games104_10_54.png"><span class="image-caption">GJK算法7</span><br><img src="/images/article/Games104/10/Games104_10_55.png"><span class="image-caption">GJK算法8</span><br>使用的方法为GJK算法。可以参考<a href="https://zhuanlan.zhihu.com/p/511164248">https://zhuanlan.zhihu.com/p/511164248</a></p><h3 id="分离轴定理（Separating-Axis-Theorem）"><a href="#分离轴定理（Separating-Axis-Theorem）" class="headerlink" title="分离轴定理（Separating Axis Theorem）"></a>分离轴定理（Separating Axis Theorem）</h3><p><b>分离轴定理(separating axis theorem, SAT)</b>同样是一种计算凸多边形相交的算法，<br>它的思想是平面上任意两个互不相交的图形我们必然可以找到一条直线将它们分隔在两端。<br>对于凸多边形还可以进一步证明必然存在以多边形顶点定义的直线来实现这样的分隔，<br>因此判断凸多边形相交就等价于寻找这样的分隔直线。<br><img src="/images/article/Games104/10/Games104_10_56.png"><span class="image-caption">SAT - 凸面</span><br><img src="/images/article/Games104/10/Games104_10_57.png"><span class="image-caption">SAT - 重叠的必要性</span><br><img src="/images/article/Games104/10/Games104_10_58.png"><span class="image-caption">SAT - 分离标准</span></p><p>使用SAT判断凸多边形是否相交时需要分别对两个图形的边进行遍历，然后判断另一个图形上的每个顶点是否落在边的同一侧。<br>只要发现存在一条边可以分隔两个图形即说明它们互不相交，否则继续遍历直到用尽所有的边，此时两个图形必然是相交的。<br><img src="/images/article/Games104/10/Games104_10_59.png"><span class="image-caption">SAT - 2D案例</span><br><img src="/images/article/Games104/10/Games104_10_60.png"><span class="image-caption">SAT - 2D案例2</span></p><p>当图形的位置发生变化时还可以从上一次检测得到的分离轴开始重新进行检测，这样可以进一步提高算法的效率。<br><img src="/images/article/Games104/10/Games104_10_61.png"><span class="image-caption">SAT - 2D案例优化</span></p><p>对于三维图形的情况则不仅需要考虑面和面的分隔关系，还要考虑边和边的分隔关系。<br><img src="/images/article/Games104/10/Games104_10_62.png"><span class="image-caption">SAT - 3D案例</span></p><h2 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h2><p>完成碰撞检测后就需要对发生碰撞的刚体进行处理，使它们相互分开。目前刚体的碰撞主要有三种处理思路，<br>分别是penalty force、velocity constraints以及position constraints，本节课我们主要介绍前两种处理方法。<br><img src="/images/article/Games104/10/Games104_10_63.png"><span class="image-caption">碰撞解决</span><br><img src="/images/article/Games104/10/Games104_10_64.png"><span class="image-caption">碰撞解决方法</span></p><h3 id="施加惩罚力（Applying-Penalty-Force）"><a href="#施加惩罚力（Applying-Penalty-Force）" class="headerlink" title="施加惩罚力（Applying Penalty Force）"></a>施加惩罚力（Applying Penalty Force）</h3><p><b>Penalty force</b>是最直观的碰撞处理方法，它的思想是当两个物体相交后沿反方向分别施加一个排斥力把它们推开。<br>这种方法要求设置比较大的排斥力以及很小的积分时间间隔，否则容易出现非常不符合直觉的碰撞效果，<br>因此现代物理引擎中几乎不会使用penalty force来处理刚体碰撞问题。<br><img src="/images/article/Games104/10/Games104_10_65.png"><span class="image-caption">施加惩罚力</span></p><h3 id="求解约束（Solving-Constraints）"><a href="#求解约束（Solving-Constraints）" class="headerlink" title="求解约束（Solving Constraints）"></a>求解约束（Solving Constraints）</h3><p>目前物理引擎中主流的刚体碰撞处理算法是基于Lagrangian力学的求解方法，它会把刚体之间的碰撞和接触转换为系统的约束，然后求解约束优化问题。<br><img src="/images/article/Games104/10/Games104_10_66.png"><span class="image-caption">求解约束</span><br><img src="/images/article/Games104/10/Games104_10_67.png"><span class="image-caption">求解约束2</span><br><img src="/images/article/Games104/10/Games104_10_68.png"><span class="image-caption">求解速度约束</span></p><h2 id="场景请求"><a href="#场景请求" class="headerlink" title="场景请求"></a>场景请求</h2><p>除了上面介绍过的内容外，在游戏中我们往往还需要对场景中的物体进行一些查询，这些查询操作也需要物理引擎的支持。</p><h3 id="光线投射（Raycast）"><a href="#光线投射（Raycast）" class="headerlink" title="光线投射（Raycast）"></a>光线投射（Raycast）</h3><p><b>Raycast</b>是非常基本的查询操作，我们希望能够获取某条射线在场景中击中的物体。实际上在光线追踪中就大量使用了raycast的相关操作，<br>而在物理引擎中raycast也有大量的应用，比如说子弹击中目标就是使用raycast来实现的。<br><img src="/images/article/Games104/10/Games104_10_69.png"><span class="image-caption">光线投射</span><br><img src="/images/article/Games104/10/Games104_10_70.png"><span class="image-caption">光线投射2</span><br><img src="/images/article/Games104/10/Games104_10_71.png"><span class="image-caption">光线投射3</span></p><h3 id="遮挡（Sweep）"><a href="#遮挡（Sweep）" class="headerlink" title="遮挡（Sweep）"></a>遮挡（Sweep）</h3><p><b>Sweep<b>与</b>Raycast</b>类似，不过在sweep中需要使用有一定几何形态的物体取击中场景中的其它物体<br><img src="/images/article/Games104/10/Games104_10_72.png"><span class="image-caption">遮挡</span><br><img src="/images/article/Games104/10/Games104_10_73.png"><span class="image-caption">遮挡2</span></p><h3 id="重叠（Overlap）"><a href="#重叠（Overlap）" class="headerlink" title="重叠（Overlap）"></a>重叠（Overlap）</h3><p>另一种常用的操作是<b>overlap</b>，此时我们需要判断场景中的物体是否位于某个几何形状中。overlap与碰撞检测非常类似，<br>不过overlap一般只会使用简单的几何体来进行检测。像游戏中爆炸效果的检测就是使用overlap来实现的。<br><img src="/images/article/Games104/10/Games104_10_74.png"><span class="image-caption">重叠</span><br><img src="/images/article/Games104/10/Games104_10_75.png"><span class="image-caption">重叠2</span></p><h3 id="碰撞组（Collision-Group）"><a href="#碰撞组（Collision-Group）" class="headerlink" title="碰撞组（Collision Group）"></a>碰撞组（Collision Group）</h3><p>在物理引擎中还需要额外注意对场景中的物体进行分组，这样可以提高各种物理仿真算法的效率。<br><img src="/images/article/Games104/10/Games104_10_76.png"><span class="image-caption">碰撞组</span></p><h2 id="效率、准确性与确定性"><a href="#效率、准确性与确定性" class="headerlink" title="效率、准确性与确定性"></a>效率、准确性与确定性</h2><h3 id="仿真优化（Simulation-Optimization）"><a href="#仿真优化（Simulation-Optimization）" class="headerlink" title="仿真优化（Simulation Optimization）"></a>仿真优化（Simulation Optimization）</h3><p>我们知道物理仿真是极其消耗计算资源的，如果在所有时刻都对场景中的物体进行模拟会造成计算资源的浪费。<br>因此一种常用的手段是把场景中的物体划分为若干个island，当island内没有外力作用时就对它们进行休眠，<br>这样就可以节约计算资源。<br><img src="/images/article/Games104/10/Games104_10_77.png"><span class="image-caption">仿真优化 - 堆</span><br><img src="/images/article/Games104/10/Games104_10_78.png"><span class="image-caption">仿真优化 - 休眠</span></p><h3 id="连续碰撞检测（Continuous-Collision-Detection-CCD）"><a href="#连续碰撞检测（Continuous-Collision-Detection-CCD）" class="headerlink" title="连续碰撞检测（Continuous Collision Detection - CCD）"></a>连续碰撞检测（Continuous Collision Detection - CCD）</h3><p>当物体运动的速度过快时可能会出现一个物体之间穿过另一个物体的现象，一种比较质朴的方法就是把墙等物体做的厚一点。<br>更规范的做法就是CCD：先计算一个安全时间（在这个时间内两个物体不会碰撞），然后开始一点点详细计算会不会碰撞，知道它们的距离小于一定阈值。<br><img src="/images/article/Games104/10/Games104_10_79.png"><span class="image-caption">连续碰撞检测</span><br><img src="/images/article/Games104/10/Games104_10_80.png"><span class="image-caption">连续碰撞检测2</span><br><img src="/images/article/Games104/10/Games104_10_81.png"><span class="image-caption">连续碰撞检测3</span><br><img src="/images/article/Games104/10/Games104_10_82.png"><span class="image-caption">连续碰撞检测4</span></p><h3 id="确定性模拟（Deterministic-Simulation）"><a href="#确定性模拟（Deterministic-Simulation）" class="headerlink" title="确定性模拟（Deterministic Simulation）"></a>确定性模拟（Deterministic Simulation）</h3><p>在进行物理仿真时还需要考虑仿真结果的确定性。尽管在编程时我们使用的都是同一套物理定律，<br>在程序运行阶段由于帧率、计算顺序以及浮点数精度等问题容易出现同一个场景在不同终端上产生不同的模拟结果。<br><img src="/images/article/Games104/10/Games104_10_83.png"><span class="image-caption">确定性模拟</span><br><img src="/images/article/Games104/10/Games104_10_84.png"><span class="image-caption">确定性模拟2</span></p><p>总而言之，物理仿真仍然是比较困难的。在现代游戏引擎中还有很多开放问题待我们进行解决。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://peng00bo00.github.io/2022/05/26/GAMES104-NOTES-10.html">参考文章1</a></p><p><a href="https://blog.csdn.net/Jason__Y/article/details/124986719">参考文章2</a></p><p><a href="https://www.bilibili.com/video/BV16U4y117VU/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture10_Physics%20System_Basic%20Concepts.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 高级动画技术：动画树、IK和表情动画（九）</title>
      <link href="/posts/649819f1.html"/>
      <url>/posts/649819f1.html</url>
      
        <content type="html"><![CDATA[<h2 id="动画混合（Animation-Blending）"><a href="#动画混合（Animation-Blending）" class="headerlink" title="动画混合（Animation Blending）"></a>动画混合（Animation Blending）</h2><p>上一章节提到，我们的动画是由一个个Clip（动作）组成的。当我们正在播放一个Clip时，想要切换到另一个Clip，<br>如果直接播放Clip，会显得不自然。这时就需要对两个Clip进行动画混合。</p><p>之前在计算Clip的每一帧状态时，是通过插值的方式处理的，Clip之间的混合也是类似的处理方式。<br>两个Clip的差值需要知道在多长时间内以怎样的权重完成Clip的切换。<br><img src="/images/article/Games104/09/Games104_09_01.png"><span class="image-caption">对齐混合时间轴</span><br>在制作动画时，动画最好能够有较好的衔接（第一帧与最后一帧保持一致，循环播放不穿帮）。</p><h2 id="混合空间"><a href="#混合空间" class="headerlink" title="混合空间"></a>混合空间</h2><h3 id="1D-2D-Blend"><a href="#1D-2D-Blend" class="headerlink" title="1D &amp; 2D Blend"></a>1D &amp; 2D Blend</h3><ul><li>1D Blend：通过一个参数对动画进行混合</li><li>2D Blend：通过两个参数对动画进行混合</li></ul><p>事实上当我们去插值动画的时候，并不局限于在两个clip中插值，也可以在多个动画clip中插值（比如直走、想左走以及向右走），<br>而且它们之间权重的设置也未必一定要均匀或线性插值，而blend space就是用来指导采样权重的东西。（在此处是一维Blend Space）<br><img src="/images/article/Games104/09/Games104_09_02.png"><span class="image-caption">1D Blend</span></p><p>玩家可以同时改变方向和速度，我们简单地将两个一维混合空间正交放置，我们得到一个二维混合空间，<br>由于实际需求上各个clip不一样（比如艺术家认为向左向右走时速度超过一个很低的阈值就直接进入跑的clip），<br>那么此时就无法像上图一样均匀插值，不同的clip在整个采样空间上的分布是不均匀的。<br><img src="/images/article/Games104/09/Games104_09_03.png"><span class="image-caption">2D Blend</span></p><h3 id="Skeleton-Masked-Blending"><a href="#Skeleton-Masked-Blending" class="headerlink" title="Skeleton Masked Blending"></a>Skeleton Masked Blending</h3><p>有时我们可能需要动画只对部分骨骼产生效果，例如角色边挥手边行走或者边挥手边边跳跃。<br>Masked Blending就是对骨骼进行遮罩的一种技术，这样就可以将多个动画进行组合。<br><img src="/images/article/Games104/09/Games104_09_04.png"><span class="image-caption">骨骼遮罩混合</span></p><h3 id="Additive-Blending"><a href="#Additive-Blending" class="headerlink" title="Additive Blending"></a>Additive Blending</h3><p>除了以上两种混合方式，有时我们可能还需要根据环境情况做出改变。例如角色朝着摄像机点头，这是就需要对动画附加一个旋转动画。<br><img src="/images/article/Games104/09/Games104_09_05.png"><span class="image-caption">添加混合</span></p><h2 id="动作状态机（Animation-State-Machine-ASM-）"><a href="#动作状态机（Animation-State-Machine-ASM-）" class="headerlink" title="动作状态机（Animation State Machine (ASM)）"></a>动作状态机（Animation State Machine (ASM)）</h2><h3 id="结构（Struct）"><a href="#结构（Struct）" class="headerlink" title="结构（Struct）"></a>结构（Struct）</h3><p>当我们在进行动画设计和融合的时候，会发现有些动画clip是存在逻辑关系的而不是可以任意插值的，<br>比如“跳”这个动作我们一般分为“起跳”、“滞空loop”以及”落地”三个部分，而且其存在明确的顺序关系。<br>因而ASM就被引入了进来。 ASM包含“节点node”和“变换transitions”。<br><img src="/images/article/Games104/09/Games104_09_06.png"><span class="image-caption">Jump动画根据离地高度进行动态调整</span></p><p><img src="/images/article/Games104/09/Games104_09_07.png"><span class="image-caption">ASM结构</span></p><h4 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h4><p>节点分为两类：clip和blend space。前者可以不止是指一个动画clip，也可以把一整个blend space打包成一个节点，<br>甚至可以把一个动画蓝图放进去当一个节点；当角色发生转变时进入另一个节点，而且这种转变是会自动发生，<br>举个例子：当人物进行跳这个动作时，相关的这个ASM就会被调用进入起跳状态，然后根据具体的判断标准，<br>角色会自动从一个状态节点切换到下一个状态节点，直到全部完成之后跳回到角色本身。</p><h4 id="变换Transitions"><a href="#变换Transitions" class="headerlink" title="变换Transitions"></a>变换Transitions</h4><p>转变本身是一个过程（函数），最简单就是表明从一个节点到另一个节点，当然也可能涉及到两个节点之间blending的问题，<br>即两者切换时不是突变，而是有一个时间间隔完成插值过渡，此时经常会用到经典的0.2秒。<br>另外，transitions的核心问题在于触发条件，比如跳到什么程度会从“起跳”节点进入“滞空loop”节点。<br>事实上，transitions的触发条件可能有多种。</p><h3 id="Cross-Fades"><a href="#Cross-Fades" class="headerlink" title="Cross Fades"></a>Cross Fades</h3><p>ASM内部的动画切换也有两种方式：smooth transition和frozen transition。smooth transition平滑得将两个动画随时间插值，<br>frozen transition会将原有动画暂停，并逐渐提高切换动画的比例。t通常会通过差值曲线进行转换。<br><img src="/images/article/Games104/09/Games104_09_08.png"><span class="image-caption">Cross Fades</span><br><img src="/images/article/Games104/09/Games104_09_09.png"><span class="image-caption">Cross Fades Curve</span></p><h3 id="分层状态机（Layered-ASM）"><a href="#分层状态机（Layered-ASM）" class="headerlink" title="分层状态机（Layered ASM）"></a>分层状态机（Layered ASM）</h3><p>Layered ASM与前面提到的遮罩概念近似，让不同的动画进行组合，独立控制部分骨骼，以达到更好的效果。<br><img src="/images/article/Games104/09/Games104_09_10.png"><span class="image-caption">Layered ASM</span></p><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>随着技术的发展，现在普遍使用的是动画混合树。<br><img src="/images/article/Games104/09/Games104_09_11.png"><span class="image-caption">Blend Tree</span></p><p>其中每个非叶节点的产出都是一个pose。<br>比较常用的操作有lerp（包括多个输入的lerp，此时它们的权重另外输入）、相加（addictive blend node）等。<br>因而不难发现，上述layered ASM本身也是动画树的一种情况。<br><img src="/images/article/Games104/09/Games104_09_12.png"><span class="image-caption">Blend Tree Nodes</span></p><p>动画树的一个特点是递归：<br>因为动画树中叶节点可以是单个动画clip、blend space已经ASM三种内容，所以导致其叶节点本身也可以是一个内含很多node的小动画树。</p><p>另外，动画树的核心作用是控制变量，动画树会定义大量变量暴露给外面的game play系统来进行控制，而这些变量的值决定了动画的混合行为。<br>通过这个设计，我们只需设置这些变量的值就可以决定动画实现。<br>变量有两种，一种是环境变量，比如有一个变量是角色当前血量，如果设定到了50%以下就切换成虚弱的动画。<br>还有一类变量类似于类的private data，通过event触发去进行调整。event概念引用于UE，即事件。<br>当某件事发生的时候，会改变动画树中的某些变量，从而影响动画混合效果。<br><img src="/images/article/Games104/09/Games104_09_13.png"><span class="image-caption">虚幻的动画蓝图控制</span></p><h2 id="IK技术（Inverse-Kinematics）"><a href="#IK技术（Inverse-Kinematics）" class="headerlink" title="IK技术（Inverse Kinematics）"></a>IK技术（Inverse Kinematics）</h2><p>上面介绍了常规动画的处理方式，但有一类动画是难以处理的。人伸手拿杯子、登上不同高度的阶梯，这类动画有一个特点：<br>在动画结束时需要特定骨骼移动到指定位置。在此需求上产生了两种处理方式：反向动力学（IK）和正向动力学（FK）。<br>IK是在最终效果骨骼确定的情况下，反推其它骨骼变动情况；而FK则是从Root节点，<br>逐步正向计算每个节点位置，以符合最终的效果。其中IK在游戏中使用较为常见<br><img src="/images/article/Games104/09/Games104_09_14.png"><span class="image-caption">IK基本概念</span></p><h3 id="Two-Bones-IK"><a href="#Two-Bones-IK" class="headerlink" title="Two Bones IK"></a>Two Bones IK</h3><p>Two Bones IK是指只有两个骨骼限制的IK，常见于人物行走在地面的效果。两个骨骼是指与地面接触的点以及大腿根部，这样就可以简单计算腿的弯曲角度。<br><img src="/images/article/Games104/09/Games104_09_15.png"><span class="image-caption">Two Bones IK 01</span></p><p>但这只是在二维平面上的结果，在三维空间中并不唯一，我们还需要对腿的朝向进行约束。<br><img src="/images/article/Games104/09/Games104_09_16.png"><span class="image-caption">Two Bones IK 02</span></p><h3 id="More-Complicated-IK-Scenarios"><a href="#More-Complicated-IK-Scenarios" class="headerlink" title="More Complicated IK Scenarios"></a>More Complicated IK Scenarios</h3><p>当有多条链的IK处理情况就变得极其复杂，难点：</p><ul><li>计算成本很高</li><li>自由度高，结果不唯一</li></ul><p><img src="/images/article/Games104/09/Games104_09_17.png"><span class="image-caption">Complexity of Multi-Joint IK Solving</span></p><p>此时首先要做的第一步是判断可达性，即先判断角色能不能到达目标位置。而不能达到分两种情况：</p><ul><li>全身所有骨骼加起来都没法碰到目标位置</li><li>全身所有其他骨骼加起来的总和与最长的骨骼比起来的差大于目标位置的位置。</li></ul><p><img src="/images/article/Games104/09/Games104_09_18.png"><span class="image-caption">Check Reachability of the Target</span></p><p>除了可达性判断外，另外很重要的一点是骨骼的旋转是受限的，尤其是人体，不同骨骼的旋转模式不一样。错误的处理会导致很离谱的扭曲。<br><img src="/images/article/Games104/09/Games104_09_19.png"><span class="image-caption">Constraints of Joints</span></p><h3 id="Cyclic-Coordinate-Decent-CCD"><a href="#Cyclic-Coordinate-Decent-CCD" class="headerlink" title="Cyclic Coordinate Decent (CCD)"></a>Cyclic Coordinate Decent (CCD)</h3><ul><li>规则：在已知最终首末两端位置情况下，从终点位置依次连接末端骨骼=&gt;起始骨骼，旋转所连接的骨骼，<br>使得末端骨骼处于两者连线上。最后尝试将末端骨骼移动至指定位置。</li><li>终止：可设置一定迭代次数，无限迭代问题</li><li>优化（每个节点旋转相对均匀）：可对旋转角度、距离目标点位置做限制</li></ul><p><img src="/images/article/Games104/09/Games104_09_20.png"><span class="image-caption">CCD</span><br><img src="/images/article/Games104/09/Games104_09_21.png"><span class="image-caption">CCD P1</span><br><img src="/images/article/Games104/09/Games104_09_22.png"><span class="image-caption">CCD P2</span></p><h3 id="Forward-And-Backward-Reaching-Inverse-Kinematics-FABRIK"><a href="#Forward-And-Backward-Reaching-Inverse-Kinematics-FABRIK" class="headerlink" title="Forward And Backward Reaching Inverse Kinematics (FABRIK)"></a>Forward And Backward Reaching Inverse Kinematics (FABRIK)</h3><ul><li>规则：依次使用FR和BR迭代计算骨骼位置，直到达到理想效果。FR:强制末端骨骼移动到指定位置，<br>再依次移动其它骨骼保证骨骼长度不变。BR则是从首端骨骼开始处理。</li></ul><p><img src="/images/article/Games104/09/Games104_09_23.png"><span class="image-caption">FABRIK</span><br><img src="/images/article/Games104/09/Games104_09_25.png"><span class="image-caption">FABRIK约束</span></p><h3 id="Multiple-End-Effectors"><a href="#Multiple-End-Effectors" class="headerlink" title="Multiple End-Effectors"></a>Multiple End-Effectors</h3><p>上面的算法解决了单条链的IK问题，但在复杂模型中往往存在多个终端点的情况。比如角色攀岩，就是将四肢附着在墙壁上。</p><ul><li>难点：各个附着点的链条相互影响</li><li>处理方式：为各链条设置优先级或者权重。（例如一个共享骨骼需要移动，最后更新的末端执行器将获得优先级，其他骨骼将被移除）</li></ul><p><img src="/images/article/Games104/09/Games104_09_24.png"><span class="image-caption">Multiple End-Effectors</span></p><h3 id="Jacobian-Matrix-IK"><a href="#Jacobian-Matrix-IK" class="headerlink" title="Jacobian Matrix IK"></a>Jacobian Matrix IK</h3><p>当控制点有很多时又会遇到不同问题（比如攀岩，同时需要设定的目标点不止一个）<br>因为当试图把一个点移到它的目标点时可能会让其他已经到位的节点又偏移开。<br>解决方法是：Jacobian Matrix（优化问题），在后续物理系统会详细介绍。<br><img src="/images/article/Games104/09/Games104_09_26.png"><span class="image-caption">Jacobian Matrix IK</span><br><img src="/images/article/Games104/09/Games104_09_27.png"><span class="image-caption">逐步接近目标</span></p><h3 id="其它IK解决方案"><a href="#其它IK解决方案" class="headerlink" title="其它IK解决方案"></a>其它IK解决方案</h3><p><img src="/images/article/Games104/09/Games104_09_28.png"><span class="image-caption">其它IK解决方案</span></p><h3 id="IK前沿问题"><a href="#IK前沿问题" class="headerlink" title="IK前沿问题"></a>IK前沿问题</h3><p>其中第一个是指IK是假设骨骼本身没体积的，但实际上是有的，尤其在蒙皮之后，所以会出现IK后骨骼自我穿插等问题。<br><img src="/images/article/Games104/09/Games104_09_29.png"><span class="image-caption">其它IK解决方案</span></p><h3 id="完整动画Pipeline"><a href="#完整动画Pipeline" class="headerlink" title="完整动画Pipeline"></a>完整动画Pipeline</h3><p><img src="/images/article/Games104/09/Games104_09_31.png"><span class="image-caption">完整动画Pipeline</span></p><h2 id="面部动画（Facial-Animation）"><a href="#面部动画（Facial-Animation）" class="headerlink" title="面部动画（Facial Animation）"></a>面部动画（Facial Animation）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>人的面部表情是很难表达的，细微的变化就可能表达出完全相反的含义。<br>骨骼动画虽然也可以处理面部表情，但即便是最简单的表情也需要花费大量的时间处理。<br><img src="/images/article/Games104/09/Games104_09_30.png"><span class="image-caption">面部是由复杂的肌肉系统驱动的</span></p><h3 id="Facial-Action-Coding-System"><a href="#Facial-Action-Coding-System" class="headerlink" title="Facial Action Coding System"></a>Facial Action Coding System</h3><p>FACS在基础表情库的基础上进行组合，表达其它表情。（40个 =&gt; 28个）<br><img src="/images/article/Games104/09/Games104_09_32.png"><span class="image-caption">简单混合的问题</span><br>所以不同于其他动画blending，一般业内使用Morph Target Animation。简单讲就是blending总是以additive的形式去融合，<br>比如直接在眼睛的位置上加上闭着的眼睛，而不会将睁着的眼睛和闭着的去做插值。 MF的问题是存储量大，并且随着表面细节增多计算量也会变很大</p><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><p><img src="/images/article/Games104/09/Games104_09_33.png"><span class="image-caption">Morph Target</span><br><img src="/images/article/Games104/09/Games104_09_34.png"><span class="image-caption">Complex Facial Skeleton</span><br><img src="/images/article/Games104/09/Games104_09_35.png"><span class="image-caption">UV Texture Facial Animation</span><br><img src="/images/article/Games104/09/Games104_09_36.png"><span class="image-caption">Muscle Model Animation</span></p><h2 id="动画重定向（Animation-Retargeting）"><a href="#动画重定向（Animation-Retargeting）" class="headerlink" title="动画重定向（Animation Retargeting）"></a>动画重定向（Animation Retargeting）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>作用：不同的骨骼需要表现相同的动作效果。<br><img src="/images/article/Games104/09/Games104_09_37.png"><span class="image-caption">在角色之间共享动画</span></p><p>术语<br><img src="/images/article/Games104/09/Games104_09_38.png"><span class="image-caption">Terminology</span></p><h3 id="Retargeting"><a href="#Retargeting" class="headerlink" title="Retargeting"></a>Retargeting</h3><p>此处默认source与target的骨骼结构相同。<br><img src="/images/article/Games104/09/Games104_09_39.png"><span class="image-caption">Retargeting</span></p><h3 id="Retargeting-IK"><a href="#Retargeting-IK" class="headerlink" title="Retargeting IK"></a>Retargeting IK</h3><p>即便使用了上述的方法，当两者骨骼比例差异过大，仍然会出现穿帮效果。例如同样的蹲在地上的动画，<br>由于大腿与小腿的比例差异，上述方法就会产生穿模，这时就需要使用IK来辅助解决。<br><img src="/images/article/Games104/09/Games104_09_40.png"><span class="image-caption">Retargeting IK</span></p><h3 id="Retargeting-with-Different-Skeleton-Hierarchy"><a href="#Retargeting-with-Different-Skeleton-Hierarchy" class="headerlink" title="Retargeting with Different Skeleton Hierarchy"></a>Retargeting with Different Skeleton Hierarchy</h3><p>上面的方法都要求source、target骨骼结构相同，但如果骨骼结构相似但不完全相同的情况下需要怎么处理呢？<br><img src="/images/article/Games104/09/Games104_09_41.png"><span class="image-caption">用不同的骨架层次结构进行重新定位</span></p><p>处理的方式有很多，一种较为简单的方法是规定骨骼名称相同的进行Retargeting处理。将中间没有Retargeting的骨骼归一化.<br><img src="/images/article/Games104/09/Games104_09_42.png"><span class="image-caption">简单的解决方案</span></p><h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p><img src="/images/article/Games104/09/Games104_09_43.png"><span class="image-caption">未解决的再定位问题</span><br><img src="/images/article/Games104/09/Games104_09_44.png"><span class="image-caption">变形动画重定向</span><br>表情领域的MF也面临动画重定向问题，具体做法有如利用拉普拉斯算子解决artifacts等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/article/Games104/09/Games104_09_45.png"><span class="image-caption">Take Away</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/546514925">参考文章1</a></p><p><a href="https://blog.csdn.net/Jason__Y/article/details/124841455">参考文章2</a></p><p><a href="https://www.bilibili.com/video/BV1pY411F7pA/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture%2009_Animation%20System-Advanced%20Animation%20Technology.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎的动画技术基础（八）</title>
      <link href="/posts/b1eb3151.html"/>
      <url>/posts/b1eb3151.html</url>
      
        <content type="html"><![CDATA[<h2 id="动画技术简介"><a href="#动画技术简介" class="headerlink" title="动画技术简介"></a>动画技术简介</h2><p>人类一直在试图代表运动中的物体<br><img src="/images/article/Games104/08/Games104_08_01.png"><span class="image-caption">壁画、陶瓷、神庙</span></p><p>序列帧和视觉残留（1/24 秒：翻页书、西洋镜）<br><img src="/images/article/Games104/08/Games104_08_02.png"><span class="image-caption">视觉残留</span></p><h3 id="电影中的动画技术发展"><a href="#电影中的动画技术发展" class="headerlink" title="电影中的动画技术发展"></a>电影中的动画技术发展</h3><ul><li>Zafari（2018）第一部用游戏引擎（Unreal）渲染出来的动画短片</li><li>手绘</li><li>骨骼动画，K帧</li><li>动作捕捉</li></ul><p><img src="/images/article/Games104/08/Games104_08_03.png"><span class="image-caption">电影动画技术</span></p><h3 id="游戏中的动画技术发展"><a href="#游戏中的动画技术发展" class="headerlink" title="游戏中的动画技术发展"></a>游戏中的动画技术发展</h3><ul><li>序列帧动画（Pac-Man（1980）、波斯王子（1989）、Doom（1993））</li><li>骨骼动画</li><li>蒙皮动画</li><li>物理动画</li></ul><p><img src="/images/article/Games104/08/Games104_08_04.png"><span class="image-caption">游戏中的动画技术01</span><br><img src="/images/article/Games104/08/Games104_08_05.png"><span class="image-caption">游戏中的动画技术02</span></p><h3 id="游戏动画挑战"><a href="#游戏动画挑战" class="headerlink" title="游戏动画挑战"></a>游戏动画挑战</h3><ol><li>要跟用户进行很多的互动动画（要和其他玩法系统协作、适配各种复杂环境）</li><li>实时的（要在1/30秒完成）</li><li>真实感的要求（表情动画、布娃娃系统、运动匹配系统（Motion Matching））</li></ol><p><img src="/images/article/Games104/08/Games104_08_06.png"><span class="image-caption">游戏动画的挑战01</span><br><img src="/images/article/Games104/08/Games104_08_07.png"><span class="image-caption">游戏动画的挑战02</span><br><img src="/images/article/Games104/08/Games104_08_08.png"><span class="image-caption">游戏动画的挑战03</span></p><h2 id="2D游戏动画技术"><a href="#2D游戏动画技术" class="headerlink" title="2D游戏动画技术"></a>2D游戏动画技术</h2><p>Sprite animation：通过多张图片连续播放获得的近似动画效果，早年红白机小霸王上的游戏大多此原理<br><img src="/images/article/Games104/08/Games104_08_09.png"><span class="image-caption">2D序列帧动画</span></p><p>Sprite-like animation：在前者基础上利用多个视角相机进行拍摄获得的更全面的图片信息，从而可以实现模拟3D的效果（Doom）<br><img src="/images/article/Games104/08/Games104_08_10.png"><span class="image-caption">2D模拟3D</span></p><p>根据角色的方向，播放指定的动画序列以达到模拟3D动画的效果。这种处理方式也可以用来模拟特效<br><img src="/images/article/Games104/08/Games104_08_11.png"><span class="image-caption">2D特效</span></p><p>Lived2D：是一种2D动画生成技术，处理非常简单。其核心思想是将动画对象进行拆分，对图元局部进行Transform以及spine变换以达到模拟局部动画效果。<br><img src="/images/article/Games104/08/Games104_08_12.png"><span class="image-caption">Lived2D</span></p><h2 id="3D游戏动画技术"><a href="#3D游戏动画技术" class="headerlink" title="3D游戏动画技术"></a>3D游戏动画技术</h2><h3 id="自由度"><a href="#自由度" class="headerlink" title="自由度"></a>自由度</h3><p>自由度（Degrees of Freedom）：系统对象可变化的基础维度。通常三维空间的物体自由度为6：三个维度上的偏移和三个维度上的旋转。<br><img src="/images/article/Games104/08/Games104_08_13.png"><span class="image-caption">DoF</span></p><h3 id="刚性层次动画"><a href="#刚性层次动画" class="headerlink" title="刚性层次动画"></a>刚性层次动画</h3><p>最基础的3D角色动画，就是有层次的（如树状）的刚体的运动，形式类似皮影戏和上面的Live2D。这种方法的问题是刚体间移动旋转时可能会出现缺缝。<br><img src="/images/article/Games104/08/Games104_08_14.png"><span class="image-caption">刚性层次动画</span></p><h3 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h3><p>如旗帜、水流的动画效果用刚体难以解决，所以使用3DoFs的顶点动画，计算每一帧下每个顶点的空间位置的变化，<br>一般存成两个texture，第一张的x轴是所有顶点的序号，y轴是帧的数量，位置（x, y）则是某顶点在某帧下空间位置变化的offset；<br>第二张图是记录顶点的法向量，因为随着位置的变化，法向也会变化。这两张图都会利用物理引擎先预计算保存。缺点是数据量会很大。<br><img src="/images/article/Games104/08/Games104_08_15.png"><span class="image-caption">顶点动画</span></p><h3 id="Morph-Target-Animation"><a href="#Morph-Target-Animation" class="headerlink" title="Morph Target Animation"></a>Morph Target Animation</h3><p>顶点动画的一种变型，不同的是顶点影响权重。通常用于表情动画，对两个key frame进行插值。<br><img src="/images/article/Games104/08/Games104_08_16.png"><span class="image-caption">顶点动画</span></p><h3 id="2D-3D-蒙皮动画"><a href="#2D-3D-蒙皮动画" class="headerlink" title="2D &amp; 3D 蒙皮动画"></a>2D &amp; 3D 蒙皮动画</h3><p>3D角色是动画通常是通过骨骼来驱动的，骨骼所影响的皮肤通常不会的静态的，Mesh会随着骨骼的运动而变化。处理这种问题的技术称为蒙皮骨骼动画。<br><img src="/images/article/Games104/08/Games104_08_17.png"><span class="image-caption">3D蒙皮动画</span></p><p>2D也可以使用同样的原理进行处理<br><img src="/images/article/Games104/08/Games104_08_18.png"><span class="image-caption">2D蒙皮动画</span></p><h3 id="Physics-based-Animation"><a href="#Physics-based-Animation" class="headerlink" title="Physics-based Animation"></a>Physics-based Animation</h3><p>基于物理的动画，常见于三个方面：Ragdoll，即人从高空坠地时的一些动画，往往部分由艺术家设计实现，部分还需考虑物理原理（自由落体以及坠地瞬间）；<br>衣料的动画；Inverse Kinematics（IK）反向运动学，比如攀爬时如何让这个抓取过程更合理。<br><img src="/images/article/Games104/08/Games104_08_19.png"><span class="image-caption">基于物理的动画</span></p><h3 id="Animation-Content-Creation"><a href="#Animation-Content-Creation" class="headerlink" title="Animation Content Creation"></a>Animation Content Creation</h3><ul><li>在专业软件中通过key frame来插值处理</li><li>动捕技术</li></ul><p><img src="/images/article/Games104/08/Games104_08_20.png"><span class="image-caption">动画制作方式</span></p><h2 id="蒙皮动画实现"><a href="#蒙皮动画实现" class="headerlink" title="蒙皮动画实现"></a>蒙皮动画实现</h2><h3 id="Mesh如何运动"><a href="#Mesh如何运动" class="headerlink" title="Mesh如何运动"></a>Mesh如何运动</h3><ol><li>为一个Pos创建Mesh</li><li>为Mesh绑定骨骼（骨骼影响哪些顶点）</li><li>设置骨骼的影响权重</li><li>将骨架设置为所需姿势的动画</li><li>通过骨架和蒙皮权重设置蒙皮顶点的动画</li></ol><p>看似简单，但如果顶点的权重设置不合理，模型一动起来可能就炸了。<br><img src="/images/article/Games104/08/Games104_08_21.png"><span class="image-caption">Mesh如何运动</span></p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><ul><li>World space：包含所有物体的坐标系。</li><li>Model space：模型制作的时的坐标系。</li><li>Local space：当有其它物体相对于自身表示时的坐标系，骨骼的计算也是在这一坐标系中进行的。</li></ul><p><img src="/images/article/Games104/08/Games104_08_22.png"><span class="image-caption">坐标系</span></p><h3 id="生物骨骼"><a href="#生物骨骼" class="headerlink" title="生物骨骼"></a>生物骨骼</h3><p>动画师在设计骨骼时，根据需求通常会有一套标准的骨骼，在此基础上进行角色动画的制作。<br>这些骨骼由一系列的刚性joint组成，两个joint可以为一根骨骼（Bone）。所有的joint都附属于root节点，通常处于角色的底部。<br><img src="/images/article/Games104/08/Games104_08_23.png"><span class="image-caption">生物骨骼01</span><br><img src="/images/article/Games104/08/Games104_08_24.png"><span class="image-caption">生物骨骼02</span></p><h3 id="人物骨架"><a href="#人物骨架" class="headerlink" title="人物骨架"></a>人物骨架</h3><p>游戏中的人物，除了标准的骨骼，还会有许多附加的骨骼。比如穿着斗篷、拿着武器以及表情动画，都会有额外骨骼的需求。<br><img src="/images/article/Games104/08/Games104_08_25.png"><span class="image-caption">人物骨架</span></p><h3 id="对象的绑定动画"><a href="#对象的绑定动画" class="headerlink" title="对象的绑定动画"></a>对象的绑定动画</h3><p>游戏中常见一种动画就是骑乘，比如开车、骑马。骑乘状态下的角色会随着载具一起运动，那么两者之间就必须有一个连接点来保持两者的关系。<br><img src="/images/article/Games104/08/Games104_08_27.png"><span class="image-caption">对象的绑定动画</span></p><h3 id="T-Pos-A-Pos"><a href="#T-Pos-A-Pos" class="headerlink" title="T-Pos &amp; A-Pos"></a>T-Pos &amp; A-Pos</h3><p>T-Pos与A-Pos是在制作人物骨骼动画时常见的两种pos。<br>T-Pos在处理肩部的有一定的肌肉挤压，会造成对这部分的骨骼权重精度不足。A-Pos更符合制作的需求。<br><img src="/images/article/Games104/08/Games104_08_26.png"><span class="image-caption">T-Pos &amp; A-Pos</span></p><h2 id="3D旋转的数学原理"><a href="#3D旋转的数学原理" class="headerlink" title="3D旋转的数学原理"></a>3D旋转的数学原理</h2><h3 id="欧拉角（Euler-Angle）"><a href="#欧拉角（Euler-Angle）" class="headerlink" title="欧拉角（Euler Angle）"></a>欧拉角（Euler Angle）</h3><p>可以通过绕xyz旋转的矩阵相乘来获取最终效果。<br>另一种表达欧拉角的方式是Yaw, Roll和Pitch，分别指水平的旋转、左右侧向高低变化以及抬头低头的变化。<br><img src="/images/article/Games104/08/Games104_08_28.png"><span class="image-caption">2D旋转矩阵</span><br><img src="/images/article/Games104/08/Games104_08_29.png"><span class="image-caption">3D欧拉角旋转矩阵</span></p><p>欧拉角存在的问题：</p><ul><li>顺序依赖，即换一种绕不同轴旋转的顺序会导致最终旋转结果不同。所以一般规定必须xyz顺序。</li><li>欧拉角存在“退化”问题，即当固定绕一个轴旋转时，其他两个轴就退化成同一个内容了，比如绕z轴转动时，x和y的地位就相同了，此时DoF实际上只有1度了。</li><li>插值困难。给定两组旋转角度时，很难计算它们之间的插值结果，不能简单线性插值。</li><li>很难绕其他任意特定轴旋转。</li></ul><p><img src="/images/article/Games104/08/Games104_08_31.png"><span class="image-caption">旋转插值</span><br><img src="/images/article/Games104/08/Games104_08_30.png"><span class="image-caption">欧拉角存在的问题</span></p><h3 id="四元数（Quaternion）"><a href="#四元数（Quaternion）" class="headerlink" title="四元数（Quaternion）"></a>四元数（Quaternion）</h3><p>出于上述缺点，实际游戏制作中不太用欧拉角，反而用Quaternion会比较多。<br>其基于利用复数解决二维旋转问题的方法。<br><img src="/images/article/Games104/08/Games104_08_32.png"><span class="image-caption">复数和二维旋转</span></p><p>进一步提升到三维空间后<br><img src="/images/article/Games104/08/Games104_08_33.png"><span class="image-caption">四元数向量运算基础</span><br>比较值得注意的是<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="23.706ex" height="2.461ex" role="img" focusable="false" viewBox="0 -883.9 10477.9 1087.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(378,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1059.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(2115.1,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mn" transform="translate(445,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3241.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(4297.2,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(5532.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(6588.3,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6933.3,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mi" transform="translate(7345.3,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(8144.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(9199.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(9977.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container><br>这个式子，从中可以得出 ij = k, ik = j, jk = i 的事实。从而便于理解后面两个旋转的累积结果的矩阵。<br>与二维的复数一样，这个四元数也有共轭和互逆的概念。<br><img src="/images/article/Games104/08/Games104_08_34.png"><span class="image-caption">欧拉角转Quaternion</span></p><p><img src="/images/article/Games104/08/Games104_08_35.png"><span class="image-caption">Quaternion旋转</span></p><p>其中q是指旋转的四元数，v’ 是v进行q旋转后的结果<br>对上式进行计算优化后，结果可以表示为<br><img src="/images/article/Games104/08/Games104_08_36.png"><span class="image-caption">四元数到旋转矩阵</span></p><p>在以上基础上，利用四元数可以表示很多三维空间的旋转，包括反旋转、旋转的结合以及从当前方向u到指定方向v的旋转函数计算等<br><img src="/images/article/Games104/08/Games104_08_37.png"><span class="image-caption">四元数旋转数学</span></p><p>四元数还有一个应用就是围绕任意固定轴旋转，其中u就是那个指定轴的单位坐标，q就是与这个轴和旋转角度相关的一个旋转四元数，v’即v旋转后的结果。<br><img src="/images/article/Games104/08/Games104_08_38.png"><span class="image-caption">任意轴Quaternion旋转</span></p><h2 id="关节与蒙皮"><a href="#关节与蒙皮" class="headerlink" title="关节与蒙皮"></a>关节与蒙皮</h2><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>关节的Pose有三个维度：Orientation、Position和Scale</p><h4 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a>Orientation</h4><p><img src="/images/article/Games104/08/Games104_08_39.png"><span class="image-caption">方向</span></p><h4 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h4><p><img src="/images/article/Games104/08/Games104_08_40.png"><span class="image-caption">定位</span></p><h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p><img src="/images/article/Games104/08/Games104_08_41.png"><span class="image-caption">比例</span></p><p>合并起来形成了Affine Matrix<br><img src="/images/article/Games104/08/Games104_08_42.png"><span class="image-caption">Transfrom矩阵</span></p><h3 id="骨骼动画-蒙皮"><a href="#骨骼动画-蒙皮" class="headerlink" title="骨骼动画 &amp; 蒙皮"></a>骨骼动画 &amp; 蒙皮</h3><p>骨骼动画中所有的骨骼变动都是基于局部坐标系（旋转时能够保证骨骼大小不变），也就是和父节点相关。<br>所有骨骼的变动是逐步叠加的结果。骨骼动画需要存储model space下，关键帧root =&gt; joint的变换矩阵。<br><img src="/images/article/Games104/08/Games104_08_43.png"><span class="image-caption">从局部空间到模型空间</span></p><p>在处理骨骼蒙皮时，会记录皮肤Mesh顶点相对绑定骨骼的位置，这样皮肤就能跟随骨骼运动。<br>在处理骨骼蒙皮时，只需要知道Mesh顶点在model space的坐标和绑定矩阵，就可以知道蒙皮顶点相对Joint的局部坐标。<br><img src="/images/article/Games104/08/Games104_08_44.png"><span class="image-caption">蒙皮矩阵01</span><br><img src="/images/article/Games104/08/Games104_08_45.png"><span class="image-caption">蒙皮矩阵02</span></p><p>通常骨骼的数量很少，蒙皮顶点的数量很多，因此不可能每次计算蒙皮顶点时都计算骨骼的转化矩阵。在计算骨骼动画时，<br>先计算好某一时刻的骨骼动画，再计算所有的蒙皮矩阵。在计算实际的顶点时，是在世界空间下处理，因此可以将这部分骨骼矩阵计算好，再处理蒙皮效果。<br><img src="/images/article/Games104/08/Games104_08_46.png"><span class="image-caption">蒙皮矩阵调色板</span></p><h3 id="Clip插值"><a href="#Clip插值" class="headerlink" title="Clip插值"></a>Clip插值</h3><p>一个动画Clip是由一些关键帧组成的，关键帧之间由两个关键帧的数据插值计算，由此获得较为平滑的动作。<br>对弈简单的差值，比如位置就可以直接进行差值，但上面提到的角度差值就相对麻烦。<br><img src="/images/article/Games104/08/Games104_08_47.png"><span class="image-caption">简单插值</span></p><p>对于角度来说，最直观的线性插值（q1 -&gt; q2直线），但旋转需要保证半径不变，因此要对对线性插值结果标准化处理（NLERP）。<br>缺点：角度变化不均匀，中间慢，两边慢。<br><img src="/images/article/Games104/08/Games104_08_48.png"><span class="image-caption">旋转的四元数插值</span></p><p>最短路径插值：从一个角度移动到另一个角度，对于每个维度来说都有两种变化方式，而符合人直观的插值是最短路径插值。<br>通过四元数点乘的正负值；方向向量的叉乘正负值来处理旋转方向。<br><img src="/images/article/Games104/08/Games104_08_49.png"><span class="image-caption">最短路径插值</span></p><p>SLERP：先计算旋转角度，对角度进行差值计算位置。优点：变化均匀。<br>缺点：计算量略高（反三角函数）；旋转角度很小时，计算结果不稳定。<br><img src="/images/article/Games104/08/Games104_08_50.png"><span class="image-caption">SLERP</span></p><p>混合处理：设定一个角度阈值，当夹角小于阈值时，使用NLERP;当角度大于阈值时，使用SLERP。<br><img src="/images/article/Games104/08/Games104_08_51.png"><span class="image-caption">NLERP VS SLERP</span></p><h3 id="动画管线"><a href="#动画管线" class="headerlink" title="动画管线"></a>动画管线</h3><p>基础动画管线：根据时间插值计算当前帧的Pos =&gt; 计算蒙皮Mesh =&gt; GPU渲染。<br>现代动画管线：大部分CPU计算放到GPU处理。<br><img src="/images/article/Games104/08/Games104_08_52.png"><span class="image-caption">基础动画管线</span></p><h2 id="动画技术压缩"><a href="#动画技术压缩" class="headerlink" title="动画技术压缩"></a>动画技术压缩</h2><p>动画需要处理的数据很多，会占用大量的存储空间，若不就行压缩处理，难以在硬件设备上运行。<br><img src="/images/article/Games104/08/Games104_08_53.png"><span class="image-caption">动画数据大小</span></p><h3 id="简单压缩"><a href="#简单压缩" class="headerlink" title="简单压缩"></a>简单压缩</h3><p>如果存下所有节点每秒比如三十帧的数据，会导致数据量过大没法使用，所以必须进行压缩。<br>第一步是进行DoF的压缩，我们可以发现，对大部分节点来说，其scale不怎么变化，所以可以直接去掉（除了脸部节点）；<br>同时，节点的translate也不怎么动，只需要存储固定值（除了骨盆和脸部节点）。<br><img src="/images/article/Games104/08/Games104_08_54.png"><span class="image-caption">自由度降低</span></p><h3 id="关键帧与插值曲线"><a href="#关键帧与插值曲线" class="headerlink" title="关键帧与插值曲线"></a>关键帧与插值曲线</h3><p>针对旋转，比较简单的方法是使用关键帧Key Frame进行插值，当插值误差小于一定阈值时就设为关键帧，<br>不然就把这插值对应的GT帧加入关键帧再继续细分。因而关键帧的间隔不是固定的。<br><img src="/images/article/Games104/08/Games104_08_55.png"><span class="image-caption">关键帧</span></p><p>关键帧的结果虽然不错，但仍然是一条折线。所以又提出了Catmull-Rom Spline：在两帧P1P2之外分别再取P0P3，然后拟合这个曲线即可。<br><img src="/images/article/Games104/08/Games104_08_56.png"><span class="image-caption">Catmull-Rom Spline</span></p><h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p><img src="/images/article/Games104/08/Games104_08_57.png"><span class="image-caption">浮点量化</span><br>对已知范围的浮点数映射到0~1之间，可以增加数据的精度。对于四元数可利用归一化的特性，只存储三个绝对值较小的数据，这三个值处于一定范围内。<br>这样只需要2bit存储最大值的位置，其余每位15bit，共48bit。<br><img src="/images/article/Games104/08/Games104_08_58.png"><span class="image-caption">四元数量化01</span><br><img src="/images/article/Games104/08/Games104_08_59.png"><span class="image-caption">四元数量化02</span></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>压缩虽然好用，但会带来误差累积问题。所以需要检测误差是不是被控制在可接受范围内。<br>最实际可用的误差是visual error视觉误差，但如果对比压缩前后每顶点的误差则计算量太大，所以实际中针对每一个节点joint进行估计：<br>对节点估计两个互相垂直方向上的点，距离设置为offset（如果精度敏感则offset大一点，如果不敏感或小骨骼的话就offset小一点），<br>这样只需要比较两个点在压缩前后的error即可<br><img src="/images/article/Games104/08/Games104_08_60.png"><span class="image-caption">误差传播</span></p><p>Error Compensation：在多帧误差累积后反向进行偏移来补偿。其问题就是这一帧和上一帧会很不连贯。<br><img src="/images/article/Games104/08/Games104_08_61.png"><span class="image-caption">偏移补偿</span></p><h2 id="动画技术流程"><a href="#动画技术流程" class="headerlink" title="动画技术流程"></a>动画技术流程</h2><h3 id="Mesh-building"><a href="#Mesh-building" class="headerlink" title="Mesh building"></a>Mesh building</h3><p><img src="/images/article/Games104/08/Games104_08_62.png"><span class="image-caption">网状结构</span></p><h3 id="Skeleton-Binding"><a href="#Skeleton-Binding" class="headerlink" title="Skeleton Binding"></a>Skeleton Binding</h3><p>DCC软件通常自带预制骨架，美术可以手动将骨骼附加到指定到Mesh位置。<br><img src="/images/article/Games104/08/Games104_08_64.png"><span class="image-caption">骨架图</span></p><h3 id="Skinning"><a href="#Skinning" class="headerlink" title="Skinning"></a>Skinning</h3><p><img src="/images/article/Games104/08/Games104_08_63.png"><span class="image-caption">蒙皮</span></p><h3 id="Animation-Creation"><a href="#Animation-Creation" class="headerlink" title="Animation Creation"></a>Animation Creation</h3><p><img src="/images/article/Games104/08/Games104_08_65.png"><span class="image-caption">动画创作</span></p><h3 id="Exporting"><a href="#Exporting" class="headerlink" title="Exporting"></a>Exporting</h3><p>在DCC软件中完成动画资源制作后，需要将资源导出到游戏引擎中使用。这其中就有许多细节又要注意：</p><ul><li>尺寸单位一致性</li><li>坐标系一致性</li><li>是否附带位移曲线</li></ul><p><img src="/images/article/Games104/08/Games104_08_66.png"><span class="image-caption">导出</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/537220623">参考文章1</a></p><p><a href="https://blog.csdn.net/Jason__Y/article/details/124731287">参考文章2</a></p><p><a href="https://www.bilibili.com/video/BV1jr4y1t7WR/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频1</a></p><p><a href="https://www.bilibili.com/video/BV1fF411j7hA/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture%2008_Animation%20System%20-%20Basics%20of%20Animation%20Technology.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏中渲染管线、后处理和其他的一切（七）</title>
      <link href="/posts/ed8f511c.html"/>
      <url>/posts/ed8f511c.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境光遮蔽（Ambient-Occlusion）"><a href="#环境光遮蔽（Ambient-Occlusion）" class="headerlink" title="环境光遮蔽（Ambient Occlusion）"></a>环境光遮蔽（Ambient Occlusion）</h2><p>在之前的章节中，我们提到过对于阴影的处理，但有一种阴影是难以通过这种方式来处理的——物体自身局部对光线的遮挡，<br>比如人物眼角对皮肤、鼻子对面部的遮挡阴影。虽然从理论上来说，这种阴影也符合光照方程，但由于其局部遮挡的特性，<br>在统一的光照模型处理中很难得到较好的效果。<br><img src="/images/article/Games104/07/Games104_07_01.png"><span class="image-caption">Ambient Occlusion</span></p><h3 id="预计算环境光遮蔽（Precomputed-AO）"><a href="#预计算环境光遮蔽（Precomputed-AO）" class="headerlink" title="预计算环境光遮蔽（Precomputed AO）"></a>预计算环境光遮蔽（Precomputed AO）</h3><p>Precomputed AO思想是将AO信息存储在角色纹理中，这样即使我们没有AO真正对应的网格结构，<br>也可以有较好的AO效果。这也是现在很多商业项目使用的方法。<br><img src="/images/article/Games104/07/Games104_07_02.png"><span class="image-caption">Precomputed AO</span><br>其特点也很明显：</p><ol><li>无需几何上的遮蔽关系；</li><li>需要额外的纹理存储信息；</li><li>只能处理静态对象。</li></ol><h3 id="屏幕空间环境遮挡（Screen-Space-Ambient-Occlusion-SSAO-）"><a href="#屏幕空间环境遮挡（Screen-Space-Ambient-Occlusion-SSAO-）" class="headerlink" title="屏幕空间环境遮挡（Screen Space Ambient Occlusion+  - SSAO+）"></a>屏幕空间环境遮挡（Screen Space Ambient Occlusion+  - SSAO+）</h3><p>SSAO的思想是将是对屏幕像素进行局部空间采样，计算点可显示的概率，作为最终颜色的比例系数。<br><img src="/images/article/Games104/07/Games104_07_03.png"><span class="image-caption">SSAO</span></p><p>SSAO采样时使用的是球体区域采样，但实际我们看到一个平面时，可视区域只有半球。因此对其进行优化后改为SSAO+的方式进行处理：</p><ol><li>沿法线方向在视图空间生成半球面；</li><li>多次区域采样，判断是否被遮蔽，计算颜色衰减比例。</li></ol><p><img src="/images/article/Games104/07/Games104_07_04.png"><span class="image-caption">SSAO+</span></p><p>相比Precomputed AO优点：动态处理AO效果</p><p>相比Precomputed AO缺点：</p><ol><li>实时计算量较大；</li><li>需要有真实的遮蔽结构；</li><li>AO判断错误（当一个像素覆盖的深度很大也就是距离摄像机很远时，用球面进行采样计算覆盖的区域很大，很可能不是局部遮挡关系了，<br>不应该进行处理。屏幕空间没有几何信息，因此无法判断采样区域内的对象关系，应该可以设定阈值进行一定的优化）</li></ol><h3 id="基于地平线的环境光遮蔽（Horizon-basedAmbient-Occlusion-HBAO）"><a href="#基于地平线的环境光遮蔽（Horizon-basedAmbient-Occlusion-HBAO）" class="headerlink" title="基于地平线的环境光遮蔽（Horizon-basedAmbient Occlusion - HBAO）"></a>基于地平线的环境光遮蔽（Horizon-basedAmbient Occlusion - HBAO）</h3><p>HBAO假设各个方向上的光贡献相同（这也是算法的缺陷），对SSAO+在计算衰减比例上做了简化：区域采样点计算比例 =&gt; 积分切面最大仰角<br><img src="/images/article/Games104/07/Games104_07_05.png"><span class="image-caption">HBAO</span></p><h3 id="基于地面实况的环境遮挡（Ground-Truth-based-Ambient-Occlusion-GTAO）"><a href="#基于地面实况的环境遮挡（Ground-Truth-based-Ambient-Occlusion-GTAO）" class="headerlink" title="基于地面实况的环境遮挡（Ground Truth-based Ambient Occlusion - GTAO）"></a>基于地面实况的环境遮挡（Ground Truth-based Ambient Occlusion - GTAO）</h3><p>具体来说，GTAO在HBAO的基础上移除了随着距离衰减的可见性函数，转而使用一个常量1作为可见性（不过恢复了正常积分中的光线与法线之间的余弦项），<br>为了避免硬切导致的瑕疵，会考虑添加一个从一个较大的距离到最大的采样半径上使用一个从1到0的线性混合权重。为了模拟near-field的interreflection，<br>则是通过对多个具有代表性的场景在不同的albedo作用下的GI跟AO之间的数值关系进行匹配映射，得到了两者之间的关系的解析模拟解。<br><img src="/images/article/Games104/07/Games104_07_06.png"><span class="image-caption">GTAO</span></p><h3 id="光线追踪环境光遮蔽（Ray-Tracing-Ambient-Occlusion）"><a href="#光线追踪环境光遮蔽（Ray-Tracing-Ambient-Occlusion）" class="headerlink" title="光线追踪环境光遮蔽（Ray-Tracing Ambient Occlusion）"></a>光线追踪环境光遮蔽（Ray-Tracing Ambient Occlusion）</h3><p>基于RTX的硬件，每个像素发出一些射线来进行遮蔽检测来计算AO情况。<br><img src="/images/article/Games104/07/Games104_07_07.png"><span class="image-caption">Ray-Tracing Ambient Occlusion</span></p><h2 id="雾效（Fog）"><a href="#雾效（Fog）" class="headerlink" title="雾效（Fog）"></a>雾效（Fog）</h2><p>Fog越浓，透明度约低。</p><h3 id="深度雾效（Depth-Fog）"><a href="#深度雾效（Depth-Fog）" class="headerlink" title="深度雾效（Depth Fog）"></a>深度雾效（Depth Fog）</h3><p>Depth Fog假设空间中充满了均匀的Fog，那么我们就只需要根据Depth缓冲就可以计算看到物体的透明度了。<br>常见的Fog透明度计算方式有三种：线性、指数、指数平方（最常用）。<br><img src="/images/article/Games104/07/Games104_07_08.png"><span class="image-caption">Depth Fog</span></p><h3 id="高度雾效（Height-Fog）"><a href="#高度雾效（Height-Fog）" class="headerlink" title="高度雾效（Height Fog）"></a>高度雾效（Height Fog）</h3><p>Height Fog用来处理与高度相关的Fog，例如从山脚向上看，可以看到雾效；但在山顶缺看不到雾效。<br><img src="/images/article/Games104/07/Games104_07_09.png"><span class="image-caption">Height Fog</span></p><h3 id="体积雾（Volumetric-Fog）"><a href="#体积雾（Volumetric-Fog）" class="headerlink" title="体积雾（Volumetric Fog）"></a>体积雾（Volumetric Fog）</h3><p>以上两种方式的Fog都是在屏幕空间进行处理的，这样有些效果就难以处理了，比如幽暗的环境，一束光透过fog。这就需要体积雾来处理了。</p><p>体积雾根据视锥与摄像机的远近，对空间进行划分（近处密）。对切分后的视锥进行Ray Matching等计算，处理方式与云的处理类似。<br><img src="/images/article/Games104/07/Games104_07_10.png"><span class="image-caption">Volumetric Fog</span></p><h2 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h2><p>走样的原因：想要表达的东西太细，但是采样频率不足。大概分为三类：</p><ul><li>边缘的采样</li><li>纹理的采样</li><li>高光的采样</li></ul><p><img src="/images/article/Games104/07/Games104_07_11.png"><span class="image-caption">走样的原因</span></p><h3 id="Anti-aliasing"><a href="#Anti-aliasing" class="headerlink" title="Anti-aliasing"></a>Anti-aliasing</h3><p>常用解决方案就是：多采样获取更多的样本，然后对样本进行加权和求和，以产生一个像素颜色<br><img src="/images/article/Games104/07/Games104_07_12.png"><span class="image-caption">Anti-aliasing</span></p><h3 id="Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA"><a href="#Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA" class="headerlink" title="Super-sample AA (SSAA) and Multi-sample AA (MSAA)"></a>Super-sample AA (SSAA) and Multi-sample AA (MSAA)</h3><p>SSAA是通过绘制一个高分辨率的图像做一下滤波变成低分辨率的结果，处理步骤如下：</p><ol><li>在一个像素内取若干个子采样点；</li><li>对子像素点进行颜色计算（采样）；</li><li>根据子像素的颜色和位置，利用一个称之为resolve的合成阶段，计算当前像素的最终颜色输出</li></ol><p>MSAA优化了SSAA的着色次数：每个像素只着色一次，根据子像素覆盖情况，将着色的数据复制到相应的Color位置。<br><img src="/images/article/Games104/07/Games104_07_13.png"><span class="image-caption">SSAA and MSAA</span></p><h3 id="FXAA（Fast-Approximate-Anti-aliasing）"><a href="#FXAA（Fast-Approximate-Anti-aliasing）" class="headerlink" title="FXAA（Fast Approximate Anti-aliasing）"></a>FXAA（Fast Approximate Anti-aliasing）</h3><p>核心思想：提取边缘像素；将边缘像素与周围像素混合。<br><img src="/images/article/Games104/07/Games104_07_14.png"><span class="image-caption">FXAA</span></p><p>为了判断边缘像素法线方向，通常会计算自身以及周围像素（8个）亮度，计算其中最大值与最小值之差作为判断依据。<br>（亮度不同的地方，以不同的阈值判断，缓解局部高频信息丢失）<br><img src="/images/article/Games104/07/Games104_07_15.png"><span class="image-caption">卷积计算偏移方向</span></p><p>在确定像素边缘方向之后，就需要进一步确定边缘的法线方向。处理思路如下：若边缘为水平方向，则判断上下像素与自身像素亮度的差值；<br>若边缘为垂直方向，则判断左右像素与自身像素亮度的差值。(法线朝向亮度变化大的方向)<br><img src="/images/article/Games104/07/Games104_07_16.png"><span class="image-caption">边缘搜索算法</span></p><p>FXAA算法在颜色混合时，首先会计算当前像素处于边线中的比例位置。然后根据比例位置，对当前像素的uv做偏移。<br><img src="/images/article/Games104/07/Games104_07_17.png"><span class="image-caption">计算混合系数</span></p><h3 id="TAA（Temporal-Anti-aliasing）"><a href="#TAA（Temporal-Anti-aliasing）" class="headerlink" title="TAA（Temporal Anti-aliasing）"></a>TAA（Temporal Anti-aliasing）</h3><p>TAA分为采样（sampling）和合成（resolve）两个过程。</p><ul><li>采用：常见的做法是在每帧中对摄像机的视锥体矩阵做偏移，以达到多次采样的效果。</li><li>合成：为了避免采样的像素差异过大，使用Motion Vector：计算像素点在当前帧和上一帧的移动，<br>在融合时进行差异判断，放弃掉那些颜色差异大的历史像素点</li></ul><p>这种采样方法存在很多问题：</p><ol><li>由于舍弃了历史像素，会出现部分顶点闪烁。</li><li>当前画面的像素点与上一帧的矩形像素点有偏移，插值合成导致了像素的模糊。</li><li>Ghosting问题：光照变化或物体运动，导致历史样本失效；</li><li>骨骼动画、顶点动画需要额外计算处理<br><img src="/images/article/Games104/07/Games104_07_18.png"><span class="image-caption">TAA</span></li></ol><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><p>后处理：在Camera渲染完成之后，拿到渲染的纹理再对其进行处理。通常后处理是用来保证画面正确以及特殊效果<br>，但我们之前提到的SSAO、Depth Fog其实也算是在后处理流程中实现的。这里简单介绍一下常见的后处理效果。</p><h3 id="光晕（Bloom）"><a href="#光晕（Bloom）" class="headerlink" title="光晕（Bloom）"></a>光晕（Bloom）</h3><p>现实中，我们看到的强光源时，周围会有一圈光晕，Bloom就是为了处理这类效果。</p><p>Bloom的产生：</p><ul><li>相机透镜不能完美聚焦</li><li>Airy disk，光会在眼里产生散射</li></ul><p><img src="/images/article/Games104/07/Games104_07_19.png"><span class="image-caption">光晕</span></p><h3 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h3><p><img src="/images/article/Games104/07/Games104_07_20.png"><span class="image-caption">提取高亮区域</span></p><p>利用高斯模糊与低阶亮度对所提取的亮度区域进行模糊处理，以达到高效计算。然后将模糊化的亮度图与原图以一定比例进行叠加。<br><img src="/images/article/Games104/07/Games104_07_21.png"><span class="image-caption">高斯模糊</span><br><img src="/images/article/Games104/07/Games104_07_22.png"><span class="image-caption">高斯滤波金字塔</span></p><h3 id="色调映射（Tone-Mapping）"><a href="#色调映射（Tone-Mapping）" class="headerlink" title="色调映射（Tone Mapping）"></a>色调映射（Tone Mapping）</h3><p>自然界中亮度范围很大，但我们用来显示的设备亮度范围是有限的。若不对颜色做任何处理，但显示的颜色亮度超出显示上限时就会被截断，产生过曝显现。</p><p>为了处理这一问题，就需要Tone Mapping将显示的颜色映射到显示器能够处理的亮度范围内。<br>颜色的映射方案就是Tone Mapping的核心（Tone Mapping Curve）。</p><h4 id="Filmic-s-curve"><a href="#Filmic-s-curve" class="headerlink" title="Filmic s-curve"></a>Filmic s-curve</h4><p>Filmic s-curve是行业早期剔除的颜色映射曲线，提出者在大量实践基础上进行参数化拟合。其效果然游戏画质有了极大提升。<br><img src="/images/article/Games104/07/Games104_07_23.png"><span class="image-caption">Filmic s-curve</span></p><h4 id="ACES"><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h4><p>ACES是目前最被认可的颜色曲线，能够有效得在各种终端有稳定的显示效果。<br><img src="/images/article/Games104/07/Games104_07_24.png"><span class="image-caption">ACES</span></p><p><img src="/images/article/Games104/07/Games104_07_25.png"><span class="image-caption">三条色调映射效果对比</span></p><h3 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h3><p>Color Grading用来调整画面的色调，以达到烘托气氛或特殊的画风效果。<br>通常的处理方式为：对原有像素颜色通过查表的变为需要的颜色。映射的表称为Lookup Table (LUT)<br><img src="/images/article/Games104/07/Games104_07_26.png"><span class="image-caption">LUT</span></p><p>因为颜色是连续的，将3D颜色空间转换到2D纹理使用起来效果差不多。<br><img src="/images/article/Games104/07/Games104_07_27.png"><span class="image-caption">3D颜色空间到2D纹理</span></p><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>到目前为止，渲染的需要处理的内容基本都涉及了：渲染方程、大地、天空、AO等。<br>但还有一个核心问题：如何将我们提到的渲染相关的内容串联起来，使得整个渲染系统能够正常工作？<br>渲染管线就是来管理整个渲染的流程。</p><h3 id="前向渲染（Forward-Rendering）"><a href="#前向渲染（Forward-Rendering）" class="headerlink" title="前向渲染（Forward Rendering）"></a>前向渲染（Forward Rendering）</h3><p><img src="/images/article/Games104/07/Games104_07_28.png"><span class="image-caption">前向渲染</span></p><p>物体渲染顺序：总体来说，先由近及远渲染不透明物体（避免OverDraw），再由远及近渲染半透明物体（处理颜色混合）</p><p>半透明物体穿插绘制问题无法完美解决，只能用物体的中心点进行排序处理。<br><img src="/images/article/Games104/07/Games104_07_29.png"><span class="image-caption">排序和渲染透明对象</span></p><h3 id="延迟渲染（Deferred-Rendering）"><a href="#延迟渲染（Deferred-Rendering）" class="headerlink" title="延迟渲染（Deferred Rendering）"></a>延迟渲染（Deferred Rendering）</h3><p>前向渲染的问题就在于，每有一个光源就要对渲染物体处理一遍。当场景中存在大量光源时，开销太大。Deferred Rendering为了避免这种情况，<br>提出了两个Pass的处理方案：第一个Pass存储屏幕像素需要的几何信息（GBuff）；第二个Pass针对像素进行逐光源处理。<br><img src="/images/article/Games104/07/Games104_07_30.png"><span class="image-caption">延迟渲染</span></p><p>优点</p><ul><li>只计算可见顶点光照</li><li>G-Buffer的数据，后处理能拿来用</li></ul><p>缺点：</p><ul><li>高内存占用</li><li>不支持透明对象</li><li>对MSAA不友好<br><img src="/images/article/Games104/07/Games104_07_31.png"><span class="image-caption">延迟渲染优缺点</span></li></ul><h3 id="分块渲染（Tile-based-Rendering）"><a href="#分块渲染（Tile-based-Rendering）" class="headerlink" title="分块渲染（Tile-based Rendering）"></a>分块渲染（Tile-based Rendering）</h3><p>由于移动端的带宽、内存以及散热极其敏感，常规的PC GPU架构并不适合。为了应对这一问题，<br>现代移动端设备通常使用Tile-based Rendering的GPU架构：将画面拆分成许多小块（Tile），渲染绘制时针对Tile进行处理。<br><img src="/images/article/Games104/07/Games104_07_32.png"><span class="image-caption">分块渲染</span></p><p>优点：</p><ol><li>较少GPU的读写压力；</li><li>将Light附着到Tile优化Light处理；</li><li>根据Pre-Z与光照范围减少光照计算<br><img src="/images/article/Games104/07/Games104_07_33.png"><span class="image-caption">屏幕瓷砖中的灯光列表</span><br><img src="/images/article/Games104/07/Games104_07_34.png"><span class="image-caption">深度范围优化</span></li></ol><p>Forward+(Tile-based Forward) Rendering ：对Forward模式使用Tile-based Rendering<br>TBDR（Tile-based Deferred Rendering）：对Deferred模式使用Tile-based Rendering<br><img src="/images/article/Games104/07/Games104_07_35.png"><span class="image-caption">Forward+ Rendering</span></p><h3 id="基于集群的渲染（Cluster-based-Rendering）"><a href="#基于集群的渲染（Cluster-based-Rendering）" class="headerlink" title="基于集群的渲染（Cluster-based Rendering）"></a>基于集群的渲染（Cluster-based Rendering）</h3><p>将视图空间划分为多个四棱锥（Cluster），每个Tile单独计算Light的可见性。<br><img src="/images/article/Games104/07/Games104_07_36.png"><span class="image-caption">Cluster-based Rendering</span></p><h3 id="可见性缓冲区（Visibility-Buffer）"><a href="#可见性缓冲区（Visibility-Buffer）" class="headerlink" title="可见性缓冲区（Visibility Buffer）"></a>可见性缓冲区（Visibility Buffer）</h3><p>Visibility Buffer的基本思路是在前一个Pass中生成一个类似于GBuffer的全屏Buffer，<br>其中的每个texel只存primitive ID、uv和贴图ID，进而得到与之关联的所有属性值，法线、粗糙度等等。</p><p>Deferred Rendering在完成GBuff存储之后，就无法再获取原始的Mesh相关数据了；<br>而Visibility Buffer很好处理了这种问题， 对于复杂几何体来说，能够提供更好的细节效果。<br><img src="/images/article/Games104/07/Games104_07_37.png"><span class="image-caption">Visibility Buffer</span></p><p>优点：</p><ol><li>提供更好的几何数据；</li><li>内存、带宽压力小=&gt;可以使用MSAA</li></ol><p>缺点：计算消耗变大（索引不同纹理）</p><h2 id="框架图（FrameGraph）"><a href="#框架图（FrameGraph）" class="headerlink" title="框架图（FrameGraph）"></a>框架图（FrameGraph）</h2><p>可视化依赖和分析管理pipeline<br><img src="/images/article/Games104/07/Games104_07_38.png"><span class="image-caption">FrameGraph</span></p><h2 id="V-Sync-G-Sync"><a href="#V-Sync-G-Sync" class="headerlink" title="V-Sync&amp;&amp;G-Sync"></a>V-Sync&amp;&amp;G-Sync</h2><p>游戏画面出现画面撕裂问题，学术名叫Screen Tear<br><img src="/images/article/Games104/07/Games104_07_39.png"><span class="image-caption">画面撕裂</span></p><p>画面撕裂的原因：引擎渲染不同帧复杂程度不同，所以GPU帧率不固定，但是显示器刷新是固定的。<br>如果在显示器的刷新间隔中间，GPU完成了渲染，就会造成屏幕撕裂<br><img src="/images/article/Games104/07/Games104_07_40.png"><span class="image-caption">画面撕裂原因</span></p><p>垂直同步，是为了解决画面撕裂问题。就是降低帧率，等FrameBuffer写完，再一起刷新界面<br><img src="/images/article/Games104/07/Games104_07_41.png"><span class="image-caption">垂直同步</span></p><h3 id="可变刷新率（Variable-Refresh-Rate）"><a href="#可变刷新率（Variable-Refresh-Rate）" class="headerlink" title="可变刷新率（Variable Refresh Rate）"></a>可变刷新率（Variable Refresh Rate）</h3><p>显示器自适配游戏帧率技术<br><img src="/images/article/Games104/07/Games104_07_42.png"><span class="image-caption">Variable Refresh Rate</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/533244258">参考文章1</a></p><p><a href="https://zhuanlan.zhihu.com/p/527697509">参考文章2</a></p><p><a href="https://www.bilibili.com/video/BV1kY411P7QM/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture07_Rendering%20on%20Game%20Engine_Render%20Pipeline,%20Post-process%20and%20Everything.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏中地形大气和云的渲染（六）</title>
      <link href="/posts/aa8fbdb6.html"/>
      <url>/posts/aa8fbdb6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>前面章节我们了解了如何处理光线与物体的关系，这就有了渲染的基础。真实世界中地形是十分重要的部分，<br>尤其是在现代大世界的场景中，可以看到各种美轮美奂的地形效果，我们通常把地形称为Terrain。<br><img src="/images/article/Games104/06/Games104_06_01.png"><span class="image-caption">荒野大镖客：救赎</span></p><p>地形的制作面临以下挑战：</p><ul><li>游戏地形的尺寸可能十分广阔，如何在有限的硬件中来表现？</li><li>地形中存在大量各式各样的物件：山川、河流、植被、道路……，艺术家要如何处理？</li><li>游戏中需要与地形实时交互：比如雪地中行走留下痕迹、爆炸在地面留下坑洞。</li></ul><h2 id="地形的几何"><a href="#地形的几何" class="headerlink" title="地形的几何"></a>地形的几何</h2><p>本质来说地形与一般的物体没有树木不同，我们完全可以用简单的Mesh显示完整的地形效果。<br>但这样处理的方式，高精度地形对于目前硬件来说是难以承受的。之前章节处理阴影时，<br>有一个重要的思想： 对于距离Camera近的区域，需要的分辨率较高，反之则分辨率需求降低。（LOD）</p><h3 id="高沉图（Heightfield）"><a href="#高沉图（Heightfield）" class="headerlink" title="高沉图（Heightfield）"></a>高沉图（Heightfield）</h3><p>Heightfield是地形的俯视图，记录了地形的高度数据。原始的地形Mesh可以是精度较低的网格，<br>在运行时根据Camera位置动态细分网格数据，这样就可以极大减少性能压力。<br><img src="/images/article/Games104/06/Games104_06_02.png"><span class="image-caption">Heightfield</span></p><p>HeightMap有明显的局限性。它是一张二维的俯视图，也就是说只能处理没有重叠的地形。<br>比如山的内部有一个巨大的洞窟，虽然有一些方式可以处理，但总体来说是不方便的。</p><h3 id="网格细分原则"><a href="#网格细分原则" class="headerlink" title="网格细分原则"></a>网格细分原则</h3><p>Camera Distance：距离摄像机约近，网格约密</p><p>Adaptive Mesh Tessellation：分块设置地形精度</p><p>在说三角形细分前，我们需要先了解FOV与视野精度的关系。FOV代表摄像机的夹角， 由于Camera的分辨率是确定的，<br>因此FOV较大时，视野开阔，画面的很多细节会变得模糊；FOV较小时，视野缩小，场景精度变高。<br><img src="/images/article/Games104/06/Games104_06_03.png"><span class="image-caption">Adaptive Mesh Tessellation</span></p><ol><li>根据Fov(视角)和距离设置</li><li>因为采样点变少，所以地形的高度可能会有误差，这个误差体现到屏幕上，最好不超过一个像素。</li></ol><p>当我们实现View-dependent Terrain时（网格颜色变化在一定范围内，通常为1个像素）就需要基于以上两个原则。</p><h3 id="网格细分算法"><a href="#网格细分算法" class="headerlink" title="网格细分算法"></a>网格细分算法</h3><p>细分网格算法需要关注两个点：什么情况下进行细分？如何细分？</p><h4 id="基于三角形的细分（Triangle-Based-Subdivision）"><a href="#基于三角形的细分（Triangle-Based-Subdivision）" class="headerlink" title="基于三角形的细分（Triangle-Based Subdivision）"></a>基于三角形的细分（Triangle-Based Subdivision）</h4><p>将一个等腰三角形最长边与对应顶点切分得到两个等腰三角形。<br><img src="/images/article/Games104/06/Games104_06_04.png"><span class="image-caption">Triangle-Based Subdivision</span></p><p>相邻边一侧被切分，另一侧未切分时，未切分三角形进行同样的处理，避免相邻三角形出现高度差，从而漏出天空。<br>细分方法：从细分三角形的直角边将三角形对半分开。<br><img src="/images/article/Games104/06/Games104_06_05.png"><span class="image-caption">Subdivision and T-Junctions</span></p><h4 id="基于四叉树（QuadTree-Based-Subdivision）"><a href="#基于四叉树（QuadTree-Based-Subdivision）" class="headerlink" title="基于四叉树（QuadTree-Based Subdivision）"></a>基于四叉树（QuadTree-Based Subdivision）</h4><p>切分三角形的方式不符合我们制作地形的直觉，因此上述算法在实际应用中使用不多。基于四叉树的细分方式则更加方便理解和使用。</p><p>优点： </p><ol><li>易于构建</li><li>易于管理地理空间下的数据，包括对象挑选和数据流</li></ol><p>缺点：</p><ol><li>网格细分不如三角形网格那么灵活</li><li>叶节点的网格级别需要保持一致</li></ol><p><img src="/images/article/Games104/06/Games104_06_06.png"><span class="image-caption">QuadTree原理</span></p><p><img src="/images/article/Games104/06/Games104_06_07.png"><span class="image-caption">QuadTree不同层级细分</span></p><p>QuadTree不仅在算法层面较为便利，并且资源的制作和管理方式也与算法较为贴合。四叉树同样存在T-Junctions问题，<br>但在处理时十分聪明：存在T-Junctions的问题三角形，将其新增的细分点吸附到临近三角形点。<br>这种处理方式不存在顶点的删减，算法实现层面也较为简单。<br><img src="/images/article/Games104/06/Games104_06_08.png"><span class="image-caption">QuadTree不同层级细分</span></p><h4 id="不规则三角形（Triangulated-Irregular-Network）"><a href="#不规则三角形（Triangulated-Irregular-Network）" class="headerlink" title="不规则三角形（Triangulated Irregular Network）"></a>不规则三角形（Triangulated Irregular Network）</h4><p>对于存在大量平面的地形，上述两种方法效果都不明显（极限情况地形为平面时，只需两个三角形采样就可以表达）。<br>因此TIN将地形的细分直接做到Mesh中，不再动态计算。<br><img src="/images/article/Games104/06/Games104_06_09.png"><span class="image-caption">不规则三角形对比</span></p><h3 id="GPU网格处理（GPU-Based-Tessellation）"><a href="#GPU网格处理（GPU-Based-Tessellation）" class="headerlink" title="GPU网格处理（GPU-Based Tessellation）"></a>GPU网格处理（GPU-Based Tessellation）</h3><p>在早先时候，上述的细分算法都是需要程序员在CPU中精心处理好的，但在现代游戏引擎中，曲面细分的工作通常是交给GPU来完成。</p><h4 id="硬件曲面细分（Hardware-Tessellation）"><a href="#硬件曲面细分（Hardware-Tessellation）" class="headerlink" title="硬件曲面细分（Hardware Tessellation）"></a>硬件曲面细分（Hardware Tessellation）</h4><p>DX11提供了基于硬件的曲面细分可选Shader<br><img src="/images/article/Games104/06/Games104_06_10.png"><span class="image-caption">DX11的绘制流程</span></p><p><img src="/images/article/Games104/06/Games104_06_11.png"><span class="image-caption">DX11的绘制流程2</span></p><ul><li>Hull Shader：生成Subdivision Patch，Patch由几个控制点组成定义了一个细分面。</li><li>Tessellator Shader：根据Patch生成点集和这些点集的重心坐标。</li><li>Domain Shader：生成三角网格</li><li>Geometry Shader：添加额外的Primitive</li></ul><h4 id="网格着色器管线（Mesh-Shader-Pipeline）"><a href="#网格着色器管线（Mesh-Shader-Pipeline）" class="headerlink" title="网格着色器管线（Mesh Shader Pipeline）"></a>网格着色器管线（Mesh Shader Pipeline）</h4><p>DX12中提供了新的Shader管线：Mesh Shader Pipeline，极大简化了Shader处理流程，所有的处理流程都可以由程序自己控制。<br><img src="/images/article/Games104/06/Games104_06_12.png"><span class="image-caption">DX12的Shader管线</span></p><p>注：NVIDIA在2019年公布Turing(图灵) 架构对Mesh Shader的拓展，对应RTX 20系列显卡。<br>而DX12同年也宣布对这一特性的支持，因此Win10之前版本不支持这一特性。</p><h4 id="实时可变地形（Real-Time-Deformable-Terrain）"><a href="#实时可变地形（Real-Time-Deformable-Terrain）" class="headerlink" title="实时可变地形（Real-Time Deformable Terrain）"></a>实时可变地形（Real-Time Deformable Terrain）</h4><p>有了曲面细分之后，再进一步就可以着手处理与地形的交互了。以雪地交互为例，当物体在雪地中移动时，<br>我们用一张Texture来记录物体运动的轨迹。然后将这张Texture传入地形Shader中，做曲面细分。这样就可以实现雪地的交互变形效果。<br><img src="/images/article/Games104/06/Games104_06_13.png"><span class="image-caption">实时可变地形</span></p><h4 id="体素化（Voxelization）"><a href="#体素化（Voxelization）" class="headerlink" title="体素化（Voxelization）"></a>体素化（Voxelization）</h4><p>曲面细分的方法虽然可以处理地面变形的交互，但地面的高度场并没有真正发生变化。<br>比如地面出现一个深坑， 我们只能看起来有一个坑，但人并不会掉入坑中。而体素化地形可以较好得解决这一问题。</p><p><strong>体素化思想</strong><br>Voxelization是将物体的几何形式表示转换成最接近该物体的体素表示形式，产生体数据，包含模型的表面信息和内部属性。<br>表示3D模型的体素跟表示2D图像的像素相似，只不过从二维的点扩展到三维的立方体单元。<br>体素化能够对模型进行简化，得到均匀一致的网格，在求模型的切片，物理仿真分析过程中有较好的应用。<br><img src="/images/article/Games104/06/Games104_06_14.png"><span class="image-caption">体素化</span></p><p><strong>方块裁切（Marching Cube）</strong><br>Marching Cube使用许多Cube来对物体进行填充表示。Cube的点与被表示的物体有两种情况：处于物体内部和处于物体外部。一个Cube有8个点，<br>这样每个Cube就有2^8=256种情况。由于反转状态不变，所以可以减少一半，为128种。再根据旋转不变形，又可以减少到14种情况。<br><img src="/images/article/Games104/06/Games104_06_15.png"><span class="image-caption">Marching Cube</span></p><p>我们把这14中情况的Cube数据存到查找表(look up table)中，这样只需要判断Cube顶点与物体的交集情况就可以得到覆盖物体的每个Cube数据了。</p><ul><li>优点：可以处理任意结构的地形。</li><li>缺点：相比常规处理，地形内部多出了大量数据，并且目前的算法并不完善。</li></ul><h2 id="地形的材质"><a href="#地形的材质" class="headerlink" title="地形的材质"></a>地形的材质</h2><p>之前我们已经解决了光照计算，但地形由于其特殊的需求，需要对一些参数据进行处理。</p><h3 id="纹理混合（Texture-Splatting）"><a href="#纹理混合（Texture-Splatting）" class="headerlink" title="纹理混合（Texture Splatting）"></a>纹理混合（Texture Splatting）</h3><p>当我们渲染地表时，必然需要用到地表的纹理，但地表中存在许多物体：沙、石、草……，并且这些物体存在重叠的情况，<br>不同区域可能需要对多个纹理采样。我们使用一张纹理作为不同纹理的map：使用哪些纹理进行采样混合。<br>简单根据alpha的混合不符合现实：混合区域沙子应该更多得处于石头缝隙中，而不是线性得混合。<br><img src="/images/article/Games104/06/Games104_06_16.png"><span class="image-caption">简单的纹理混合</span></p><p>一种处理方式是对过渡区域做Height对比，从较高的区域区域过渡到较低的区域，则较高区域的混合权重下降慢一些，较低区域很快退去。<br><img src="/images/article/Games104/06/Games104_06_17.png"><span class="image-caption">高级的纹理混合</span></p><p>但这种处理方式仍然存在问题，这种切换是0、1切换（只选择一种材质），当相机移动时，信息高频，会出现抖动，<br>通过增加阈值的方式来手动调整（加入Bias，当高度差在0.2内时看起来是最好的）。<br><img src="/images/article/Games104/06/Games104_06_18.png"><span class="image-caption">添加扰动纹理混合</span></p><h3 id="采样（Sampling）"><a href="#采样（Sampling）" class="headerlink" title="采样（Sampling）"></a>采样（Sampling）</h3><p>Sampling from Texture Array</p><p>将实际采样的纹理存储在几个纹理数组中，通过Map纹理映射到具体对哪些纹理采样。<br><img src="/images/article/Games104/06/Games104_06_19.png"><span class="image-caption">从材料纹理阵列中取样</span></p><p>为了让平面产生几何感，我们可以通过一下几种方式进行处理，目前使用的比较少</p><ul><li>Bump（凹凸贴图）：颜色计算时，对法线做修改</li><li>Parallax（视差贴图）：对纹理uv做偏移，形成高度差</li><li>Dsaplacement（位移贴图）：对顶点延法线方向位移</li></ul><p><img src="/images/article/Games104/06/Games104_06_20.png"><span class="image-caption">地形的凹凸显示</span></p><h3 id="虚拟纹理（Virtual-Texture）"><a href="#虚拟纹理（Virtual-Texture）" class="headerlink" title="虚拟纹理（Virtual Texture）"></a>虚拟纹理（Virtual Texture）</h3><p>上面使用纹理数组的方式处理，我们的Shader就需要在不同纹理之间来回跳转采样，这样的处理方式是十分耗时的。<br>Virtual Texture很好得解决了这个问题：将需要使用的Texture合并到一个虚拟的大纹理中，进行动态加载与卸载。<br><img src="/images/article/Games104/06/Games104_06_21.png"><span class="image-caption">Virtual Texture</span></p><h3 id="直接存储器访问（DirectStorage-DMA）"><a href="#直接存储器访问（DirectStorage-DMA）" class="headerlink" title="直接存储器访问（DirectStorage &amp; DMA）"></a>直接存储器访问（DirectStorage &amp; DMA）</h3><p>常规的硬件GPU读取内存：硬盘-&gt;内存-&gt;现存，中间的数据传递十分耗时。DirectStorage技术在传递数据时，<br>传递的是未解压的数据，由GPU来完成解压。DMA技术则更进一步，直接由GPU读取纹理数据。<br><img src="/images/article/Games104/06/Games104_06_22.png"><span class="image-caption">Virtual Texture</span></p><h3 id="浮点数精度溢出"><a href="#浮点数精度溢出" class="headerlink" title="浮点数精度溢出"></a>浮点数精度溢出</h3><p>浮点数是以32bit记录数据（整数+小数），当我们使用浮点数来表示大地形顶点数据时，<br>很可能出现浮点数无法精确表示的情况。（由于整数部分过大，小数部分精度不够）<br><img src="/images/article/Games104/06/Games104_06_23.png"><span class="image-caption">浮点数精度溢出</span></p><p><strong>Camera Relarive Rendering</strong><br>物体在渲染时，通常将顶点数据转换为世界坐标系。更好的处理方式是将物体转换为相对Camera的坐标来处理，<br>这样距离Camera视野范围内的对象就可以相对正确表达。</p><h2 id="植被道路贴花等"><a href="#植被道路贴花等" class="headerlink" title="植被道路贴花等"></a>植被道路贴花等</h2><h3 id="树木渲染（Tree-Rendering）"><a href="#树木渲染（Tree-Rendering）" class="headerlink" title="树木渲染（Tree Rendering）"></a>树木渲染（Tree Rendering）</h3><p>通常渲染树的方式是用一堆插片来表示，并且根据视角做LOD。<br><img src="/images/article/Games104/06/Games104_06_24.png"><span class="image-caption">Tree Rendering</span></p><h3 id="装饰渲染（Decorator-Rendering）"><a href="#装饰渲染（Decorator-Rendering）" class="headerlink" title="装饰渲染（Decorator Rendering）"></a>装饰渲染（Decorator Rendering）</h3><p>早期游戏的Decorator会一直面向Camera（跟着相机旋转）<br><img src="/images/article/Games104/06/Games104_06_25.png"><span class="image-caption">Decorator Rendering</span></p><h3 id="道路和贴花渲染（Road-and-Decals-Rendering）"><a href="#道路和贴花渲染（Road-and-Decals-Rendering）" class="headerlink" title="道路和贴花渲染（Road and Decals Rendering）"></a>道路和贴花渲染（Road and Decals Rendering）</h3><p>Road在地形中的处理较为复杂，因为不仅要处理渲染纹理，还需要处理高度场。</p><p>Decals是将物体附着在对象上的技术，例如人脸上的花纹，建筑上的单孔。<br><img src="/images/article/Games104/06/Games104_06_26.png"><span class="image-caption">Road and Decals Rendering</span></p><p>现代通常会用程序化的方式对地形物件进行生成，上面这些所有的纹理在渲染时，都直接Bake到VT中，减少渲染成本。</p><h2 id="大气散射理论"><a href="#大气散射理论" class="headerlink" title="大气散射理论"></a>大气散射理论</h2><h3 id="大气"><a href="#大气" class="headerlink" title="大气"></a>大气</h3><p><img src="/images/article/Games104/06/Games104_06_27.png"><span class="image-caption">大气</span></p><p>这部分主要涉及两部分：天空与云，大气的拟合方程如下：<br><img src="/images/article/Games104/06/Games104_06_28.png"><span class="image-caption">大气拟合</span></p><p>影响因素：观察方向与天顶的角度（θ）、观测方向与太阳角度（γ）</p><p>优点：计算简单；缺点：只能模拟静态地表的情况</p><h3 id="气体媒介"><a href="#气体媒介" class="headerlink" title="气体媒介"></a>气体媒介</h3><p>大气由气溶胶组成，所以才能表现出特殊的光学现象。气溶胶可以看做是很多细小的颗粒，光线在这些颗粒之间不断弹射，形成复杂的光学现象。<br><img src="/images/article/Games104/06/Games104_06_29.png"><span class="image-caption">气体媒介</span></p><h3 id="光的交互"><a href="#光的交互" class="headerlink" title="光的交互"></a>光的交互</h3><p>在一维空间下对于光与气体的交互，我们作出以下假设，以此产生RTE方程：</p><ul><li>光在气体中每前进一段距离，其能量会以一定比例被吸收</li><li>光在气体中每前进一段距离，会向周围散射</li><li>气体自发光（通常不考虑）</li><li>周围气体的散射</li></ul><p><img src="/images/article/Games104/06/Games104_06_30.png"><span class="image-caption">光的交互</span></p><p>RTE方程表示光传递的梯度，对于梯度的积分就是人眼看到一个气体像素的最终颜色。VRE想要表达是，<br>光从M点到P点，逐个计算每个气体光被吸收、散射并且接收周围气体散射的能量，得到最终的颜色。<br><img src="/images/article/Games104/06/Games104_06_31.png"><span class="image-caption">VRE</span></p><h3 id="光散射模型"><a href="#光散射模型" class="headerlink" title="光散射模型"></a>光散射模型</h3><h4 id="Rayleigh-Scattering"><a href="#Rayleigh-Scattering" class="headerlink" title="Rayleigh Scattering"></a>Rayleigh Scattering</h4><p>当介质远小于光波长，光几乎均匀散射，越短的波长(蓝、紫)散射越厉害。受影响于波长与海拔(h)<br><img src="/images/article/Games104/06/Games104_06_32.png"><span class="image-caption">Rayleigh Scattering</span></p><h4 id="Mie-Scattering"><a href="#Mie-Scattering" class="headerlink" title="Mie Scattering"></a>Mie Scattering</h4><p>气溶胶尺寸大于等于光波长，具有方向性，沿光方向比较强，对波长不敏感。雾也是用的这个原理<br><img src="/images/article/Games104/06/Games104_06_33.png"><span class="image-caption">Mie Scattering</span></p><h3 id="多散射问题"><a href="#多散射问题" class="headerlink" title="多散射问题"></a>多散射问题</h3><p><img src="/images/article/Games104/06/Games104_06_34.png"><span class="image-caption">单次和多次射对比</span></p><p>现实中气体散射会影响场景中的光照，上图中山的背面被空气的散射照亮。为了解决这一问题，我们可以使用Ray Matching的方式处理。<br><img src="/images/article/Games104/06/Games104_06_35.png"><span class="image-caption">Ray Matching</span></p><p>沿着射线的方向，均匀采样许多点。根据散射方程，计算散射积分。</p><h2 id="实时大气渲染"><a href="#实时大气渲染" class="headerlink" title="实时大气渲染"></a>实时大气渲染</h2><p>为了避免复杂计算，我们通常会将通透度和散射放到纹理中进行查询。根据通透度和散射值，可以计算一次散射的结果，多次迭代计算可以接近真实效果。<br><img src="/images/article/Games104/06/Games104_06_36.png"><span class="image-caption">根据一个角度和海拔高度采样通透度</span><br><img src="/images/article/Games104/06/Games104_06_37.png"><span class="image-caption">通过三个角度和海拔高度采样一次散射</span></p><p>当我们需要处理天空中的雾效时，可以做一些简化处理。参考UE中的处理方式，以及作出的假设</p><ul><li>大气的散射具有各项同性 =&gt; 颜色百分比的衰减</li><li>光源位置不变，海拔高度不变，这样只需要两个参数就可以查找散射</li><li>根据距离进行积分</li></ul><p><img src="/images/article/Games104/06/Games104_06_38.png"><span class="image-caption">快速产生天空和气氛的渲染</span></p><h2 id="云的渲染"><a href="#云的渲染" class="headerlink" title="云的渲染"></a>云的渲染</h2><h3 id="云的类型"><a href="#云的类型" class="headerlink" title="云的类型"></a>云的类型</h3><p><img src="/images/article/Games104/06/Games104_06_39.png"><span class="image-caption">云的类型</span></p><ul><li>stratus（层云）：云体均勾成层，呈灰色，似雾，但不与地接，常笼罩山腰，主要由小水滴构成，为水云，厚度一般在400-500米之间；<br>云底离地面高度常在2000米以下，属低云族。层云又可分成2类：层云、碎层云。</li><li>Stratocumulus（层积云）：一般在600~2000米 ，结构松散的大云块、大云条(滚轴状)组成的云层，有时排列成行；颜色灰白或灰色；<br>根据其形状特征可分透光、蔽光、积云性、荚状、堡状等层积云数种。</li><li>Cirrus（卷云）：一般在4500至10000米。它由高空的细小冰晶组成，且冰晶比较稀疏，故云比较薄而透光良好，色泽洁白并具有冰晶的亮泽。<br>卷云按外形、结构等特征，分为毛卷云和钩卷云、伪卷云、密卷云四类。</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><img src="/images/article/Games104/06/Games104_06_40.png"><span class="image-caption">基于网格的云建模（Mesh腐蚀处理）</span><br>优点：高质量。缺点：昂贵，不支持动态天气。</p><p><img src="/images/article/Games104/06/Games104_06_41.png"><span class="image-caption">公告牌云（Billboard面片处理）</span><br>现在一般不使用这种方式了。优点：效率高。缺点：视觉有限，类型有限。</p><p><img src="/images/article/Games104/06/Games104_06_42.png"><span class="image-caption">体积云</span><br>优点：</p><ul><li>实现云的形状。</li><li>可大规模出现。</li><li>支持动态天气。</li><li>支持体积照明和阴影。</li></ul><p>缺点：</p><ul><li>必须考虑效率。</li></ul><h3 id="体积云"><a href="#体积云" class="headerlink" title="体积云"></a>体积云</h3><p>体积云使用Weather Texture来处理。Weather Texture分为两个部分：云的分布纹理和云的厚度纹理。<br>当我们需要让云产生变化时，只需要对Weather Texture做扰动处理。<br><img src="/images/article/Games104/06/Games104_06_43.png"><span class="image-caption">Weather Texture</span></p><p>在项目中常见的随机扰动处理就是噪声。Perlin Noise可以生成的平滑的随机游走模型；Worley Noise模拟细胞的生成，根据空间中的点对空间进行划分。<br><img src="/images/article/Games104/06/Games104_06_44.png"><span class="image-caption">噪声扰动</span><br><img src="/images/article/Games104/06/Games104_06_45.png"><span class="image-caption">云模型的生成过程：多层级Noise对云模型腐蚀</span></p><p>有了云模型之后，就要考虑如何渲染了，处理方式和大气类似：Ray Marching。由于云的通透度度很低，并不需要像大气的复杂处理，<br>我们看到的云是GPU中的三维纹理，使用Ray Marching的方式解析出来。<br><img src="/images/article/Games104/06/Games104_06_46.png"><span class="image-caption">通过光线行进来渲染云</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/500870965">参考文章1</a></p><p><a href="https://zhuanlan.zhihu.com/p/501343768">参考文章2</a></p><p><a href="https://zhuanlan.zhihu.com/p/500862481">参考文章3</a></p><p><a href="https://www.bilibili.com/video/BV1au411y7Fq/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频1</a></p><p><a href="https://www.bilibili.com/video/BV1i3411T7QL/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频2</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture06_The%20Challenges%20and%20Fun%20of%20Rendering%20the%20Beautiful%20Mother%20Nature.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏渲染中光和材质的数学魔法（五）</title>
      <link href="/posts/27ef4ad0.html"/>
      <url>/posts/27ef4ad0.html</url>
      
        <content type="html"><![CDATA[<h2 id="渲染方程及挑战"><a href="#渲染方程及挑战" class="headerlink" title="渲染方程及挑战"></a>渲染方程及挑战</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li>光：光子，反射，吸收</li><li>材质：跟光子的交互</li><li>着色：不同材质和、光照的渲染</li></ul><p><img src="/images/article/Games104/05/Games104_05_01.png"><span class="image-caption">渲染计算的组成</span></p><h3 id="渲染方程式"><a href="#渲染方程式" class="headerlink" title="渲染方程式"></a>渲染方程式</h3><p>1986年，James Kajiya提出了物体渲染方程（Rendering Equation），世界上所有物体的渲染逻辑都可以用这一方程来解释。<br><img src="/images/article/Games104/05/Games104_05_02.png"><span class="image-caption">James Kajiya</span><br><img src="/images/article/Games104/05/Games104_05_03.png"><span class="image-caption">渲染方程式</span></p><p>渲染方程式表明：经过任意点x反射到观察点中的辐射通量由x点自身发光和其他点反射到x点的辐射通量组成，其中其他点反射到x点的光照又可分为直接光照和间接光照。</p><p><img src="/images/article/Games104/05/Games104_05_04.png"><span class="image-caption">真实环境的复杂渲染</span><br>渲染方程在实际运用中非常复杂，包含诸多影响因素。</p><p><a href="https://zhuanlan.zhihu.com/p/370162390">具体分析可参考大佬的文章：王江荣：路径追踪（Path Tracing）与渲染方程(Render Equation)</a></p><h3 id="挑战1"><a href="#挑战1" class="headerlink" title="挑战1"></a>挑战1</h3><p>阴影（Shadow）是我们判断物体空间关系的重要条件，我们该如何模拟出真实的阴影呢？<br><img src="/images/article/Games104/05/Games104_05_05.png"><span class="image-caption">光的可见性</span></p><p>光源的复杂性，光源有点光源、方向光源、面光源等不同种类，在实际应用中光照强度也有所不同。<br><img src="/images/article/Games104/05/Games104_05_06.png"><span class="image-caption">光源的复杂性</span></p><h3 id="挑战二"><a href="#挑战二" class="headerlink" title="挑战二"></a>挑战二</h3><p>如何高效的对双向反分布函数（BRDF，Bidirectional Reflectance Distribution Function）和入射辐射率的乘积进行积分，这里可以使用Monte Carlo积分（在上面大佬的文章中也有具体分析）。<br><img src="/images/article/Games104/05/Games104_05_07.png"><span class="image-caption">如何在硬件上高效地进行集成</span></p><h3 id="挑战三"><a href="#挑战三" class="headerlink" title="挑战三"></a>挑战三</h3><p>因为光可以反射，所以全局范围内任何一个物体都可以作为光源，即一束Output的光下一次可能作为Input输入，这样形成了一个递归的过程，典型案例Cornell Box。<br><img src="/images/article/Games104/05/Games104_05_08.png"><span class="image-caption">任何物质都将是光源</span></p><h3 id="总结三个挑战"><a href="#总结三个挑战" class="headerlink" title="总结三个挑战"></a>总结三个挑战</h3><ul><li>对于任一给定方向如何获得irradiance</li><li>对于光源和表面shading的积分运算</li><li>对于入射光和反射光不断递归过程的计算</li></ul><p><img src="/images/article/Games104/05/Games104_05_09.png"><span class="image-caption">总结三个挑战</span></p><h2 id="基础光照解决方法"><a href="#基础光照解决方法" class="headerlink" title="基础光照解决方法"></a>基础光照解决方法</h2><h3 id="简化光源"><a href="#简化光源" class="headerlink" title="简化光源"></a>简化光源</h3><p>我们使用方向光源、点光源、锥形光源等作为Main Light，取Ambient Light作为除主光外的环境光的均值，以此简化复杂的计算。<br><img src="/images/article/Games104/05/Games104_05_10.png"><span class="image-caption">简单的光解决方案</span></p><p>对于能够反射环境的材质，我们可以设计一种环境贴图，通过采样环境数据来表现<br><img src="/images/article/Games104/05/Games104_05_11.png"><span class="image-caption">环境地图反射</span></p><h3 id="简化材质"><a href="#简化材质" class="headerlink" title="简化材质"></a>简化材质</h3><p>基于一个光照可以线性叠加的假设（在渲染方程式中也有用到），<br>Blinn-Phong模型通过叠加Ambient（环境）、Diffuse（漫反射）、和Specular（高光）来简单粗暴的描述材质的着色计算<br><img src="/images/article/Games104/05/Games104_05_12.png"><span class="image-caption">Blinn-Phong材质</span></p><p>Blinn-Phong的缺陷：</p><ul><li>能量不保守：使用Blinn-Phong模型的出射光照能量可能大于入射光照的能量，这在计算光线追踪时会带来很大的问题：这一过程在光线追踪中经过无限次反弹后，会使得本该暗的地方变得过于明亮。</li><li>难以表现真实的质感：Blinn-Phong模型虽然比较经典，但它却很难表现出物体在真实世界中的模样，总是有一种”塑料“感。</li></ul><p><img src="/images/article/Games104/05/Games104_05_13.png"><span class="image-caption">Blinn-Phong缺陷</span></p><h3 id="简化阴影"><a href="#简化阴影" class="headerlink" title="简化阴影"></a>简化阴影</h3><p>Shadow简单说来就是人眼可见区域中，光线无法照到的地方。在过去十几年中，对于Shadow最常见的处理方式便是Shadow Map。<br><img src="/images/article/Games104/05/Games104_05_14.png"><span class="image-caption">阴影</span></p><p>Shadow Map的思想可以简单概括为：第一次先在光源处放置相机，以z-buffer的方式储存一张对应的深度缓冲， 第二次将相机放置在观察的位置，<br>并将视锥内的点的深度和深度缓冲中的对应点（三维坐标转换为二维坐标后，在平面坐标系中对应的点）的深度进行对比，<br>若前者大于后者，则认为视锥中的点处于阴影中</p><p><img src="/images/article/Games104/05/Games104_05_15.png"><span class="image-caption">Shadow Map</span></p><p>渲染Camera区域对ShadowMap进行采样，两者精度是不同的，因此很容易出现走样问题。<br>最常见的就是自遮挡问题，可以尝试加一个bias使它的容差大一点，但是这样会导致物体与阴影之间出现”断层“的人脚浮空现象。<br><img src="/images/article/Games104/05/Games104_05_16.png"><span class="image-caption">自遮挡问题</span></p><p>这样的话我们有了lighting,material和shadow，一套简单的渲染方案就出现了：<br><img src="/images/article/Games104/05/Games104_05_17.png"><span class="image-caption">基本的渲染方案</span></p><h2 id="基于预计算的全局光照"><a href="#基于预计算的全局光照" class="headerlink" title="基于预计算的全局光照"></a>基于预计算的全局光照</h2><p>只用直接光照会使得场景的平面感很强，而使用全局光照（直接光照+间接光照）能很大程度上的还原真实情况<br><img src="/images/article/Games104/05/Games104_05_18.png"><span class="image-caption">全局光照对比</span></p><h3 id="如何表现全局光照："><a href="#如何表现全局光照：" class="headerlink" title="如何表现全局光照："></a>如何表现全局光照：</h3><ul><li>我们需要储存数以万计的光照探测器，因此我们需要一个很好的压缩比率（需要预计算，空间换时间）</li><li>材质的BRDF卷积运算涉及到复杂的多项式积分运算，我们需要利用数学方法简化积分运算</li></ul><p><img src="/images/article/Games104/05/Games104_05_19.png"><span class="image-caption">如何表现全局光照</span></p><h3 id="卷积定理（Convolution-Theorem）"><a href="#卷积定理（Convolution-Theorem）" class="headerlink" title="卷积定理（Convolution Theorem）"></a>卷积定理（Convolution Theorem）</h3><p>百度百科：</p><blockquote><p>卷积定理是傅立叶变换满足的一个重要性质。卷积定理指出，函数卷积的傅立叶变换是函数傅立叶变换的乘积。具体分为时域卷积定理和频域卷积定理，时域卷积定理即时域内的卷积对应频域内的乘积；频域卷积定理即频域内的卷积对应时域内的乘积，两者具有对偶关系。</p></blockquote><p>对于空间域中的一个数字信号（下图以照片为例），我们可以通过傅里叶变换将其转化为频率域的一段频率，<br>截取频率的一小段就可以实现对频率整体的一个粗糙的表达，这时我们再通过反向傅里叶变换就可以得到原数字信号的大概情况<br>（通过对信号的高度压缩也能让我们大概看出是什么东西）。 通过这一数学性质，我们不需要再去进行复杂的乘积累加和运算。</p><p><img src="/images/article/Games104/05/Games104_05_20.png"><span class="image-caption">卷积定理</span></p><h3 id="球谐函数（Spherical-Harmonics）"><a href="#球谐函数（Spherical-Harmonics）" class="headerlink" title="球谐函数（Spherical Harmonics）"></a>球谐函数（Spherical Harmonics）</h3><p>球谐函数就是一组基函数的集合，并且基函数越多，它的回归性越强(表达能力越强)</p><p>球谐函数（SH）有以下性质：</p><ul><li>正交性，任意两个不同的归一化的球谐函数卷积在一起的结果为0。</li><li>旋转不变性：光源旋转后，对世界空间传入的数据进行同样的旋转旋转变换，可以得到同样的光照数据。</li><li>球谐函数的二阶导数为0：说明函数永远是光滑的，变化十分流畅和光滑。</li></ul><p><img src="/images/article/Games104/05/Games104_05_21.png"><span class="image-caption">球谐函数</span></p><p>使用球谐函数，我们就可以通过一阶多项式近似的表达一个球面光照（低频信号）<br><img src="/images/article/Games104/05/Games104_05_22.png"><span class="image-caption">球谐编码</span></p><p>接着我们来使用这个工具，一般来说我们取很低的阶来展现低频信息，如图在场景中取一点，<br>在这个点进来的光（也就是我们进行球面采样）我们将球按照地图一样展开，就像右下角的图一样。<br><img src="/images/article/Games104/05/Games104_05_23.png"><span class="image-caption">任意irradiance采集点</span></p><p>接着我们对其用球谐函数进行压缩，在这里我们只取L0和L1两阶，一共4个基函数。<br><img src="/images/article/Games104/05/Games104_05_24.png"><span class="image-caption">将irradiance采集点压缩到SH1</span></p><p>我们可以看到重建出来的图虽然十分模糊，但是我们大致知道哪些地方有光，而且整个数据是连续，<br>如果想知道某方向的光强是多少只需要进行一次线性的vector计算即可，大部分时间其实用来表示环境光的，<br>因为环境光本来就是低频的，用SH正合适。<br><img src="/images/article/Games104/05/Games104_05_25.png"><span class="image-caption">用SH存储和着色</span></p><h3 id="光照贴图（Lightmap）"><a href="#光照贴图（Lightmap）" class="headerlink" title="光照贴图（Lightmap）"></a>光照贴图（Lightmap）</h3><p>有了球谐函数这一便捷工具，我们就可以将许多几何物体拍下存放在一张贴图上（这张贴图通常被称为“atlas”），这一过程又分为几个步骤</p><p>首先我们需要将几何物体进行简化，而后在参数空间内为每个几何物体分配近似的texel精度<br><img src="/images/article/Games104/05/Games104_05_26.png"><span class="image-caption">UV集</span></p><p>下面我们在场景内加入全局光照，就可以表现出非常真实的效果<br><img src="/images/article/Games104/05/Games104_05_27.png"><span class="image-caption">全局光照效果</span></p><p>LightMap的优点：</p><ul><li>在real-time中效率高，因为成本低</li><li>由于是离线baking，当将空间分解之后，会产生很多细节或subtle的效果。</li></ul><p>LightMap的缺点：</p><ul><li>时间非常长的预计算时间。</li><li>只能处理static物体和static光源。</li><li>由于采用的是空间换时间的策略，在real-time时lightmap会占用几十到几百兆的存储空间</li></ul><p>LightMap思想：</p><ul><li>烘培（bake）可以空间换时间；空间光照可以烘焙成图片，那很多计算可以实现可以管理。</li></ul><h3 id="为什么使用LightMap"><a href="#为什么使用LightMap" class="headerlink" title="为什么使用LightMap:"></a>为什么使用LightMap:</h3><p>如果只计算主光源那么就会感觉有些地方很暗，所以需要计算主光源和各个光源所产生的间接影响，<br>比如如果只有一个光源，他可能照射到一个物体，那么这个物体就变成了刺激光源反射光到别的物体上。<br>如果这样计算间接光照在不断的bounce下是无法结束的，很消耗计算资源，在上述简化光源的解决方案中我们设置了一个常数作为统一的环境光，<br>但是如果所有的物体都有相同的环境光，那么只接受间接光照影响的物体，会显得一股平面感塑料感，这是因为使用的相同的光照强度，<br>所以最好的办法还是记录每个点光照信息，但是这样的话记录的信息会非常多，这时候用傅里叶变换所衍生的SH函数，<br>SH函数是一种定义在球面上的函数的压缩表示方法，一个点收到的环境光照可以定义为以该点为球心的单位球面上每个点的irradiance，<br>我们该probe点接受的环境光用SH函数表示，当我们在进行使用时可以根据SH的系数和基函数进行重建，<br>从而可以记录很少的数据就能大致记录这个环境中大致的光暗关系，这个就是生成Lightmap。</p><h3 id="光照采集点（Light-Probe）"><a href="#光照采集点（Light-Probe）" class="headerlink" title="光照采集点（Light Probe）"></a>光照采集点（Light Probe）</h3><p>我们可以在空间内放置许多采样点，对于每个采样点采集其对应的光场，当有物体移动经过某一采样点时，<br>通过寻找附近的采样点并计算插值，就可以得到该采样点的光照<br><img src="/images/article/Games104/05/Games104_05_28.png"><span class="image-caption">光照采集点</span></p><p>那么这么多的采样点我们该如何生成呢？我们首先在空间内均匀的产生采样点，再根据玩家的可到达区域和建筑物的几何结构进行延拓，相对均匀的分布采样点<br><img src="/images/article/Games104/05/Games104_05_29.png"><span class="image-caption">自动生成采集点</span></p><h3 id="反射采集点（Reflection-Probe）"><a href="#反射采集点（Reflection-Probe）" class="headerlink" title="反射采集点（Reflection Probe）"></a>反射采集点（Reflection Probe）</h3><p>我们还会做一些数量不多但采样精度非常高的Reflection Probe用于表现环境，一般它们与Light Probe分开采样<br><img src="/images/article/Games104/05/Games104_05_30.png"><span class="image-caption">反射采集</span></p><p>综合使用Light Probes和Reflection Probes，我们已经可以实现一个不错的全局光照的效果，它给我们带来以下好处：</p><ul><li>实时运行效率很高</li><li>既可以处理动态物体又可以处理静态物体，并且可以实时更新</li><li>既可以处理漫反射也可以处理镜面着色</li></ul><p>当然它也有一些缺陷：</p><ul><li>大量的Light probes需要我们进行预计算</li><li>相比于Lightmap，它对于全局光照和重叠部分的软阴影的细节处理精度较低</li></ul><p><img src="/images/article/Games104/05/Games104_05_31.png"><span class="image-caption">光照采集和反射采集</span></p><h2 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h2><p>全局光照是我们可以模拟真实世界的一个必要条件，在拥有GI之后，我们可以去模拟真实世界了。</p><h3 id="微平面理论（Microfacet-Theory）"><a href="#微平面理论（Microfacet-Theory）" class="headerlink" title="微平面理论（Microfacet Theory）"></a>微平面理论（Microfacet Theory）</h3><p>微平面理论看上去很高大上，但实际上它所表达的东西很简单：</p><p>一个表面上其实是有无数个微表面，而光其实是在这些微表面上进行反射打出去的，一个金属表面是粗糙还是光滑，实际上是和平面上的法向聚集度相关的：</p><ul><li>如果微表面们的法向朝向比较相似，其表现为金属材质较为清晰的反射（反射方向大致一致，完全一致则为镜子）</li><li>如果微表面们的法向朝向几乎不相同，其表现为金属材质较为粗糙的反射（反射方向为四面八方）</li></ul><p><img src="/images/article/Games104/05/Games104_05_32.png"><span class="image-caption">微面理论</span></p><h3 id="基于微平面理论的BRDF模型"><a href="#基于微平面理论的BRDF模型" class="headerlink" title="基于微平面理论的BRDF模型"></a>基于微平面理论的BRDF模型</h3><p>因此基于微表面理论的基础上引入了一个反射模型，现如今大家用的最多的这类模型叫GGX。</p><p>渲染方程中，使用BRDF模型来处理物体反射效果，其中反射分为漫反射（diffuse）和高光（spectual）。</p><p>我们知道当光打到一个物体上时，只会发生两种情况：</p><ul><li>部分光打到物体表面最后被反射，反射能量的多少取决于表面上法向的分布，也就是roughness(粗糙度)，roughness越高，随机性越强，而roughness越低，随机性就地，大部分法向相似，也就越接近于镜面反射。</li><li>部分光被吸收进入物体中，金属物体的电子可以捕获光子，而非金属没有能力捕获光子，因此进入的光会在内部进行几次弹射后，最后以一个随即方向射出去，因此一束光打入物体在经历几次折射后最后发生漫反射现象。</li></ul><p>因此PBR模型其实可以分为两个PART：</p><ul><li>lambert的漫反射（diffuse）部分，如果将球面所有的漫反射部分积分起来的话结果为  ，C的大小取决于多少能量可以进来。</li><li>specular，反射的这一部分引入了著名的cook-Torrance模型，可以看到它的公式中有DFG这三项，每一项代表了一种光学现象。</li></ul><p><img src="/images/article/Games104/05/Games104_05_33.png"><span class="image-caption">基于微平面理论的BRDF模型</span></p><p>DFG模型中的D指法向分布方程（Normal Distribution Function）、F指菲涅尔现象（Fresnel Equation）、<br>G指微表面几何内部的自遮挡（Geometric attenuation term）</p><h4 id="D（Normal-Distribution）-表示法线分布，反应的是normal分布是发散还是聚集。"><a href="#D（Normal-Distribution）-表示法线分布，反应的是normal分布是发散还是聚集。" class="headerlink" title="D（Normal Distribution） 表示法线分布，反应的是normal分布是发散还是聚集。"></a>D（Normal Distribution） 表示法线分布，反应的是normal分布是发散还是聚集。</h4><p>左下角是GGX模型和Phong模型对比，我们可以发现GGX模型的变化足够快并且底部足够平滑，<br>也就是高频部分突出，低频部分变化慢不像Phong一样快速衰减。</p><p>将GGX模型比作音箱来理解就是，高音够脆，低音够沉，范围广，这样的表现力才强。</p><p>因此当我们用GGX模型来表达高光时，高频部分的波峰足够陡，当光是“混响”时，高光并不会消失的很彻底，<br>低频也有很好的表达效果，而当我们在调整Phong模型的pow时，如果没有调好pow，会发现高光部分边界很生硬，<br>就像一张狗皮膏药贴在上面一样，但是用了GGX模型时，过渡比较顺滑，在低频高频上都有很好的效果。</p><p>在右下角伪代码中我们可以发现，我们引入了一个α值，其代表的是roughness，表达法向分布的随机度,roughness越高，<br>随机度越高，也就越发散。引入这个值的好处在于可以参与D和G的运算，引入了一个值（参数）从而可以计算出两个结果。<br>那么我们接下来根据roughness来计算G。<br><img src="/images/article/Games104/05/Games104_05_34.png"><span class="image-caption">分布方程（Normal Distribution Function）</span></p><h4 id="G-Geometric-attenuation-term-微表面几何内部的自遮挡"><a href="#G-Geometric-attenuation-term-微表面几何内部的自遮挡" class="headerlink" title="G (Geometric attenuation term) 微表面几何内部的自遮挡"></a>G (Geometric attenuation term) 微表面几何内部的自遮挡</h4><p>由于表面是凹凸不平的，当一束光射到物体上进行反射的时候，反射的光可能会被其他微平面挡住。</p><p>我们这里需要理解方程含义，他所代表的意义是： </p><p>在基于微表面理论的基础上，我们认为表面上的法线形成了一个roughness的分布方程，<br>根据这个roughness的分布方程我们可以用积分的方法大致估算出每个角度上大致有多少光被挡住，<br>伪代码中的GGX函数的目的是为了计算出阻挡性，而G_Smith是在将光的阻挡性和视线的阻挡性计算出之后，<br>将两个阻挡性相乘，从而知道有多少光从入射表面到弹到眼睛时被挡住了。</p><p>举个例子，一束光以100%的能量射入到表面上，根据NDF方程（roughness分布方程），<br>我们知道30%的光被遮挡了，因此此时的光的能量是70%，这些光又是无数个光子，这些光子开始朝眼睛运动，<br>由于分布时各向同性的，因此70%的能量中又有30%被遮挡了，最后到达眼睛的能量就是70% X 70% = 49%。<br><img src="/images/article/Games104/05/Games104_05_35.png"><span class="image-caption">微表面几何内部的自遮挡（Geometric attenuation term）</span></p><h4 id="F（Fresnel）菲尼尔现象"><a href="#F（Fresnel）菲尼尔现象" class="headerlink" title="F（Fresnel）菲尼尔现象"></a>F（Fresnel）菲尼尔现象</h4><p>什么是菲涅尔现象？</p><p>当你的眼睛视线足够靠近表面的切线方向时，反射系数会急剧增加，从而会产生一种倒影的效果。</p><p>视线与平面的夹角约大，人眼接收到的反射约弱。</p><p>反射效果越弱，水体看起来越透明，像空气；反射效果越强，水体看起来越光滑，像镜子。</p><p>如图我们可以知道，摄像头在固定位置，而他所照出来的图片在近处看感觉清澈见底，在远处看则像是一面镜子反射出了山，<br>这就是因为在同一位置对不同位置进行观察时，视线与平面的夹角不同，观察近处时与平面夹角大，观察远处时夹角小。</p><p>因此，当你的视线与水平面接近时，此时就会产生很强的镜面效果。</p><p>这样Cook-Torrance模型就可以通过roughness以及fresnel这两个参数来很好的模拟出符合物理规则的材质。<br><img src="/images/article/Games104/05/Games104_05_36.png"><span class="image-caption">菲涅尔现象（Fresnel Equation）</span></p><h3 id="MERl-BRDF"><a href="#MERl-BRDF" class="headerlink" title="MERl BRDF"></a>MERl BRDF</h3><p>现在我们有了表面上的法线朝向分布情况，引入了roughness参数，<br>并且根据分布方程和roughness计算出了各个角度的阻挡性，又引入了fresnel从而模拟fresnel现象，<br>已经能够很好表达物理世界的效果，但是现实世界的物体仍然很复杂，想要通过艺术家手动调参的方式来实现仍然有一定难度。</p><p>MERL BRDF数据库是对大量现实中的物体进行采样，提供个各种材质对应的BRDF参数，<br>从而提供了不同材质的roughness参数和菲尼尔参数，也表达了diffuse应该是多少。<br><img src="/images/article/Games104/05/Games104_05_37.png"><span class="image-caption">基于物理的测量材料</span></p><h3 id="Disney-BRDF-Principle"><a href="#Disney-BRDF-Principle" class="headerlink" title="Disney BRDF Principle"></a>Disney BRDF Principle</h3><p>在最早期时候，艺术家对于cook-torrance的使用并不成熟，<br>导致了很多的问题，比如能量不守恒的话，光线bounce几次之后lightmap的计算就会爆炸了。</p><p>这时候Disney的一位大神提出了几条规则：</p><ul><li>物理材质的每个参数需要符合直觉且容易让艺术家明白，不可以很抽象</li><li>要尽量使用较少的参数</li><li>参数要尽量在0~1之间</li><li>需要一些特殊效果时参数可以超出0~1这个区间</li><li>所有参数的组合应该是合理的，不会出现诡异的结果</li></ul><p><img src="/images/article/Games104/05/Games104_05_38.png"><span class="image-caption">迪士尼BRDF原则</span></p><h3 id="PBR主流模型"><a href="#PBR主流模型" class="headerlink" title="PBR主流模型"></a>PBR主流模型</h3><p>Specular Glossiness（SG），这个模型中Diffuse控制漫反射部分，Specular控制菲涅尔现象，<br>Glossiness控制材质的光滑程度。这一模型的参数设置较少，便于艺术家们使用，但也因其过于灵敏而容易导致奇怪的现象。<br><img src="/images/article/Games104/05/Games104_05_39.png"><span class="image-caption">Specular Glossiness</span></p><p>Metallic Roughness（MR），这一模型中首先设置一个Base Color，而后通过金属度（Metallic）来控制Diffuse和菲涅尔现象。<br>仅调节金属度虽然使得灵活度下降了，但却不容易出问题，这也使得MR模型现今被更多的使用<br><img src="/images/article/Games104/05/Games104_05_40.png"><span class="image-caption">Metallic Roughness</span></p><p>我们可以从MR模型转换为SG模型<br><img src="/images/article/Games104/05/Games104_05_41.png"><span class="image-caption">MR模型转换为SG模型</span></p><p>下图为MR模型和SG模型优缺点的对比<br><img src="/images/article/Games104/05/Games104_05_42.png"><span class="image-caption">MR模型和SG模型对比</span></p><h2 id="基于图像的光照-Image-Based-Lighting"><a href="#基于图像的光照-Image-Based-Lighting" class="headerlink" title="基于图像的光照 (Image-Based Lighting)"></a>基于图像的光照 (Image-Based Lighting)</h2><p>IBL的核心思想是：若我们能对环境光照的信息进行一些预处理，是否能减少光照处理中积分运算消耗的时间<br><img src="/images/article/Games104/05/Games104_05_43.png"><span class="image-caption">IBL核心思想</span></p><p>BRDF的材质模型分为diffuse和specular两部分：<br><img src="/images/article/Games104/05/Games104_05_44.png"><span class="image-caption">BRDF的材质模型</span></p><p>对于漫反射部分的光照，我们可以预先进行对应的卷积运算，并将其储存在Irradiance Map中<br><img src="/images/article/Games104/05/Games104_05_45.png"><span class="image-caption">Diffuse</span></p><p>对于Specular部分，它涉及大量复杂的计算，可以近似为Lighting Term和BRDF Term的乘积<br><img src="/images/article/Games104/05/Games104_05_46.png"><span class="image-caption">Specular</span><br><img src="/images/article/Games104/05/Games104_05_47.png"><span class="image-caption">第一部分</span><br><img src="/images/article/Games104/05/Games104_05_48.png"><span class="image-caption">第二部分</span></p><p>通过预计算能快速的将shading point的光照信息通过预计算求出：<br><img src="/images/article/Games104/05/Games104_05_49.png"><span class="image-caption">预计算</span></p><p>从而让我们在环境光照中得到一个不是很shiny的高光。<br>通过对比，我们可以看到开了IBL的环境场景更加层次分明。<br><img src="/images/article/Games104/05/Games104_05_50.png"><span class="image-caption">IBL对比</span></p><h2 id="经典阴影方法"><a href="#经典阴影方法" class="headerlink" title="经典阴影方法"></a>经典阴影方法</h2><p>其实游戏中经典主流的shadow算法是cascade shadow，cascade可以理解为一层层的楼梯的场景<br><img src="/images/article/Games104/05/Games104_05_51.png"><span class="image-caption">cascade shadow</span></p><p>例如10米内的物体的shadow，我们采用高精度的shadow map，然后根据距离的增加，我们逐渐降低shadow map的精度，<br>这样最后绘制出来的shadow，近处的shadow足够清晰，远处的shadow足够稀疏，这样也符合一个光学原理，近大远小的特点，<br>近处的采样率高，远处的采样率低，眼睛的采样率从下降因此远处的从光的采样率也下降，从而使用了低精度的shadow map使得完美契合。<br><img src="/images/article/Games104/05/Games104_05_52.png"><span class="image-caption">cascade shadow步骤</span></p><p>但是cascade shadow有一个问题，就是由于分成了不同层级采用了不同的采样精度，<br>因此不同层级之间的交界处需要进行插值处理，否则就会产生一个很生硬的边界。<br><img src="/images/article/Games104/05/Games104_05_53.png"><span class="image-caption">边界问题</span></p><p>优点：</p><ul><li>很快,因为用空间换时间，但它消耗的存储空间十分大。</li><li>效果比较好。</li></ul><p>缺点：</p><ul><li>近处的shadow质量不会特别高。</li><li>shadows没有颜色</li><li>透明的物体会显示不透明的阴影。</li></ul><p><img src="/images/article/Games104/05/Games104_05_54.png"><span class="image-caption">cascade shadow优缺点</span></p><h3 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h3><h4 id="PCF-PercentageCloserFilter"><a href="#PCF-PercentageCloserFilter" class="headerlink" title="PCF-PercentageCloserFilter"></a>PCF-PercentageCloserFilter</h4><p>原理:对当前像素周围的阴影地图进行采样，并将其深度与所有的采样进行比较，通过插值，我们得到了光和影之间更平滑的线<br><img src="/images/article/Games104/05/Games104_05_55.png"><span class="image-caption">PCF</span></p><h4 id="PCSS-PercentageCloserSoftShadow"><a href="#PCSS-PercentageCloserSoftShadow" class="headerlink" title="PCSS - PercentageCloserSoftShadow"></a>PCSS - PercentageCloserSoftShadow</h4><p>根据物体距离光源的远近，确定阴影的质量。<br><img src="/images/article/Games104/05/Games104_05_56.png"><span class="image-caption">PCSS</span></p><h4 id="Variance-Soft-Shadow-Map"><a href="#Variance-Soft-Shadow-Map" class="headerlink" title="Variance Soft Shadow Map"></a>Variance Soft Shadow Map</h4><p>利用深度的平均值和方差，直接接近深度分布的百分比，而不是将单个深度与特定区域进行比较。<br><img src="/images/article/Games104/05/Games104_05_57.png"><span class="image-caption">Variance Soft Shadow Map</span></p><h4 id="上个时代的3A标配选择"><a href="#上个时代的3A标配选择" class="headerlink" title="上个时代的3A标配选择"></a>上个时代的3A标配选择</h4><ul><li>光照:Lightmap + Lightprobe。都会有解决不同的问题</li><li>材质:PBR(SG、MR) + IBL(背光、环境光)</li><li>Shadow:CascadeShadow+VSSM</li></ul><p><img src="/images/article/Games104/05/Games104_05_58.png"><span class="image-caption">上个时代的3A标配选择</span></p><h2 id="前沿技术"><a href="#前沿技术" class="headerlink" title="前沿技术"></a>前沿技术</h2><h3 id="着色器模型（Shader-Model）"><a href="#着色器模型（Shader-Model）" class="headerlink" title="着色器模型（Shader Model）"></a>着色器模型（Shader Model）</h3><ul><li>Compute shader</li><li>Mesh shader</li><li>Ray-tracing shader</li></ul><p><img src="/images/article/Games104/05/Games104_05_59.png"><span class="image-caption">Shader Model</span></p><h3 id="实时光线追踪（Real-Time-Ray-Tracing）"><a href="#实时光线追踪（Real-Time-Ray-Tracing）" class="headerlink" title="实时光线追踪（Real-Time Ray-Tracing）"></a>实时光线追踪（Real-Time Ray-Tracing）</h3><p>上面讲到的GI算法，其实都不是真实的实时光照处理，它们都有一定的预计算或者很多非常规假设。<br>但在新一代硬件支持下，实时光线追踪的处理方式出现了，虽然现在还没有能够大规模普及，但这项技术已经在突破的边缘。</p><p>2018年NVIDIA宣布了可加速硬件中光线追踪速度的新架构Turing，以及搭载实时光线追踪技术的RTX系列显卡。<br>同年，第一款搭载RTX实时混合光线追踪技术的游戏《战地5（Battlefield V）》正式面世<br><img src="/images/article/Games104/05/Games104_05_60.png"><span class="image-caption">实时光线追踪</span></p><h3 id="实时GI（Real-Time-Global-Illumination）"><a href="#实时GI（Real-Time-Global-Illumination）" class="headerlink" title="实时GI（Real-Time Global Illumination）"></a>实时GI（Real-Time Global Illumination）</h3><p><img src="/images/article/Games104/05/Games104_05_61.png"><span class="image-caption">实时GI</span></p><h3 id="更多复杂材质"><a href="#更多复杂材质" class="headerlink" title="更多复杂材质"></a>更多复杂材质</h3><p>毛发渲染，皮肤渲染等复杂材质的渲染。<br><img src="/images/article/Games104/05/Games104_05_62.png"><span class="image-caption">更多复杂材质</span></p><h3 id="Virtual-Shadow-Maps"><a href="#Virtual-Shadow-Maps" class="headerlink" title="Virtual Shadow Maps"></a>Virtual Shadow Maps</h3><p>Virtual Shadow Maps和Virtual Texture原理很像。Virtual Texture是将游戏中需要用到的所有纹理Pack到一张纹理中，<br>需要使用时就加载调用，不需要时就进行卸载。</p><p>Virtual Shadow Maps首先计算哪些地方需要Shadow Map，然后在一个完整虚拟的Shadow Map中去分配空间，<br>每小块得生成Shadow Maps。在计算Shadow时，反向去取小格数据。这种处理方式可以更有效利用存储空间。<br><img src="/images/article/Games104/05/Games104_05_63.png"><span class="image-caption">Virtual Shadow Maps</span></p><h3 id="Uber-Shader"><a href="#Uber-Shader" class="headerlink" title="Uber Shader"></a>Uber Shader</h3><p>通过宏定义不同情况下的Shader组合，在编译时生成大量独立的Shader代码，<br>这就是所谓Uber Shader(类似Unity中的Shader变体概念)。这样的好处是，当Shader发生变化时，<br>只需修改组合Shader后重新编译。<br><img src="/images/article/Games104/05/Games104_05_64.png"><span class="image-caption">Uber Shader</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/543728861">参考文章1</a></p><p><a href="https://zhuanlan.zhihu.com/p/512998645">参考文章2</a></p><p><a href="https://www.bilibili.com/video/BV1J3411n7WT/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture05_Rendering%20on%20Game%20Engine_Lighting,%20Materials%20and%20Shaders.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU 工作原理</title>
      <link href="/posts/3e8e8143.html"/>
      <url>/posts/3e8e8143.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么GUP计算是可行的（我的数据在哪里）"><a href="#为什么GUP计算是可行的（我的数据在哪里）" class="headerlink" title="为什么GUP计算是可行的（我的数据在哪里）"></a>为什么GUP计算是可行的（我的数据在哪里）</h2><p>Flops(每秒种浮点运算次数)跟机器的算力有关<br>在购买机器的时候 nobody cares about flops 或者说 almost nobody really cares about flops</p><p>CPU大约每秒能进行2万次的双精度（FP64）运算。<br>内存将数据传送到CPU，每秒传输大约200G字节，也就是每秒25G的FP64数值。<br>因为每个FP64是8字节，所以内存每秒可以提供250亿个FP64值，CPU每秒能处理2万亿个FP64数据</p><p>每秒内存需要同时传输80次数据给CPU才能让CPU满载<br><img src="/images/article/GPUWorkingPrinciple/ComputeIntensity.png"><span class="image-caption">计算强度</span></p><p>不同CPU的计算强度都差不多，Flops处理能力越强就会有更大的内存带宽来平衡它，<br>当Flops的速度比内存宽带的速度块，计算强度就会上升<br><img src="/images/article/GPUWorkingPrinciple/CPUVSGPU.png"><span class="image-caption">CPU vs GPU</span></p><p>因为Flops被内存带宽完全的限制住了，随意每次加载100个程序是十分困难的，<br>这还不是全部，我们更关心的是延迟（Latency）而不是内存带宽（Memory bandwidth）<br><img src="/images/article/GPUWorkingPrinciple/Because.png"><span class="image-caption">Because</span></p><p>通过方程aX + Y = Z，分别加载X和Y等待延迟读取到数据后进行计算得到结果，这就是核心的指令流水线<br><img src="/images/article/GPUWorkingPrinciple/Daxpy.png"><span class="image-caption">数乘(daxpy)</span></p><p>在一个时钟周期内光传播的距离只有10厘米，所以时钟频率太快而光走不了多远。<br>电流在硅中的传播速度只有光的五分之一（6万公里/秒），<br>一个时钟周期内，电流的移动只有20毫米。<br>内存到CPU的路程需要有5-7个时钟周期的延迟，因为物理上的原因，<br>在内存中提取数据时需要5-10个时钟周期才能放回到CPU。<br><img src="/images/article/GPUWorkingPrinciple/Distance.png"><span class="image-caption">内存到CPU距离</span></p><p>CPU很快，内存很慢。所以整体效率很低<br><img src="/images/article/GPUWorkingPrinciple/Utilization.png"><span class="image-caption">利用率</span></p><p>虽然0.14%的利用率很低，但是已近算很好了，这就是程序受到了延迟限制（latency bound）的影响，<br>它发生次数远比我们认为的要多。延迟限制是内存限制类别的一个子集，<br>它主要发生在不需要立即从内存中检索太多的数据，但是在内存层次结构的上层，<br>必须等待很长事件才能将数据发送到处理器的情况。<br><img src="/images/article/GPUWorkingPrinciple/UtilizationComparison.png"><span class="image-caption">利用率对比</span></p><p>GPU要充分利用内存，按起前面的数据 11659/16=729 一次需要运行729次迭代才能让内存保存满负荷运转<br><img src="/images/article/GPUWorkingPrinciple/GPUUtilization.png"><span class="image-caption">GPU利用率</span></p><h3 id="Loop-Unrolling（循环展开）"><a href="#Loop-Unrolling（循环展开）" class="headerlink" title="Loop Unrolling（循环展开）"></a>Loop Unrolling（循环展开）</h3><p>编译器有一种优化器叫做Loop Unrolling（循环展开）</p><ul><li>循环展开可以由程序员完成，也可由编辑器自动优化完成。</li><li>循环展开是通过将循环体代码复制多次实现</li><li>循环展开能够增大指令调度的空间，减少循环分支指令的开销</li><li>循环展开可以更好的实现数据预取技术</li></ul><p>循环展开发现只有一个进程和延迟时间，通过发出back to back all at once信号加载 x 和 y<br>一次循环中可以做很多次，它受到硬件能跟踪多少操作请求的限制，它可以在指令流水线中缓存指令，<br>但是它必须追踪每一个请求。虽然我只有一个进程，但循环展开之后有729个迭代请求也没问题<br><img src="/images/article/GPUWorkingPrinciple/GPUParallel.png"><span class="image-caption">GPU并行计算</span></p><p>并行性（parallelism）比并发性（concurrency）强，对吗？</p><ul><li>并行的关键是你有同时处理多个任务的能力（每个线程同时执行一个操作，但是硬件可以处理许多线程）</li><li>并发的关键是你有处理多个任务的能力，不一定要同时</li></ul><h3 id="GPU和CPU对比"><a href="#GPU和CPU对比" class="headerlink" title="GPU和CPU对比"></a>GPU和CPU对比</h3><p>我们可以通过循环展开多线程操作提高硬件的使用效率，同样也允许我使用较少的线程。<br>GPU比CPU不同的是有更高的延迟和更多的线程。<br>如果有一些线程正在等待内存，那么还有更多的线程等待激活，GPU就是所谓的吞吐机。<br>GPU的设计师将所有资源投入到更多线程中而不是减少延迟。<br>CPU是一台延迟机，CPU的期望是一个线程基本完成所有的工作，<br>将一个线程从一个切换到另一个是非常昂贵的，就像上下文切换一样。<br>所以你只需要足够的线程就可以解决延迟的问题，而CPU设置值把所有的资源都投入到减少延迟上了。<br><img src="/images/article/GPUWorkingPrinciple/Contrast.png"><span class="image-caption">对比</span></p><h2 id="介绍GPU"><a href="#介绍GPU" class="headerlink" title="介绍GPU"></a>介绍GPU</h2><p>GPU解决的方式和CPU完全不同，但是内存是最重要的，所有的程序都是和内存相关，<br>内存带宽、内存延迟以及数据在内存中的位置。</p><h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><p>我把寄存器（Register File）作为Cache的一种，这是一个非常重要的GPU细节，<br>GPU在每个线程中使用大量的寄存器，寄存器能够以很低的延迟来保存活动的数据，<br>因为不同类型的缓存延迟差距很大。硬件需要一个地方存储指针，<br>所以当我从内存中加载数据并放到寄存器中，我就可以计算它了，<br>我可做的内存操作与寄存器的数量直接相关，GPU使用寄存器缓存数据解决高延迟问题，以及通过靠近数据来减少延迟。<br><img src="/images/article/GPUWorkingPrinciple/Cache.png"><span class="image-caption">缓存</span></p><p>L1、L2、HBM缓存结构总览<br><img src="/images/article/GPUWorkingPrinciple/CacheContrast.png"><span class="image-caption">缓存对比</span></p><p>L1、L2、HBM缓存，L1的带宽是最强的，PCIe是最差的，PCIe在这里没有作用，<br>只是因为它连接GPU和CPU，但我认为NVLink比PCIe更接近主内存领域，NVLink是GPU之间相连的<br><img src="/images/article/GPUWorkingPrinciple/CacheContrast2.png"><span class="image-caption">缓存对比2</span></p><p>带宽在增加，你需要为主内存准备几乎相同数量的线程（下图是39264），<br>因为计算强度很高，所以如果这个内存系统中有一个比其他需要更多的线程，就会发现它的瓶颈，<br>我必须加入更多线程去满足那部分，然后我的内存系统的其他部分便会拥有更多线程，这是一种精心设计的平衡。</p><p><img src="/images/article/GPUWorkingPrinciple/CacheContrast3.png"><span class="image-caption">缓存对比3</span></p><p>SM是一个基础处理单元，它里面有很多东西，实际上要记住的是warp，它有32个线程组成一组，<br>warp就是GPU的基本调度单位，在一个时钟周期内，我可以运行多个warp，一个SM，包含64个warps，<br>4个warps可以并行运行。<br><img src="/images/article/GPUWorkingPrinciple/SM.png"><span class="image-caption">SM</span></p><p>每个SM 2048个线程，120个线程我一次就能跑完了，这就是我说的GPU是超量配额的原因。<br>当一些线程因为等待延迟关闭时，其他线程大概已经收到了他们的响应，准备运行了（随时切换线程），<br>这就是GPU工作的全部秘密， 它可以在不同warp之间切换，并且在一个时钟周期内完成，所以根本没有上下文开销。<br>GPU可以连续运行线程，这意味着系统在任何我时候都能运行更多的线程是非常重要的，因为这是解决延迟的好方法。<br>为什么不希望固定线程，因为GPU是一个吞吐机<br><img src="/images/article/GPUWorkingPrinciple/SM2.png"><span class="image-caption">SM2</span></p><p>汽车不能快速有效的帮助其他人，他只能载少数人从一个地方到另一个地方，<br>火车可以载很多人，会停很多地方，所以在这条线路上的所有人都能得到帮助，<br>而且沿途可以有很多火车，关于延迟系统很可怕的一个事就是过载，<br>开车如果路上太多车你哪里都去不到，火车满了可以等下一列，<br>GPU是一个吞吐机，就像火车一样，让你在站台等，而且需要保持忙碌，<br>而CPU是一个延迟机，切换线程开销很大，所以需要一个线程尽快的运行。<br><img src="/images/article/GPUWorkingPrinciple/ThroughputMachineAndDelayMachine.png"><span class="image-caption">吞吐机和延迟机</span></p><ul><li>元素智能算法（Element-wise）：两个张量之间操作，它在对应张量内的元素进行操作</li><li>Local：比如卷积，它会引入所有邻居</li><li>all to all：比如傅里叶转换（Fourier Transform），要求每个元素与其他元素相互作用</li></ul><p><img src="/images/article/GPUWorkingPrinciple/Algorithm.png"><span class="image-caption">算法</span></p><h3 id="如何获取吞吐量"><a href="#如何获取吞吐量" class="headerlink" title="如何获取吞吐量"></a>如何获取吞吐量</h3><p>一张猫的图片，将用一个网格覆盖，将网格创建许多工作块，随每个方块单独进行处理，<br>让这些方块彼此独立处理图像的不同部分，GPU通过超量分配（oversubscribe）加载这些块，<br>我们想要的是高效执行和内存满载使用。因此，多个块由许多一起工作的线程组成，<br>这些线程可以共享数据并实现联合任务，该块中的所有线程同时并行运行。<br><img src="/images/article/GPUWorkingPrinciple/GetThroughput.png"><span class="image-caption">获取吞吐量</span></p><p>要做工作，都被分解成线程块，每个块都有并行线程，确保线程同时运行，这样他们就可以共享数据，<br>但所有块都是超量分配模式下独立调度的。我需要通过吞吐机器保持忙碌，但它也允许一定数量的线程相互交互，<br>这就是GPU编程的本质<br><img src="/images/article/GPUWorkingPrinciple/IndependentDispatching.png"><span class="image-caption">独立调度</span></p><p>延迟才是我真正要关心的，所有这些线程都是通过超量分配：程序、网格模型、线程，<br>所有的都在我的块中运行，从根本上解决延迟问题。</p><p>现在我有很多线程，根据前面那个表，我有5倍的线程，远远超过我需要的线程，问题是那么多的线程如何调度。<br>这归结到算法的复杂性，也就是说，我增加问题的规模，我可以增加很多线程，但我要怎么操作呢？<br>例如对于Element-wise，每次我添加一个线程，我都加载一个新的数据元素，但是我只做了一次操作，<br>我添加了一个线程，加载数据一部分，载做一个计算，我添加的线程实际上不会带来变化，我所请求的Flops增加了，<br>但我的算法以及算法的强度是平滑的，比如2D、卷积或者3D。我现在的数据，当我增加方块是，它是可扩展的。<br>它的算术强度是1：1计算，在卷积中即使再多的数据也无法与我的计算强度抗衡（线程和计算量同时增大）。<br><img src="/images/article/GPUWorkingPrinciple/IndependentDispatching2.png"><span class="image-caption">独立调度2</span></p><p>矩阵乘法是一个大而复杂的东西，但它是由大量的FMA（Fused-Multiply-Add）堆积起来的。<br>它重复计算很多次，这个矩阵每个绿点装载25次，我只处理了这一行并用作25次计算，<br>如果矩阵是10X10，我会以100次操作的速度重复使用它，这就是我想要的计算机强度，<br>因此，随着矩阵的增长，极大地提高我的Flops能力<br><img src="/images/article/GPUWorkingPrinciple/Matrix.png"><span class="image-caption">矩阵</span></p><p>所以矩阵乘法具有算术强度，它增加矩阵立方的大小，这就是矩阵乘法的本质。<br>同时，随着矩阵变大，数据加载量承指数级增加，我已经对正在加载的数据增添了指数，<br>所以我的算术强度、扩展性、算法复杂度是有序的。<br><img src="/images/article/GPUWorkingPrinciple/MatrixMultiplication.png"><span class="image-caption">矩阵相乘</span></p><p>这两个线的交点在50，一旦矩阵大小达到50，我们就会获取所有数据，为了满足Flops需求，<br>计算机会抓取所有它能处理的数据，所以这就是我能有效计算的最大矩阵，我的内存现在比计算要空闲的多，<br>理想情况下，为了让你的机器保存平衡，需要让一切都以100%的速度运行，这就是吞吐机的意义所在，<br>所以最佳点就是这条线的交点。<br><img src="/images/article/GPUWorkingPrinciple/EffectiveCalculation.png"><span class="image-caption">有效计算</span></p><p>下图是FP32和FP64的交点的比较，计算强度100的线，到达100将会达到双精度计算的最大值，<br>当然，随着矩阵增大，内存会变得越来越空闲，因为我要花越来越多的时间来计算。<br><img src="/images/article/GPUWorkingPrinciple/EffectiveCalculationComparison.png"><span class="image-caption">有效计算对比</span></p><p>所以现在我们可以引入Tensor Core，Tensor Core是内置在SM中的定制硬件单元，<br>很像一个算术单元，我可以乘或加运算，但是它们可以一次性完成整个矩阵运算，<br>这意味着它们可以一步完成多个Flops请求任务，FMA每个指令可以做两个乘加运算，<br>它为每个指令增加了两个Flops，这些张量核心能够比Cuda核心实现更多的Flops。<br>我想要跑到更快，但是更大的Flops需要更大的问题规模，当内存空间用完时，就无法增大Flops了。<br><img src="/images/article/GPUWorkingPrinciple/TensorCore.png"><span class="image-caption">Tensor Core</span></p><p>HBM计算强度有400，这就是为什么它需要使用HBM内存进行操作。<br>如果使用L2缓存，我都计算强度只有156，L1更小，只有32，<br>所以我显然需要使用缓存来搭配我的张量核心，使它在最小矩阵下更高效。<br><img src="/images/article/GPUWorkingPrinciple/CacheContrast2.png"><span class="image-caption">缓存对比2</span></p><p>在我的主存储器里是400，L2是156，L1中是32，我可以快速处理小矩阵，因为我已经改变数据所在的位置。<br><img src="/images/article/GPUWorkingPrinciple/CacheContrast4.png"><span class="image-caption">缓存对比4</span></p><p><a href="https://www.bilibili.com/video/BV17L4y1a7Xy?spm_id_from=333.880.my_history.page.click&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53">参考视频</a></p>]]></content>
      
      
      <categories>
          
          <category> gpu </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎中的渲染实践（四）</title>
      <link href="/posts/3d4c0b0.html"/>
      <url>/posts/3d4c0b0.html</url>
      
        <content type="html"><![CDATA[<h2 id="渲染概述"><a href="#渲染概述" class="headerlink" title="渲染概述"></a>渲染概述</h2><p>渲染是游戏引擎的基础，而渲染的理论基础是计算机图形学。但计算机图形学与游戏渲染存在一些区别：</p><ul><li>计算机图形学面对的问题是明确单一的。</li><li>计算机图形学更多关注算法的正确性。</li><li>计算机图形学没有严格的性能需求。</li></ul><p>游戏渲染面对的挑战：</p><ul><li>游戏融合了大量渲染效果，复杂度很高</li><li>游戏需要面对硬件处理问题</li><li>游戏在不同的场景下需要有稳定的帧率</li><li>游戏CPU端大量的计算需要分配给GamePlay</li></ul><p><img src="/images/article/Games104/04/Games104_04_01.png"><span class="image-caption">渲染大纲</span></p><h2 id="渲染系统的对象"><a href="#渲染系统的对象" class="headerlink" title="渲染系统的对象"></a>渲染系统的对象</h2><p><img src="/images/article/Games104/04/Games104_04_02.png"><span class="image-caption">渲染管道和数据</span><br>现代游戏渲染是通过CPU+GPU合作处理模式。CPU准备好数据渲染数据后将其提交到GPU，GPU设置好渲染状态后开始处理CPU所提交的数据。</p><p>GPU拿到顶点数据集后，对这些顶点进行空间坐标转换（MVP）投射到屏幕中，并组装成三角面。<br>现代的显示器通常是栅格化的，因此需要将三角面映射到屏幕中的像素，最终对这些像素进行着色处理。<br><img src="/images/article/Games104/04/Games104_04_03.png"><span class="image-caption">计算投影和光栅化</span></p><p>Shading涉及到的计算：</p><ul><li>常量访问，比如需要知道屏幕的长宽，像素个数，需要访问常数</li><li>数学计算（加减乘除），比如冯模型需要知道法线，光线，眼睛，并计算光有衰减百分比</li><li>纹理采样</li></ul><p><img src="/images/article/Games104/04/Games104_04_04.png"><span class="image-caption">着色计算类型</span></p><p>纹理采样其实是rendering过程中非常昂贵的一个环节，当我们在不同距离观察物体的时候，可以看到物体上的一个个或者空间上的像素。<br>为了避免纹理采样时的锯齿问题，通常会对纹理进行差值处理。当纹理小于采样区域时，可通过双线性插值的方式进行处理；<br>当纹理区域大于采样区域时，可通过Mipmap、各向异性过滤、EWA过滤等方式处理。</p><h2 id="了解GPU"><a href="#了解GPU" class="headerlink" title="了解GPU"></a><a href="/2022/09/04/GPU-Working-Principle/">了解GPU</a></h2><p>现在CPU中已经广泛使用了SIMD(Single Instruction Multiple Threads)单指令多数据的处理方式，通常为矢量数据。<br>例如一个32bit位宽的4维向量vec4，一条指令最快就在一个cycle执行完。那SIMT，最快要用4个cycles来完成。</p><p>而GPU在多核中使用SIMT指令来实现类似SIMD功能，并且支持分支跳转。在SIMT的架构上，会把vec4分解开，然后一个cycle处理完一个数据。<br>所以最快需要4个cycle。<br><img src="/images/article/Games104/04/Games104_04_05.png"><span class="image-caption">SIMD和SIMT架构</span></p><p>Fermi是第一个完整的GPU计算架构。GPU中分为很多组内核，一组内核称为GPC（Graphics Progressing Cluster）。<br>GPC中存在很多小的内核，这些内核是指令的直接执行者。Texture Unit进行纹理采样，CUDA Core用于多核之间的数据交换<br><img src="/images/article/Games104/04/Games104_04_06.png"><span class="image-caption">Fermi架构</span></p><p>CPU和GPU可以看做是独立的机器，两个机器之间的数据传递成本很高。<br>现代CPU的架构是冯诺依曼架构：数据与计算分离，这种架构的问题就是计算式需要准备好数据。</p><p>如果（CPU -&gt; GPU -&gt; CPU）双向传输会存在同步问题导致效率低下，<br>因此在设计代码时，尽量保证数据的单向传输（CPU -&gt; GPU）,避免计算同步问题。</p><p>CPU查找数据时，首先从Cache中查找，再从内存中查找，而Cache访问速度是内存访问的100倍。因此我们在处理数据时，尽可能使用连续数据。</p><ul><li>充分利用硬件并行计算</li><li>避免冯诺依曼架构瓶颈</li></ul><p><img src="/images/article/Games104/04/Games104_04_07.png"><span class="image-caption">缓存</span></p><p>主机、PC、手机的GPU架构是不一样的，引擎的架构也是不一样的，引擎架构和硬件架构息息相关。</p><h2 id="可渲染物体"><a href="#可渲染物体" class="headerlink" title="可渲染物体"></a>可渲染物体</h2><p>Renderable组件中的数据是如何组织的呢？以一个士兵为例，首先很多网格组成对象的框架；<br>网格的质地各不相同，这就需要材质进行处理；材质中有不同的花纹，需要提供图片数据等。<br><img src="/images/article/Games104/04/Games104_04_08.png"><span class="image-caption">可渲染的物体块</span></p><p>Mesh提供了单位的网格数据，网格是由一个个顶点数据组成的三角面的集合。</p><p>顶点数据涉及坐标、颜色、法线、切线……（不一定都有）有了顶点数据之后，最暴力的表示方法就是，每个三角面都有自生的原始数据，<br>这样的话N个三角面就有N*3个顶点数据。但我们仔细观察就会发现，这样的数据中有很多是重复的的（相邻三角面两个顶点数据相同）</p><p>在OpenGL中定义Mesh时就有VBO与VAO的概念，顶点数据为原始数据，通过index索引来组成三角面。</p><p>除了通过index引用的方式表示，还有Triangle Strip的表示方式：顶点列表中，连续三个顶点表示一个三角面，这样就省去了index数据，并且对缓存友好。<br><img src="/images/article/Games104/04/Games104_04_09.png"><span class="image-caption">顶点和索引缓冲区</span></p><p>Rendering里面定义的Material只是视觉材质，也就是看起来像塑料，金属等，<br>而不是物理材质，像是其弹性，摩擦等是物理方面的，物理材质通常会单独的描述。<br><img src="/images/article/Games104/04/Games104_04_10.png"><span class="image-caption">Material</span></p><p>经过这么多年的发展，从图形学中经典的phong模型到现在的PBR模型，以及一些特殊的效果，比如半透明的效果，工业界中已经积累了很多的Material模型。</p><p>在表达材质时，Texture起到了很重要的作用，因为大多数时候我们判断一个物体的材质，第一时间是通过其Texture来判断的，而不是根据材质的参数。</p><p>比如这个生锈的铁球，我们是根据Roughness的Texture来区分哪些部分是光滑的哪些部分是生锈的，所以Texture也是Material重要的一种表达方式。<br><img src="/images/article/Games104/04/Games104_04_11.png"><span class="image-caption">Texture</span></p><p>Shader代码也是Render able的关键数据:</p><ul><li>拥有了Mesh，Material，Texture等，需要通过Shader才能将物体给绘制出来。</li><li>Shader是Source code，但是在引擎中又会被当做数据进行处理。</li></ul><p><img src="/images/article/Games104/04/Games104_04_12.png"><span class="image-caption">Shader</span></p><p>物体做好了，需要坐标转换从自身坐标系移到世界坐标系。<br>当确认相机的位置，需要物体投影到相机坐标系。<br>将正交投影或投影映射到屏幕的坐标系。<br><img src="/images/article/Games104/04/Games104_04_13.png"><span class="image-caption">空间变换</span></p><p>上述的为一般渲染处理流程，但对于一个复杂对象来说，部件的材质各不相同。<br>GPU作为一个状态机，只会保留最后Material所提交的状态进行渲染，那么就不能得到正确的效果，如图右边，<br><img src="/images/article/Games104/04/Games104_04_14.png"><span class="image-caption">根据数据与Shader渲染</span></p><p>因此就需要引入SubMesh的概念：<br><img src="/images/article/Games104/04/Games104_04_15.png"><span class="image-caption">Submesh结构</span><br>对于存在多个材质的对象，我们会对网格进行切分（通过offset、count确定index）为submesh，对应各自的材质，一个完整的复杂对象渲染就处理完成了。</p><p>但如果我们需要绘制大量这样的复杂单位，如果每个单位都独立存储一份完整的渲染数据，这样的开销太过巨大。<br>这些单位的材质、Mesh、纹理都有相同部分，因此较好的数据组织方式是对渲染资源数据创建资源池。<br>当我们在游戏中创建不同的GameObject，可以看做资源在场景中的实例化。<br><img src="/images/article/Games104/04/Games104_04_16.png"><span class="image-caption">资源池</span><br>渲染的整体分为三个步骤：</p><ol><li>CPU提交渲染数据</li><li>GPU设置渲染状态</li><li>GPU渲染</li></ol><p>对于相同材质的对象来说，每次都处理三个流程是极为耗时的，我们可以为材质相同的对象跳过步骤（2）。<br>这也是现代图形渲染API的设计思路：根据材质进行Submesh渲染。Unity中的SRP Batcher类似于这一概念。<br><img src="/images/article/Games104/04/Games104_04_17.png"><span class="image-caption">按材质排序</span></p><p>除了简化渲染状态设置，我们还可以对数据的提交进行优化：对于完全相同的物体，只是在场景中的位置不同。<br>就可以将这一类对象的渲染数据一起提交到GPU，减少数据提交次数。Unity中的GPU Instance类似于这一概念<br><img src="/images/article/Games104/04/Games104_04_18.png"><span class="image-caption">GPU批处理渲染</span></p><h2 id="可见性裁剪"><a href="#可见性裁剪" class="headerlink" title="可见性裁剪"></a>可见性裁剪</h2><p>在知道了如何绘制场景GameObject了后，我们需要思考一些问题：我们要绘制哪些物体？<br>最暴力的方法是所有对象都绘制一遍，但显然在大世界的游戏中是不行的。<br>那对于硬件的负荷也太大了，因此需要Visibility Culling，它是引擎的渲染模块中的一个基础底层系统。</p><h3 id="Bound-Volume（包围盒）"><a href="#Bound-Volume（包围盒）" class="headerlink" title="Bound Volume（包围盒）"></a>Bound Volume（包围盒）</h3><p>通常我们会根据Camera的可视范围（视锥体、长方体）作为单位是否可见的判断依据，但单位的形状千奇百怪，<br>如何能够将这些Mesh与可视范围进行检测呢？这就需要对物体范围进行简化：包围盒（Bound），规则物体的相交是相对便于计算的。<br><img src="/images/article/Games104/04/Games104_04_19.png"><span class="image-caption">包围盒</span><br><img src="/images/article/Games104/04/Games104_04_20.png"><span class="image-caption">包围盒类型</span></p><h3 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h3><p>有了包围盒后我们确实可以去判断是否被culling掉，最简单的方法就是将所有包围盒都进行判断，<br>但这样的话面对拥有数量众多GameObject的游戏效率是十分低的，因此我们可以通过对场景中的GameObject进行划分管理，<br>比如经典的四叉树划分，BVH划分等，预先剔除摄像机覆盖范围外的对象。<br><img src="/images/article/Games104/04/Games104_04_21.png"><span class="image-caption">层次视图</span></p><p>以BVH为例，把包围盒们以树状结构管理，层次包围盒树（BVH树）是一棵多叉树，用来存储包围盒形状。</p><p>它的根节点代表一个最大的包围盒，其多个子节点则代表多个子包围盒。<br>因此当frustum判断这个包围盒在内的话，进入精细化分的子节点继续判断。<br><img src="/images/article/Games104/04/Games104_04_22.png"><span class="image-caption">游戏引擎中BVH的构建与插入</span></p><p>BVH算法在工业界广泛使用，因为现代游戏场景内动的物体比较多，因此当GO移动后也就是节点变动，<br>我们需要重新构建树状结构，此时要考虑重新构建的成本一定要很低，而BVH恰好在此有很多优势，因此BVH适用于开阔动态场景。</p><h3 id="接下来我们来学习PVS（potential-visibility-set），它的算法思想是很有用的："><a href="#接下来我们来学习PVS（potential-visibility-set），它的算法思想是很有用的：" class="headerlink" title="接下来我们来学习PVS（potential visibility set），它的算法思想是很有用的："></a>接下来我们来学习PVS（potential visibility set），它的算法思想是很有用的：</h3><p><img src="/images/article/Games104/04/Games104_04_23.png"><span class="image-caption">PVS</span></p><p>我们将一个大的游戏场景划分为一系列的子场景，如图，相邻的子场景之间设置portal（也就是真实世界中的门），<br>当你站在一个子场景时，通过portal（门或窗）只能看见有限的子场景，如下图，<br>站在7号子场景可以看到6，1，2，3四个子场景，因此在7号子场景时只需要渲染，6，1，2，3四个子场景的所有东西。<br><img src="/images/article/Games104/04/Games104_04_24.png"><span class="image-caption">连接处和PVS数据</span></p><p><img src="/images/article/Games104/04/Games104_04_25.png"><span class="image-caption">游戏中PSV用法</span></p><p>随着硬件的不断发展，现如今GPU的批处理速度远远快于CPU，通过GPU进行Culling操作,<br>在绘制对象时，靠前的物体会挡住靠后的物体，进行这一判断就需要Early-Z(z-Buffer)。<br>通常在进行真正绘制之前，Camera会对空间对象生成一张深度图（z-Buffer）。<br>在之后绘制对象时，就可以判断像素的深度是否符合要求，以此来判断是否进行绘制。</p><p>利用了GPU高效的并行化能力加上廉价的成本形成一群遮挡物的深度图，然后通过比较从而节省掉不必要的计算过程，对于大型场景很有用。<br><img src="/images/article/Games104/04/Games104_04_26.png"><span class="image-caption">GPU裁剪</span></p><h2 id="贴图压缩（纹理压缩）"><a href="#贴图压缩（纹理压缩）" class="headerlink" title="贴图压缩（纹理压缩）"></a>贴图压缩（纹理压缩）</h2><p>我们日常使用的图片压缩格式（如PNG、JPEG等），有很好的压缩或显示效果，但通常无法满足游戏引擎的需求：快速随机访问像素。</p><p>在游戏引擎中通常采用block思想：将纹理划分为多个小块，然后进行压缩。<br>以DXTC格式举例，对于每个划分的小块，取得其中最亮和最暗的像素点，其余部分通过差值系数的记录数据。<br><img src="/images/article/Games104/04/Games104_04_27.png"><span class="image-caption">块压缩</span></p><h2 id="模型工具"><a href="#模型工具" class="headerlink" title="模型工具"></a>模型工具</h2><p><img src="/images/article/Games104/04/Games104_04_28.png"><span class="image-caption">多边形建模</span><br><img src="/images/article/Games104/04/Games104_04_29.png"><span class="image-caption">雕刻</span><br><img src="/images/article/Games104/04/Games104_04_30.png"><span class="image-caption">扫描</span><br><img src="/images/article/Games104/04/Games104_04_31.png"><span class="image-caption">算法生成</span><br><img src="/images/article/Games104/04/Games104_04_32.png"><span class="image-caption">建模方式对比</span></p><h2 id="新的模型管线"><a href="#新的模型管线" class="headerlink" title="新的模型管线"></a>新的模型管线</h2><p>游戏和影视有很大的重合部分，但由于游戏的实时渲染以及硬件存储要求，通常一个模型的面片数不会超过1W，<br>而影视级的模型通常是千万级的。 想要在游戏中实现影视级效果，那就得上点手段了。</p><p>2015年《刺客信条：大革命》提出了Mesh Cluster Rendering概念。其核心思想是将模型分成多个Cluster（32\64面片），<br>根据这些Cluster与摄像机的远近来展示不同的细节。这样处理的好处在于：</p><ul><li>现在GPU可以根据实时数据，动态生成几何细节（曲面细分Tessellation）</li><li>以相同的Cluster结构来并行处理时，能够有效利用GPU</li><li>可以对模型进行Cluster剔除</li></ul><p><img src="/images/article/Games104/04/Games104_04_33.png"><span class="image-caption">基于网格的管道</span><br><img src="/images/article/Games104/04/Games104_04_34.png"><span class="image-caption">可编程的网格管道</span><br><img src="/images/article/Games104/04/Games104_04_35.png"><span class="image-caption">基于集群的网格中的GPU裁剪</span><br>用一个基于数据可以凭空生成几何，并且可以根据cluster与相机间的距离选择不同的精度的算法。这样GPU处理的都是大小一致的几何体，并行处理使得高效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>游戏引擎的Rendering模块是一个工程科学，深度依赖于现代硬件架构和编程者对现代硬件架构的理解</li><li>游戏引擎渲染的核心问题是Mesh、Material、Texture等数据间的关系，比如Mesh和Submesh就是一个很好的解决方案</li><li>游戏引擎渲染在绘制对象时，要尽可能减少处理内容，从而可以提升性能，因此Visibility Culling非常重要</li><li>现代GPU的处理效率越来越高，可以将CPU中的并行计算转移到GPU中</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/493641124">参考文章（一）</a></p><p><a href="https://zhuanlan.zhihu.com/p/501405501">参考文章（二）</a></p><p><a href="https://www.bilibili.com/video/BV14r4y1p7tt?spm_id_from=333.337.search-card.all.click&amp;vd_source=422a2ce23eb94fdbdfc2824aa2898ea5">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture04_Rendering%20on%20Game%20Engine_Basics%20of%20Game%20Rendering.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 如何构建游戏世界（三）</title>
      <link href="/posts/4d443f2a.html"/>
      <url>/posts/4d443f2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="如何让游戏世界活动起来"><a href="#如何让游戏世界活动起来" class="headerlink" title="如何让游戏世界活动起来"></a>如何让游戏世界活动起来</h2><h3 id="游戏对象类型"><a href="#游戏对象类型" class="headerlink" title="游戏对象类型"></a>游戏对象类型</h3><ul><li>现代游戏中的对象通常分为：动态物体、静态物体、地形系统以及其它物件。</li><li>为了统一游戏中对象，我们通常会用GameObject来指代游戏中的所有对象。</li></ul><p><img src="/images/article/Games104/03/Games104_03_01.png"><span class="image-caption">GameObject</span></p><h3 id="游戏对象功能组织"><a href="#游戏对象功能组织" class="headerlink" title="游戏对象功能组织"></a>游戏对象功能组织</h3><p>以面向对象的思维，一个游戏对象由属性和行为组成。 但游戏中的对象十分复杂，通过水陆两栖坦克继承车还是船的案例表达难以清晰得区分继承关系。<br><img src="/images/article/Games104/03/Games104_03_02.png"><span class="image-caption">分类</span></p><p>游戏引擎中通常使用组件化的方式，抽离行为逻辑，使得游戏对象的设计更加方便。通过接口、组合的方法更加符合人的直觉。<br>基于组件化的思想，我们通常会抽象出一个ComponentBase，不同组件实现基类的方法，所有组件由统一的外部管理对象调用。<br><img src="/images/article/Games104/03/Games104_03_03.png"><span class="image-caption">组件</span></p><p>装备不同功能的组件实现不同的无人机<br><img src="/images/article/Games104/03/Games104_03_04.png"><span class="image-caption">无人机组件</span></p><ol><li>在游戏世界中，一切都是一个GameObject对象</li><li>游戏对象可以以基于组件的方式来描述</li></ol><h3 id="逻辑何时执行"><a href="#逻辑何时执行" class="headerlink" title="逻辑何时执行"></a>逻辑何时执行</h3><p>Tick的方式：</p><ol><li>基于对象为基础的Tick</li><li>基于组件为基础的Tick</li></ol><p><img src="/images/article/Games104/03/Games104_03_05.png"><span class="image-caption">GO Tick VS Component Tick</span><br>现代游戏引擎中通常不是按照GameObject来执行Tick，而是根据功能系统。这样能够处理连续内存数据，效率更高。（类似ECS思路）</p><h3 id="对象通讯"><a href="#对象通讯" class="headerlink" title="对象通讯"></a>对象通讯</h3><p>想想这样一个场景：一辆坦克被炮弹击中，坦克爆炸需要对周围单位造成伤害。<br>一种处理方案是，找到坦克周围的对象，依次处理受击逻辑。<br>这样的处理方式对于复杂的游戏来说，难以阅读维护成本很高。<br><img src="/images/article/Games104/03/Games104_03_06.png"><span class="image-caption">遍历处理逻辑</span></p><p>通常会使用event机制来解耦这些逻辑：坦克发出爆炸消息，受影响的对象自己接受消息，并执行逻辑。相当于把事件解耦成发生和处理。<br><img src="/images/article/Games104/03/Games104_03_07.png"><span class="image-caption">消息事件处理逻辑</span></p><h2 id="如何管理游戏对象"><a href="#如何管理游戏对象" class="headerlink" title="如何管理游戏对象"></a>如何管理游戏对象</h2><p>游戏对象是处于游戏场景中的，游戏对象通过唯一id来进行识别：unique ID(uid)，游戏对象处于特定位置。</p><p>继续上述的例子，当坦克发生爆炸时，所有接收到事件的对象都会进行处理。但游戏场景中存在大量对象时，<br>这样的处理方式难以适用（每个游戏对象都可能和其它游戏对象互动，此时算法复杂度为n^2）。<br>因此就需要根据游戏对象在场景中的分布进行管理，以优化场景对象的查找。</p><p>简单的场景可以通过画格子的方式处理。<br><img src="/images/article/Games104/03/Games104_03_08.png"><span class="image-caption">简单处理方式</span></p><p>常见场景对象数据结构：二分树、四叉树（八叉树）、BVH。游戏引擎一般实现多种算法供上层开发选择。<br><img src="/images/article/Games104/03/Games104_03_09.png"><span class="image-caption">多种处理方式</span></p><h2 id="其他需要处理的负责情况（时序问题）"><a href="#其他需要处理的负责情况（时序问题）" class="headerlink" title="其他需要处理的负责情况（时序问题）"></a>其他需要处理的负责情况（时序问题）</h2><p>不同系统之间可能相互影响，出现循环依赖。比如人在行走时，踢到一块石头，触发物理系统，同时反过来影响动画系统。此时就会涉及到逻辑处理的时序问题。</p><p>现代引擎是在多核CPU上行执行的，也可能出现两个对象相互影响，出现时序问题。</p><p>例子：引入一个邮局，通过将事件发送到邮局统一处理后分发到对应GO处理（通常的处理方式是引入第三方，隔帧处理）</p><p><img src="/images/article/Games104/03/Games104_03_10.png"><span class="image-caption">组件依赖</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/490186435">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1YY4y1p74P/?spm_id_from=333.788&amp;vd_source=422a2ce23eb94fdbdfc2824aa2898ea5">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture03_How%20to%20Build%20a%20Game%20World.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 引擎架构分层（二）</title>
      <link href="/posts/a6ae6279.html"/>
      <url>/posts/a6ae6279.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>资源层：负责加载管理资源</li><li>功能层：就是让画面可见，可动，可交互</li><li>核心层：提供各种核心服务，比如动画、物理、渲染、脚本、相机</li><li>工具层：编辑器，最上层</li><li>平台层：硬件输入适配</li><li>三方插件：SDK集成、或者工具独立出来</li></ul><h2 id="资源层"><a href="#资源层" class="headerlink" title="资源层"></a>资源层</h2><ul><li>核心功能：管理资产的生命周期</li><li>资源导入引擎：要从资源繁杂的数据中，拿取引擎需要的信息，转变成引擎的资产</li><li>资源管理器：一个虚拟文件系统，通过路径引用来加载和卸载资源</li></ul><p><img src="/images/article/Games104/02/Games104_02_01.png"><span class="image-caption">资源生命周期</span></p><h2 id="功能层"><a href="#功能层" class="headerlink" title="功能层"></a>功能层</h2><p>功能层的两大神兽：tick逻辑和tick渲染<br><img src="/images/article/Games104/02/Games104_02_02.png"><span class="image-caption">Tick</span></p><ol><li>入门版多线程<ul><li>逻辑线程</li><li>渲染线程</li><li>模拟线程</li></ul></li><li>主流商业引擎多线程<ul><li>在入门版基础上，把物理、渲染等可以多线程计算的放到多线程进行处理</li></ul></li><li>前沿技术<ul><li>JobSystem：所有都是一个原子，把线程吃满</li></ul></li></ol><p><img src="/images/article/Games104/02/Games104_02_03.png"><span class="image-caption">多线程</span></p><h2 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h2><ul><li>数学库：矩阵，大学学的线性代数就够用了、物理用的数学比较难</li><li>数学计算效率：不追求完全精准，极限接近就可以，追求效率高</li><li>数据结构和容器：<ul><li>矢量、地图、树木等</li><li>使用高效的STL库</li><li>避免片段内存</li></ul></li><li>内存管理：<ul><li>内存池，分配</li><li>缓存命中率高</li><li>内存排列</li></ul></li></ul><p><img src="/images/article/Games104/02/Games104_02_08.png"><span class="image-caption">内存管理</span></p><p>内存分配金科玉律：</p><ol><li>把数据放在一起</li><li>访问数据的时候最好顺序排列</li><li>删除的时候最好一批次的删除</li></ol><p><img src="/images/article/Games104/02/Games104_02_04.png"><span class="image-caption">核心层基础</span></p><h2 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h2><ul><li>硬件输入适配：键盘、鼠标、手柄、VR等</li><li>渲染输出适配：不同显卡图形API适配，比如 DirectX 和 OpenGL</li><li>文件路径适配：ios和windows 文件路径</li><li>架构：Arm64、Arm32</li></ul><p><img src="/images/article/Games104/02/Games104_02_05.png"><span class="image-caption">平台层</span></p><h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>DCC（Digital Content Creation）：导出和导入</p><p><img src="/images/article/Games104/02/Games104_02_06.png"><span class="image-caption">DCC</span></p><ul><li>解耦和降低复杂性<ul><li>下层独立于上层</li><li>上层不知道底层是如何实现的</li></ul></li><li>对不断发展的需求的响应<ul><li>上层演化迅速，但下层演化稳定</li></ul></li></ul><p><img src="/images/article/Games104/02/Games104_02_07.png"><span class="image-caption">架构分层</span></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/499674385">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV12Z4y1B7th/?spm_id_from=333.788&amp;vd_source=422a2ce23eb94fdbdfc2824aa2898ea5">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_lecture02Layered%20Architecture%20of%20Game%20Engine.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎 - 游戏引擎导论（一）</title>
      <link href="/posts/28544d6c.html"/>
      <url>/posts/28544d6c.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏最奇妙的点在于每个人都很熟悉，但却很少有人能够意识到其中的高深之处。游戏中的每一个画面，每一个细节，都是在计算机中由0和1模拟出来的。一款游戏的制作十分复杂，它其中包含了计算机科学中几乎所有的知识门类。<br><img src="/images/article/Games104/01/Games104_01_01.png"><span class="image-caption">前言</span></p><h2 id="为什么学游戏引擎"><a href="#为什么学游戏引擎" class="headerlink" title="为什么学游戏引擎"></a>为什么学游戏引擎</h2><p>因为下一个时代将是由游戏引擎构建的虚拟现实的时代，现今的游戏引擎已经发展成为很多东西的底层技术支撑。</p><h3 id="其实现在很多技术都离不开Game-Engine"><a href="#其实现在很多技术都离不开Game-Engine" class="headerlink" title="其实现在很多技术都离不开Game Engine:"></a>其实现在很多技术都离不开Game Engine:</h3><ol><li>虚拟人技术：过去二十年中工业界致力于在游戏中完美的还原角色在现实世界中的各种表现，如头发的simulation，皮肤的材质模拟</li><li>影视行业：通过游戏引擎搭建出场景然后显示在一个巨大的LED屏幕上，演员在屏幕前进行表演，这样导演可以十分便捷的在引擎中调整场景细节或者光照天气等因素。</li><li>军事模拟：在虚拟世界中模拟军事演练。</li><li>Digital Twin:把现实世界中的物体在虚拟世界表示出来，从而方便进行管理和构建。比如无人驾驶的设备，实际上是通过将周围的环境以及各种异常在引擎上模拟出来从而保证正常行驶的。</li></ol><p><img src="/images/article/Games104/01/Games104_01_02.png"><span class="image-caption">为什么学游戏引擎</span></p><h2 id="游戏引擎历史"><a href="#游戏引擎历史" class="headerlink" title="游戏引擎历史"></a>游戏引擎历史</h2><h3 id="早期游戏时代"><a href="#早期游戏时代" class="headerlink" title="早期游戏时代"></a>早期游戏时代</h3><p>视频游戏行业的历史也不过短短的五十多年左右，早期的游戏多为在红白机上运行的视频游戏，此时根本没有Game Engine这个概念，游戏都十分的简单，大家所想的是如何将复杂的元素放在很小的存储空间内。比如马里奥中，将云彩的贴图换个颜色放在地板上就变成了草丛，将小乌龟的正面反面来回播放就形成了走的效果，此时是游戏的黄金时期，大家关注点在于游戏性和趣味性，在此时期诞生了各种经典的游戏，《魂斗罗》、《马里奥》,《坦克大战》等知名IP。<br><img src="/images/article/Games104/01/Games104_01_03.png"><span class="image-caption">早期游戏时代</span></p><h3 id="第一个游戏引擎"><a href="#第一个游戏引擎" class="headerlink" title="第一个游戏引擎"></a>第一个游戏引擎</h3><p>游戏引擎之父John Carmack，将他参与研发的一款FPS游戏《德军总部3D》中能够复用的核心功能分离出来，便产生了早期游戏引擎的雏形。在他后来开发的第二款游戏《Doom》中，他将其中分离的功能卖出，便有另外一款游戏《Shadow Caster》被开发出来，这款游戏在商业上取得了巨大的成功，此时距离真正的游戏引擎的诞生已经很接近了。直到《Quake》的问世，其中的核心分离出来制作的Quake Engine，被用来制作其他第一人称射击游戏，至此，第一个游戏引擎诞生了。<br><img src="/images/article/Games104/01/Games104_01_04.png"><span class="image-caption">游戏引擎之父John Carmack</span></p><p><img src="/images/article/Games104/01/Games104_01_06.png"><span class="image-caption">Quake</span></p><p>最早的计算机硬件中并没有显卡，直到人们认识到逻辑运算和图形运算并不相同，图形运算是大量向量运算，而且有大量的并行化运算，并不适合用CPU来运算，此时，显卡便诞生了。硬件的发展不断推动着游戏引擎的发展，随着显卡等硬件性能的不断提升，游戏引擎的算力也从Play Station 1到Play Station 5提升了约二十万倍，游戏的质量自然也随之得到快速提升。更高的算力也就意味着游戏引擎变得更加庞大，复杂，也就演变成了现代游戏引擎。<br><img src="/images/article/Games104/01/Games104_01_05.png"><span class="image-caption">计算机演变</span></p><h3 id="现代游戏引擎"><a href="#现代游戏引擎" class="headerlink" title="现代游戏引擎"></a>现代游戏引擎</h3><ul><li>商业引擎，其中有我们熟知的Unity和Unreal等</li><li>游戏公司独立研发的引擎，这类引擎一般为各大游戏公司内部使用，其中包括著名的寒霜引擎</li><li>免费引擎，主要适用于轻量级的休闲游戏，与商业引擎和游戏公司独立研发的引擎还是有一定差距的</li></ul><p><img src="/images/article/Games104/01/Games104_01_07.png"><span class="image-caption">现代游戏引擎</span></p><p>随着游戏行业的不断发展，诸如物理运算一类的东西会非常复杂，早期游戏会自己实现结算器，物理碰撞的检测等，但计算越来越复杂时，便出现了专门处理物理运算的模块，也就是中间件。中间件包含处理物理运算，声音效果等等的一系列引擎。<br><img src="/images/article/Games104/01/Games104_01_08.png"><span class="image-caption">游戏引擎中间件</span></p><h2 id="什么是游戏引擎"><a href="#什么是游戏引擎" class="headerlink" title="什么是游戏引擎"></a>什么是游戏引擎</h2><p>百度百科：</p><blockquote><p>游戏引擎是指一些已编写好的可编辑电脑游戏系统或者一些交互式实时图像应用程序的核心组件。这些系统为游戏设计者提供各种编写游戏所需的各种工具，其目的在于让游戏设计者能容易和快速地做出游戏程式而不用由零开始。大部分都支持多种操作平台，如Linux、Mac OS X、微软Windows。游戏引擎包含以下系统：渲染引擎（即“渲染器”，含二维图像引擎和三维图像引擎）、物理引擎、碰撞检测系统、音效、脚本引擎、电脑动画、人工智能、网络引擎以及场景管理。</p></blockquote><ol><li>游戏引擎是创造类似《黑客帝国》中虚拟世界的底层框架</li><li>游戏引擎是创作者（艺术家、设计师）实现创意或者想象力的生产力工具</li><li>游戏引擎复杂，庞大的体量很好的展现了复杂性系统的艺术，即系统复杂之美</li></ol><p>当然，游戏引擎也需要提供如一个工作室中多人合作开发的可行性，并在不断升级优化时具备底层的兼容性。</p><h2 id="如何学习游戏引擎"><a href="#如何学习游戏引擎" class="headerlink" title="如何学习游戏引擎"></a>如何学习游戏引擎</h2><p>在学完游戏引擎的分层架构后，我们打开一个游戏引擎的源码，将能够有理清头绪的办法（Update函数）；在学完渲染系统后，我们将认识到如何组织虚拟世界中需要渲染的元素，并依照不同图形学的算法进行渲染；在学完动画系统后，我们将了解如何组织一系列的动作动画，以及不同动作的动画之间是如何过渡的；学完物理系统后，我们将学会如何使用物理表达这个世界（刚体力学、软体力学、流体等等）；在GamePlay系统中，将学到事件系统，脚本系统，图形驱动等等；在网络系统中，我们将了解到帧同步算法，异步同步算法等等</p><p>还有许多支路如特效系统、寻路系统、相机系统、C++反射机制等等。</p><p>以及广受关注的前沿科技如动作匹配技术、程序化内容生成、Lumen技术（动态全局光照）、Nanite技术（影视级片元数据处理）。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/533979732">参考文章</a></p><p><a href="https://www.bilibili.com/video/BV1oU4y1R7Km/?spm_id_from=333.788&amp;vd_source=21a878bcf79a22801dbc305350f68ca1">课程视频</a></p><p><a href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture1.pdf">课件PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏引擎 </tag>
            
            <tag> games104 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE5 源码编译</title>
      <link href="/posts/75abea48.html"/>
      <url>/posts/75abea48.html</url>
      
        <content type="html"><![CDATA[<h3 id="UE5源码"><a href="#UE5源码" class="headerlink" title="UE5源码"></a>UE5源码</h3><p>UE5源码Github地址：<a href="https://github.com/EpicGames/UnrealEngine">https://github.com/EpicGames/UnrealEngine</a></p><p>UnrealEngine是个开源商业引擎，但是它在GitHub上的开源是个私有库，所以需要申请EpicGames账户和Github账号的绑定授权才能进行下载。</p><p>注册登录EpicGames账户<a href="https://www.unrealengine.com/zh-CN/">https://www.unrealengine.com/zh-CN/</a></p><p>登录成功后点开右上角个人信息，点连接，点账户，选择Github进行关联，再登录你的GitHub账号授权。</p><p><img src="/images/article/UnrealEngine/AuthorizedLogin.jpg"><span class="image-caption">授权登录</span></p><p>授权成功后Github会发送一封验证邮件，激活一下就可以了。</p><p><img src="/images/article/UnrealEngine/JoinEpicGames.png"><span class="image-caption">激活</span></p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>找一个合适的目录执行命令 repo clone 到本地</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone git@github.com:EpicGames/UnrealEngine.git<br></code></pre></td></tr></tbody></table></figure><p>如果命令没有权限，请先<a href="https://cherry-white.github.io/posts/e0c8e18d.html">配置Git和SSh</a></p><p>代码clone下来之后，首先打个 <code>git branch --all</code> 命令，可以看到许多分支，本地有是白色的，当前分支是绿色的，远端分支本地没有则是红色的。</p><p><img src="/images/article/UnrealEngine/UnrealCodeBranch.jpg"><span class="image-caption">Unreal代码分支</span></p><p>然后输入 <code>git checkout ue5-early-access</code>，切换到UE5抢先体验版分支，下载过程可能有点久。</p><p>UE5 上最活跃的开发发生在 <code>ue5-main</code> 分支。这个分支是引擎的前沿，它甚至可能无法编译。</p><p>要获得 UE5 的稳定早期访问版本，使用 <code>ue5-early-access</code> 分支。具体可以参考<code>README.md</code>.</p><p>当代码完全下载下来后进入目录</p><ol><li>运行 <code>Setup.bat</code>，它会帮你装 UE5 需要的依赖库，要挺久的，等它慢慢完成。</li></ol><p><img src="/images/article/UnrealEngine/SetUp.png"><span class="image-caption">运行Setup.bat</span></p><ol start="2"><li>运行 <code>GenerateProjectFiles.bat</code> 它帮你装缺失的库，然后生成 <code>UE5.sln</code>。</li></ol><p><img src="/images/article/UnrealEngine/GenerateProjectFiles.jpg"><span class="image-caption">运行GenerateProjectFiles.bat</span></p><ol start="3"><li>使用 Rider 打开目录 <code>UE5.sln</code>，设置 UE5 设为启动项目 并运行。</li></ol><p><img src="/images/article/UnrealEngine/SetRunUE5.jpg"><span class="image-caption">设置启动项为UE5</span></p><p>运行UE5</p><p><img src="/images/article/UnrealEngine/UE5.jpg"><span class="image-caption">UE5</span></p>]]></content>
      
      
      <categories>
          
          <category> 虚幻 </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ue5 </tag>
            
            <tag> 虚幻 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置 Git 和 SSH</title>
      <link href="/posts/e0c8e18d.html"/>
      <url>/posts/e0c8e18d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git-下载安装"><a href="#Git-下载安装" class="headerlink" title="Git 下载安装"></a>Git 下载安装</h2><p>直接去官网下载即可，安装过程直接下一步就行。<a href="https://git-scm.com/downloads">下载地址</a></p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>首先设置Git的 user name 和 email ：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name "yourname"<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.email "youremail@gmail.com"<br></code></pre></td></tr></tbody></table></figure><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>在命令行执行以下命令：</p><p>建立密钥对，-t代表类型，有 RSA 和 DSA 两种</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shh">ssh-keygen -t rsa<br></code></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shh">ssh-keygen -t rsa -C “youremail@gmail.com”<br></code></pre></td></tr></tbody></table></figure><p>按3个回车，密码为空。</p><p>生成的好的文件默认存放路径是在： C:\Users\你的用户名.ssh</p><p>id_rsa是私钥，id_rsa.pub是公钥。</p><h2 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h2><p>把公钥里面的字符串复制好，登录 Github，右上角个人，选 Settings，选SSH and GPG keys,再点New SSH key。</p><p>这里 Title 随便起个名，方便自己记，Key 的内容，就是 Ctrl+V 粘贴 id_rsa.pub 里的内容。</p><p><img src="/images/article/configs/github-ssh.jpg"><span class="image-caption">配置SSH key</span></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathf.Lerp 使用</title>
      <link href="/posts/6ab666a7.html"/>
      <url>/posts/6ab666a7.html</url>
      
        <content type="html"><![CDATA[<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Mathf.Lerp(<span class="hljs-built_in">float</span> a, <span class="hljs-built_in">float</span> b, <span class="hljs-built_in">float</span> t)<br></code></pre></td></tr></tbody></table></figure><table><thead><tr><th align="left">参数</th><th align="right">解析</th></tr></thead><tbody><tr><td align="left">a</td><td align="right">开始值</td></tr><tr><td align="left">b</td><td align="right">结束值</td></tr><tr><td align="left">t</td><td align="right">插值值</td></tr></tbody></table><p>返回一个 float ，开始值和结束值之间根据浮点数插值的结果。</p><p>通过 t 线性插值在A和B之间。</p><p>参数 t 夹紧到[0，1]范围内。</p><ul><li>当t = 0返回a时</li><li>当t = 1返回b</li><li>当t = 0.5返回a和b的中点。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> LerpContinuedTime =  <span class="hljs-number">3.0F</span>;     <span class="hljs-comment">// 需要插值的持续时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> LerpTime;  <span class="hljs-comment">// 当前插值的时间</span><br><span class="hljs-keyword">public</span> AnimationCurve Curve;    <span class="hljs-comment">//可以配置的运动曲线</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> CurValue;  <span class="hljs-comment">//记录当前的值</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>{<br>    <span class="hljs-keyword">if</span>(LerpTime &lt; LerpContinuedTime)<br>    {<br>        LerpTime += Time.deltaTime;<br>        <br>        <span class="hljs-comment">// 匀速从 0 插值到 100 </span><br>        Mathf.Lerp(<span class="hljs-number">0f</span>, <span class="hljs-number">100f</span>, LerpTime/LerpContinuedTime);<br>        <br>        <span class="hljs-comment">// 递减插值，开始的值一直改变，当插值百分比固定的时候，计算出来的值每次比上一次计算的小</span><br>        CurValue = Mathf.Lerp(CurValue, <span class="hljs-number">100f</span>, <span class="hljs-number">0.1f</span>);<br>        <br>        <span class="hljs-comment">// 根据运动曲线插值，可以实现减速、加速、值先增加再减小等效果</span><br>        Mathf.Lerp(<span class="hljs-number">0f</span>, <span class="hljs-number">100f</span>, LerpTime/LerpContinuedTime, Curve.Evaluate(LerpTime / LerpContinuedTime));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
            <tag> unity api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用地址</title>
      <link href="/posts/9b20463a.html"/>
      <url>/posts/9b20463a.html</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><h3 id="IDEA：https-www-jetbrains-com-idea-download-section-windows"><a href="#IDEA：https-www-jetbrains-com-idea-download-section-windows" class="headerlink" title="IDEA：https://www.jetbrains.com/idea/download/#section=windows"></a>IDEA：<a href="https://www.jetbrains.com/idea/download/#section=windows">https://www.jetbrains.com/idea/download/#section=windows</a></h3><h3 id="Rider：https-www-jetbrains-com-cn-rider-download-section-windows"><a href="#Rider：https-www-jetbrains-com-cn-rider-download-section-windows" class="headerlink" title="Rider：https://www.jetbrains.com.cn/rider/download/#section=windows"></a>Rider：<a href="https://www.jetbrains.com.cn/rider/download/#section=windows">https://www.jetbrains.com.cn/rider/download/#section=windows</a></h3><h3 id="CLion：https-www-jetbrains-com-cn-clion-download-section-windows"><a href="#CLion：https-www-jetbrains-com-cn-clion-download-section-windows" class="headerlink" title="CLion：https://www.jetbrains.com.cn/clion/download/#section=windows"></a>CLion：<a href="https://www.jetbrains.com.cn/clion/download/#section=windows">https://www.jetbrains.com.cn/clion/download/#section=windows</a></h3><h3 id="PyCharm：https-www-jetbrains-com-cn-pycharm-download-section-windows"><a href="#PyCharm：https-www-jetbrains-com-cn-pycharm-download-section-windows" class="headerlink" title="PyCharm：https://www.jetbrains.com.cn/pycharm/download/#section=windows"></a>PyCharm：<a href="https://www.jetbrains.com.cn/pycharm/download/#section=windows">https://www.jetbrains.com.cn/pycharm/download/#section=windows</a></h3><h3 id="VSCode：https-code-visualstudio-com"><a href="#VSCode：https-code-visualstudio-com" class="headerlink" title="VSCode：https://code.visualstudio.com/"></a>VSCode：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></h3><h2 id="深度学习平台"><a href="#深度学习平台" class="headerlink" title="深度学习平台"></a>深度学习平台</h2><h3 id="pytorch：https-pytorch-org"><a href="#pytorch：https-pytorch-org" class="headerlink" title="pytorch：https://pytorch.org/"></a>pytorch：<a href="https://pytorch.org/">https://pytorch.org/</a></h3><h3 id="百度飞桨：https-www-paddlepaddle-org-cn"><a href="#百度飞桨：https-www-paddlepaddle-org-cn" class="headerlink" title="百度飞桨：https://www.paddlepaddle.org.cn/"></a>百度飞桨：<a href="https://www.paddlepaddle.org.cn/">https://www.paddlepaddle.org.cn/</a></h3><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><h3 id="Apifox：https-www-apifox-cn"><a href="#Apifox：https-www-apifox-cn" class="headerlink" title="Apifox：https://www.apifox.cn/"></a>Apifox：<a href="https://www.apifox.cn/">https://www.apifox.cn/</a></h3><h2 id="SSH工具"><a href="#SSH工具" class="headerlink" title="SSH工具"></a>SSH工具</h2><h3 id="MobaXterm：https-mobaxterm-mobatek-net"><a href="#MobaXterm：https-mobaxterm-mobatek-net" class="headerlink" title="MobaXterm：https://mobaxterm.mobatek.net/"></a>MobaXterm：<a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net/</a></h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MongoDB：https-www-mongodb-com-download-center-community"><a href="#MongoDB：https-www-mongodb-com-download-center-community" class="headerlink" title="MongoDB：https://www.mongodb.com/download-center/community"></a>MongoDB：<a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a></h3><h3 id="Studio-3T：https-studio3t-com-download"><a href="#Studio-3T：https-studio3t-com-download" class="headerlink" title="Studio 3T：https://studio3t.com/download/"></a>Studio 3T：<a href="https://studio3t.com/download/">https://studio3t.com/download/</a></h3><h3 id="MySQL：https-dev-mysql-com-downloads-mysql"><a href="#MySQL：https-dev-mysql-com-downloads-mysql" class="headerlink" title="MySQL：https://dev.mysql.com/downloads/mysql/"></a>MySQL：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></h3><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="NodeJs：https-nodejs-org-en"><a href="#NodeJs：https-nodejs-org-en" class="headerlink" title="NodeJs：https://nodejs.org/en/"></a>NodeJs：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></h3><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="VMware：https-www-vmware-com-cn-products-workstation-pro-html"><a href="#VMware：https-www-vmware-com-cn-products-workstation-pro-html" class="headerlink" title="VMware：https://www.vmware.com/cn/products/workstation-pro.html"></a>VMware：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
          <category> 下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> 下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk 评论踩坑</title>
      <link href="/posts/4ae00516.html"/>
      <url>/posts/4ae00516.html</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>我的博客关于页面没有开通评论，就想给文章开通评论区，点击登录功能发现，GitHub 登录总是失败。<br><img src="/images/article/gitalk/error.png"><span class="image-caption">登陆报错</span></p><h1 id="初步解决"><a href="#初步解决" class="headerlink" title="初步解决"></a>初步解决</h1><p><a href="https://zhuanlan.zhihu.com/p/350735142">参考文章</a></p><p>找到对应的 GitHub 仓库，Issue 区往往能找到一些有效答案。</p><p>gitalk中用到的 cors-anywhere.herokuapp.com 这个网站原本是用来演示用的，但是现在已经被滥用了。</p><p>从2021.1.31开始用户必须手动先访问这个网站获取临时的访问权限，然后才能使用，作者建议开发者自己维护一个代理网站。</p><p>在gitalk的issue中看到别人分享的一个在线代理，先拿来用下</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token<br></code></pre></td></tr></tbody></table></figure><p>我用的是zhaoo主题，在布局模板中找到代理gitalk.ejs文件，如果其他模板可以搜索gitalk关键字应该也能找到差不多的代码。</p><p>在模板里加上proxy配置和在主题的_config.yml文件上也加上proxy配置:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gitalk</span>({<br>     <span class="hljs-attr">clientID</span>: <span class="hljs-string">'&lt;%= theme.gitalk.clientID %&gt;'</span>,<br>     <span class="hljs-attr">clientSecret</span>: <span class="hljs-string">'&lt;%= theme.gitalk.clientSecret %&gt;'</span>,<br>     <span class="hljs-attr">id</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>,<br>     <span class="hljs-attr">repo</span>: <span class="hljs-string">'&lt;%= theme.gitalk.repo %&gt;'</span>,<br>     <span class="hljs-attr">owner</span>: <span class="hljs-string">'&lt;%= theme.gitalk.owner %&gt;'</span>,<br>     <span class="hljs-attr">admin</span>: <span class="hljs-string">'&lt;%= theme.gitalk.admin %&gt;'</span>,<br>     <span class="hljs-attr">proxy</span>: <span class="hljs-string">'&lt;%= theme.gitalk.proxy %&gt;'</span>,<br>   });<br></code></pre></td></tr></tbody></table></figure><p>重新部署后发现依然有问题。</p><p>查看了对应请求的应答码 429，表示请求太多，我个人估计是白嫖这个在线代理的人太多导致的。<br>既然白嫖的代理不能用，那我们就自己搭一个在线代理吧。</p><h2 id="解决方法（一）"><a href="#解决方法（一）" class="headerlink" title="解决方法（一）"></a>解决方法（一）</h2><p><b>此方法国内被墙了</b>，还可以使用 Vercel 免费部署node.js项目解决跨域问题，你可参考该项目 (<a href="https://github.com/Dedicatus546/cors-server">https://github.com/Dedicatus546/cors-server</a>) 最新推荐使用，此处就不在累述。</p><p><a href="https://www.chenhanpeng.com/create-own-cors-anywhere-to-resolve-the-request-with-403/">参考文章</a><br>利用CloudFlare Worker创建在线代理，不需要我们有服务器，也不需要搭建Node.js服务，只需要注册一个CloudFlare账号，创建一个Worker，部署一个JS脚本就可以了，简单方便，下面我们就来看看如何创建吧。</p><p>首先你需要一个 CloudFlare 的账号，如果还没有的话就先注册一个吧：<a href="https://dash.cloudflare.com/">点我注册</a></p><p>选择Workers，创建一个免费的Worker。<br><img src="/images/article/gitalk/register.png"><span class="image-caption">创建Workers</span></p><p>免费版本每天10万次请求也足以应对个人使用或者是小范围分享了。</p><p>填写自己喜欢的二级域名，然后创建worker。</p><p>进入github项目的 <a href="https://github.com/Hanpeng-Chen/cloudflare-cors-anywhere/blob/master/index.js">index.js</a>，复制代码。</p><p>清除脚本编辑器中的示例代码，将复制的代码粘贴进去。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">这里有个点需要注意：我们可以设置请求的黑白名单，这里的白名单我只设置了自己博客<br>大家可以根据自己的情况修改，当然也可以设置为whitelist = [ ".*" ]<br>这样的话知道你代理地址的人都可以用了，然而免费版本的每天只有10万次请求<br>如果用的人多了很容易就用完了，所以还是建议大家设置 whitelist<br></code></pre></td></tr></tbody></table></figure><p><img src="/images/article/gitalk/edit.png"><span class="image-caption">创建Workers</span><br>修改好之后，点击 保存并部署，如果部署正常的话，我们就可以使用我们创建的在线代理了。</p><p>从右侧获取到你的worker域名并记下来，在上面提到_confix.yml文件的proxy配置项修改为如下代码：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">proxy:</span> <span class="hljs-string">https://sakura.cherrywhite.workers.dev/?https://github.com/login/oauth/access_token</span><br></code></pre></td></tr></tbody></table></figure><p>一定要注意连接的地方，要加?,不然会出现no access token的错误<br>还有一个点要注意的是，如果还是有问题，index.js文件可以使用：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">myHeaders.<span class="hljs-title function_">set</span>(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-string">"*"</span>);<br><span class="hljs-comment">// myHeaders.set("Access-Control-Allow-Origin", event.request.headers.get("Origin"));</span><br></code></pre></td></tr></tbody></table></figure><p>重新部署我们的博客，再次点击 使用Github登录，这次登录成功，没有报错。<br>至此，个人在线代理就搭建成功了，博客的评论功能也能正常使用了，撒花！！！</p><h2 id="解决方法（二）"><a href="#解决方法（二）" class="headerlink" title="解决方法（二）"></a>解决方法（二）</h2><p>使用Nginx做一个请求转发服务器 ，在nginx配置文件中加入</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 插入 Gitalk Auth Use 关键点</span><br><span class="hljs-section">location</span> /github {<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">'OPTIONS'</span>) {<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    }<br>    <span class="hljs-attribute">proxy_pass</span> https://github.com/; <span class="hljs-comment"># 注意尾部斜杠不能少</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>前端请求是<a href="https://xxx/github/login/oauth/access_token">https://xxx/github/login/oauth/access_token</a>,<br>而实际请求是<a href="https://github.com/login/oauth/access_token%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A7%A3%E5%86%B3%E4%BA%86%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%82">https://github.com/login/oauth/access_token，所以解决了跨域问题。</a></p><p>Gitalk配置代理，proxy: /github/login/oauth/access_token</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitalk </tag>
            
            <tag> 踩坑 </tag>
            
            <tag> 报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 安装</title>
      <link href="/posts/11880203.html"/>
      <url>/posts/11880203.html</url>
      
        <content type="html"><![CDATA[<h3 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h3><p>Jenkins是一个用Java编写的开源的持续集成工具，提供了软件开发的持续集成服务。</p><h4 id="官方地址"><a href="#官方地址" class="headerlink" title="官方地址"></a><a href="https://www.jenkins.io/zh/">官方地址</a></h4><h3 id="Jenkins安装部署"><a href="#Jenkins安装部署" class="headerlink" title="Jenkins安装部署"></a>Jenkins安装部署</h3><ol><li>安装JDK</li></ol><p>jenkins推荐安装<a href="http://jdk.java.net/java-se-ri/11">JDK11</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 下载JDK<br>wget https://download.java.net/openjdk/jdk11/ri/openjdk-11+28_linux-x64_bin.tar.gz<br><br>// 解压JDK<br>tar -zxvf openjdk-11+28_linux-x64_bin.tar.gz<br><br>// 配置环境变量<br>vim /etc/profile<br><br>// 在/etc/profile底部加入<br><span class="hljs-built_in">export</span> JAVA_HOME=/opt/jdk-11<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">${JAVA_HOME}</span>/lib<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">${PATH}</span>:<span class="hljs-variable">${JAVA_HOME}</span>/bin<br><br>// 刷新文件<br><span class="hljs-built_in">source</span> /etc/profile<br><br>// 查看Java版本是否和下载的一致<br>java -version<br><br>// 我的JDK显示一下信息<br>openjdk version <span class="hljs-string">"11"</span> 2018-09-25<br>OpenJDK Runtime Environment 18.9 (build 11+28)<br>OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>下载Jenkins</li></ol><p><a href="https://www.jenkins.io/zh/download/">根据自己实际情况在官网下载</a></p><p>我使用的是Debian系统，<a href="https://pkg.jenkins.io/debian-stable/">安装过程</a></p><ol start="3"><li>启动jenkins</li></ol><p>启动命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service jenkins start<br></code></pre></td></tr></tbody></table></figure><p>如果启动报错</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Job <span class="hljs-keyword">for</span> jenkins.service failed because the control process exited with error code.<br>See <span class="hljs-string">"systemctl status jenkins.service"</span> and <span class="hljs-string">"journalctl -xe"</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></tbody></table></figure><p>大概率就是/etc/init.d/jenkins文件读取不到JDK</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 打开文件<br>sudo vim /etc/init.d/jenkins<br><br>// 需要在PATH变量加入java的路径 将java路径改成你自己的<br>PATH=/bin:/usr/bin:/sbin:/usr/sbin:/home/sakura/jdk-11/bin<br><br>// 刷新配置<br>sudo systemctl daemon-reload<br><br>// 启动jenkins<br>sudo service jenkins start<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>进入Jenkins</li></ol><p>在浏览器输入 <a href="http://ip:8080/">http://IP:8080</a> 进入 Jenkins 页面</p><p>大概率会看到以下报错</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">AWT is not properly configured on this server. Perhaps you need to run your container with <br><span class="hljs-string">"-Djava.awt.headless=true"</span>? See also: https://www.jenkins.io/redirect/troubleshooting/java.awt.headless<br></code></pre></td></tr></tbody></table></figure><p>就是因为系统没有字体导致的，<a href="https://www.jenkins.io/redirect/troubleshooting/java.awt.headless">需要根据自己系统安装工具</a><br>我的服务器需要安装以下工具</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 安装这个就够了<br>sudo apt-get install fontconfig<br><br>// 实在不行在安装这两个<br>sudo apt-get install ttf-dejavu<br>sudo apt-get install xvfb<br><br>fc-cache --force<br><br>// 重启jenkins<br>sudo service jenkins restart<br></code></pre></td></tr></tbody></table></figure><p>刷新 Jenkins 页面可以看到以下话面<br><img src="/images/article/jenkins/install.png"><span class="image-caption">安装 Jenkins</span></p><p>根据浏览器提示进行找到密码并继续</p><p>选择 安装推荐的插件 安装Jenkins，并等待安装</p><p>插件安装失败不用紧，直接继续就好了，有需要就创建用户，没需要就使用admin账号</p><p>进入jenkins之后最好修改以下admin密码</p><p>admin -&gt; configure 拉到下面可以修改账号密码</p><p>Manage Jenkins -&gt; Manager Plugin -&gt; ADVANCED<br>最下面有 Update Site 设置为：<br><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p><p>修改为中文需要安装插件 Localization: Chinese（Simplified）</p><p>以上就是安装Jenkins的全过程了，如果什么问题可以在下方评论。</p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> ci/cd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-maven插件问题</title>
      <link href="/posts/bf2beecf.html"/>
      <url>/posts/bf2beecf.html</url>
      
        <content type="html"><![CDATA[<p>个人在使用docker-maven-plugin来构建镜像的时候出现报错消息</p><p>报错 Connection reset by peer ，具体错误日志如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs log">[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.2.2:build (default-cli)<br>on project parkinglot: Exception caught: java.util.concurrent.ExecutionException: <br>com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException:<br>com.spotify.docker.client.shaded.org.apache.http.client.ClientProtocolException: <br>Cannot retry request with a non-repeatable request entity: Connection reset by peer -&gt; [Help 1]<br></code></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>oldBookShare<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定 Dockerfile 所在的文件目录 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>${project.basedir}<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>${project.build.directory}<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>${project.build.finalName}.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>解决方法：将图中的oldBookShare改成old-book-share就好了，容器名称不能有大写。</p><p>报错 Permission denied ，具体错误日志如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs log">[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.2.2:build (default-cli)<br>on project tomcat-container: Exception caught: java.util.concurrent.ExecutionException: <br>com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.io.IOException:<br>Permission denied -&gt; [Help 1]<br></code></pre></td></tr></tbody></table></figure><p>遇到了权限不足的情况习惯性的切换到root用户执行，结果一直被阻塞，疯狂打印日志（我所用操作系统：VM-20-7-debian）。<br><a href="https://www.cnblogs.com/goWithHappy/p/solve-docker-maven-permission-deny.html">经过苦苦探寻，最终找到了解决该问题的方法。</a></p><p>/var/run/docker.sock文件,它是默认情况下docker守护程序侦听的UNIX套接字侦听，它可用于与容器内与守护程序通信。 普通用户是没有权限的，先查看docker.sock的文件权限</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ls</span> -al /var/run/docker.sock<br></code></pre></td></tr></tbody></table></figure><p>执行结果如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">srw-rw---- 1 root docker 0 Dec  1 20:42 /var/run/docker.sock<br></code></pre></td></tr></tbody></table></figure><p>发现普通用户果然没有权限操作该文件的，因此考虑修改文件权限，执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> 666 /var/run/docker.sock<br></code></pre></td></tr></tbody></table></figure><p>然后我们重新执行docker的命令发现可以出现正常的结果，服务器重启的时候docker.sock文件可能会恢复，遇到这个问题再修改一下权限就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建静态博客</title>
      <link href="/posts/dfcd98a4.html"/>
      <url>/posts/dfcd98a4.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到<a href="https://cherry-white.github.io/">我的博客</a>! 这是我的第一篇文章。<br>本博客是使用 <a href="https://hexo.io/zh-cn/">Hexo</a> 搭建的静态博客， 主题使用了<a href="https://github.com/zhaoo/hexo-theme-zhaoo">zhaoo</a></p><h2 id="快速建站"><a href="#快速建站" class="headerlink" title="快速建站"></a>快速建站</h2><h3 id="前期装备"><a href="#前期装备" class="headerlink" title="前期装备"></a>前期装备</h3><ol><li>安装 <a href="https://nodejs.org/zh-cn/download/">nodejs</a></li><li>配置nodejs环境变量</li><li>安装Hexo脚手架，代码如下：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br></code></pre></td></tr></tbody></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init <span class="hljs-string">"MyBlog"</span><br>$ <span class="hljs-built_in">cd</span> MyBlog<br>$ npm install<br></code></pre></td></tr></tbody></table></figure><p>更多信息: <a href="https://hexo.io/zh-cn/docs/writing.html">写作</a></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></tbody></table></figure><p>更多信息: <a href="https://hexo.io/zh-cn/docs/server.html">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></tbody></table></figure><p>更多信息: <a href="https://hexo.io/zh-cn/docs/generating.html">生成文件</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></tbody></table></figure><p>更多信息: <a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">部署</a></p><h3 id="加入主题"><a href="#加入主题" class="headerlink" title="加入主题"></a>加入主题</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/zhaoo/hexo-theme-zhaoo.git themes/zhaoo<br></code></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>修改 Hexo 根目录下的 _config.yml 文件启用 zhaoo 主题</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">zhaoo</span><br></code></pre></td></tr></tbody></table></figure><p>具体使用方式：<a href="https://github.com/zhaoo/hexo-theme-zhaoo">查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404 Not Found</title>
      <link href="//404.html"/>
      <url>//404.html</url>
      
        <content type="html"><![CDATA[<h1>    <div style="text-align: center;">        对不起，您所访问的页面不存在或者已删除。<br>        <a href="javascript:toRandomPost()">您可以点击此处，随机看看叭。</a>    </div></h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>Me</p><p>Cherry White</p><p>喜欢动漫游戏</p><p>喜欢折腾各种东西</p><p>热爱编程的程序猿!</p><p>技术栈：</p><ul><li>Unity、C#</li><li>SpringBoot、Laravel</li><li>Linux、Docker、Jenkins</li><li>React、Vue、Angular、Ts</li><li>Mysql、MybatisPlus</li></ul><p>个人经历</p><p>2022.04 - 至今：</p><p>QQ飞车手游项目组 游戏前端开发</p><p>2020.12-2022.04：</p><p>金宝贝早教 前端开发</p><p>毕业于广州大学华软软件学院</p><p>联系方式</p><ul><li>E-Mail：<a href="mailto:cherry.white@qq.com">cherry.white@qq.com</a></li><li>WeChat：wxid_ptoe55mpaqri21</li><li>QQ：1789139001</li><li>Github: <a href="https://github.com/cherry-white">Github</a> 、 <a href="https://gitee.com/zj1789139001">Gitee</a></li><li>Website: <a href="https://cherry-white.github.io/">https://cherry-white.github.io/</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>归档</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>画廊</title>
      <link href="/galleries/index.html"/>
      <url>/galleries/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>动漫</title>
      <link href="/galleries/%E5%8A%A8%E6%BC%AB/index.html"/>
      <url>/galleries/%E5%8A%A8%E6%BC%AB/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>封面</title>
      <link href="/galleries/%E5%B0%81%E9%9D%A2/index.html"/>
      <url>/galleries/%E5%B0%81%E9%9D%A2/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
