<!DOCTYPE html><html lang="zh-CN" color-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>现代游戏引擎 - 游戏引擎中物理系统的基础理论和算法（十） - 樱白</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="google" content="notranslate"><meta name="google-site-verification" content="eQV1-bjl_nNjXCj2YhmaG3IHeUK9wO34JUX--01e0yI"><meta name="msvalidate.01" content="81DEE48B3A7B549DEC6C5C66F0BB05C2"><meta name="google-adsense-account" content="ca-pub-9139831305743788"><meta name="keywords" content="Cherry,White,CherryWhite,博客,个人成长, games104,游戏引擎,物理系统,基础理论,算法"><meta name="description" content="物理系统物理系统是游戏引擎的重要组成部分。 在游戏中玩..."><meta name="author" content="樱白 - Cherry White"><link rel="icon" href="/images/icons/favicon-16x16.ico" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.ico" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.jpg" sizes="180x180"><meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333"><meta rel="msapplication-TileImage" content="/images/icons/favicon-128x128.ico"><meta rel="msapplication-TileColor" content="#000000"><link rel="canonical" href="https://cherry-white.github.io/posts/de5d97c9.html"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/lib/iconfont/iconfont.css"><link rel="stylesheet" href="/lib/fancybox/fancybox.css"><link rel="stylesheet" href="/lib/highlight/a11y-dark.css"><script>var CONFIG=window.CONFIG||{},ZHAOO=window.ZHAOO||{},CONFIG={isHome:!1,fancybox:!0,pjax:!1,loading:{gif:"/images/theme/loading.gif",lottie:""},lazyload:{enable:!0,only_post:"false",loading:{gif:"/images/theme/loading.gif",lottie:""}},donate:{enable:!0,alipay:"/images/pay/alipay.png",wechat:"/images/pay/wechat.jpg"},galleries:{enable:!0},fab:{enable:!0,always_show:!1},carrier:{enable:!0},daovoice:{enable:!1},preview:{background:{default:"",api:"https://api.mtyqx.cn/api/random.php"},motto:{default:"我在开了灯的床头下，想问问自己的心啊。",typing:!0,api:"https://v2.jinrishici.com/one.json",data_contents:'["data","content"]'}},qrcode:{enable:!0,type:"url",image:"https://pic.izhaoo.com/weapp-code.jpg"},toc:{enable:!0},scrollbar:{type:"normal"},notification:{enable:!1,delay:4500,list:"",page_white_list:"",page_black_list:""},search:{enable:!0,path:"search.xml"}}</script><meta name="generator" content="Hexo 7.3.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body class="lock-screen"><div class="loading" id="loading"></div><nav class="navbar"><div class="left"><i class="iconfont iconhome j-navbar-back-home"></i> <i class="iconfont iconqrcode j-navbar-qrcode"></i> <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i> <i class="iconfont iconsearch j-navbar-search"></i></div><div class="center">现代游戏引擎 - 游戏引擎中物理系统的基础理论和算法（十）</div><div class="right"><i class="iconfont iconmenu j-navbar-menu"></i></div><div id="qrcode-navbar"></div></nav><nav class="menu"><div class="menu-container"><div class="menu-close"><i class="iconfont iconbaseline-close-px"></i></div><ul class="menu-content"><li class="menu-item"><a href="/" class="underline">首页</a></li><li class="menu-item"><a href="javascript:toRandomPost()" rel="external nofollow noreferrer" class="underline">随机</a></li><li class="menu-item"><a href="/galleries/" class="underline">画廊</a></li><li class="menu-item"><a href="/archives/" class="underline">归档</a></li><li class="menu-item"><a href="/tags/" class="underline">标签</a></li><li class="menu-item"><a href="/categories/" class="underline">分类</a></li><li class="menu-item"><a href="/about/" class="underline">关于</a></li></ul><div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io" rel="external nofollow noreferrer">Hexo</a> | Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo" rel="external nofollow noreferrer">zhaoo</a></p><p>Cherry White .All Rights Reserved Copyright © 2021</p></div></div></nav><main id="main"><div class="article-wrap"><div class="row container"><div class="col-xl-3"></div><div class="col-xl-6"><article class="article"><div class="wrap"><section class="head"><img   class="lazyload" data-original="/images/background/Physics-System-Basic-Concepts.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false"><div class="head-mask"><h1 class="head-title">现代游戏引擎 - 游戏引擎中物理系统的基础理论和算法（十）</h1><div class="head-info"><span class="post-info-item"><i class="iconfont iconcalendar"></i>二月 20, 2023</span> <span class="post-info-item"><i class="iconfont iconfont-size"></i>6403</span></div></div></section><section class="main"><section class="content"><h2 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h2><p>物理系统是游戏引擎的重要组成部分。 在游戏中玩家和整个游戏世界的互动都是依赖于物理系统的实现，同时在现代游戏中大量的粒子效果也都是通过物理系统来进行驱动的。<br>显然物理系统非常复杂，甚至于有很多公司专门去研究物理引擎的高效实现。 而在本课程中我们同样把物理系统拆分成两节，<br>这一节课主要介绍物理引擎的基本概念而在下一节课中则会更多地讨论游戏业界更前沿的物理仿真技术。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_01.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">物理系统大纲</span></p><h2 id="物理对象与形状"><a href="#物理对象与形状" class="headerlink" title="物理对象与形状"></a>物理对象与形状</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>静态对象：Static</li><li>动态对象：Dynamic</li><li>Trigger：碰撞检测区域</li><li>Kinematic对象：不符合物理原理，玩法逻辑控制</li></ul><h3 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h3><ul><li>球</li><li>胶囊体</li><li>立方体</li><li>凸多边形 Convex Meshes</li><li>三角面</li><li>高度图：多见于地形</li></ul><p><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_02.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">Actor Shapes</span></p><p>当我们利用这些对象去组成实际需要的物体对象时，有两个原则：</p><ul><li>形状接近就好，不一定要完美</li><li>简单性。要尽量用简单的对象去拼接（比如尽量少用三角网格），且越少越好。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_03.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">用物理形状包裹对象</span></li></ul><p>此外，一些比较重要的物理概念：</p><ul><li>质量和密度 Mass and Density</li><li>质心（做载具时很重要）Center of Mass</li><li>摩擦和恢复（弹性） Friction &amp; Restitution</li></ul><h2 id="力于运动"><a href="#力于运动" class="headerlink" title="力于运动"></a>力于运动</h2><h3 id="力"><a href="#力" class="headerlink" title="力"></a>力</h3><p>一般我们把力分成两种：</p><ul><li>Force 可以理解为直接的重力、拉力、摩擦力等</li></ul><p><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_04.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">力</span></p><ul><li>Impulse 冲量，比如说爆炸导致的冲击力等（虽然其实冲量就是力x时间（恒力条件下））</li></ul><p><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_05.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">冲量</span></p><h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>牛顿第一定律：<br>在没有外力作用下，物体保持匀速直线运动<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_06.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">牛顿第一定律</span></p><p>牛顿第二定律：<br>在有外力作用下，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="7.895ex" height="2.636ex" role="img" focusable="false" viewBox="0 -1083 3489.6 1165"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mo" transform="translate(484.3,269) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1026.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2082.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2960.6,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container>（力 = 质量 * 加速度）<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_07.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">牛顿第二定律</span></p><p>在物理引擎中一般无法使用解析的方式来计算物体的运动，因此我们需要一些数值计算方法来进行求解。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_08.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">恒力下的运动</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_09.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">不同力量下的运动</span><br>其中上图中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="8.821ex" height="2.48ex" role="img" focusable="false" viewBox="0 -846 3899 1096"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(270.3,32) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(874,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1235,0)"><g data-mml-node="mo"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g></g><g data-mml-node="mo" transform="translate(1510,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(1899,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">中</text></g><g data-mml-node="mi" transform="translate(2899,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g></g></g></svg></mjx-container>t$是二次积分（位移和时间关系公式就是二次的）</p><p>具体以圆周运动为例，如果简单去模拟物体随时间变化，并不是很困难。<br>但实际游戏中时间不是连续的，而是由一帧帧实现的，所以通常需要解决的问题是在已知当前物体位置和速度的前提下获取之后某时刻的物体位置和速度信息。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_10.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">游戏中的模拟</span></p><h3 id="显示欧拉法-Explicit-Forward-Euler’s-Method"><a href="#显示欧拉法-Explicit-Forward-Euler’s-Method" class="headerlink" title="显示欧拉法 Explicit (Forward) Euler’s Method"></a>显示欧拉法 Explicit (Forward) Euler’s Method</h3><p>在进行数值积分时，我们可以把时间间隔设置成一个比较小的值然后对被积函数进行累加来近似实际的积分。<br>具体来说，在计算物体的运动轨迹时我们首先计算物体在当前位置上受到的力并且积分得到加速度，然后再利用加速度来更新速度以及物体的位置。<br>这种计算物体运动轨迹的方法称为<b>Euler方法(Euler’s method)</b>，也称为<b>显式积分(explicit integration)</b>。<br>Euler方法实现起来非常简单，但需要注意的是它的本质是使用物体的当前状态来估计下一时刻的运动状态，此时系统的能量是不守恒的。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_11.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">显示欧拉法</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_12.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">显示欧拉法2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_13.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">显示欧拉法3</span></p><p>这种方法下，由于实际游戏中的时间片<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.025ex" xmlns="http://www.w3.org/2000/svg" width="2.701ex" height="1.645ex" role="img" focusable="false" viewBox="0 -716 1194 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container>不可能和现实中一样小，所以会导致能量不守恒（实际位移是偏多的），误差越来越大，物体逐渐甩出去。</p><h3 id="隐式欧拉法-Implicit-Backward-Euler’s-Method"><a href="#隐式欧拉法-Implicit-Backward-Euler’s-Method" class="headerlink" title="隐式欧拉法 Implicit (Backward) Euler’s Method"></a>隐式欧拉法 Implicit (Backward) Euler’s Method</h3><p>为了提高数值积分的稳定性，人们还开发出了<b>隐式积分(implicit integration)</b>的技术。<br>隐式积分的实现也很简单，只需要在求解加速度和速度时使用下一时刻而不是当前时刻的值即可， 同时可以证明此时系统的能量会不断衰减。<br>当然这又引入了另一个问题，即如何计算系统在下一时刻的物理量， 这在很多情况下是比较困难的。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_14.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">隐式欧拉法</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_15.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">隐式欧拉法2</span></p><p>其中未来的值是假设能够通过解析解强行算出来的。 和显示方法类似，该方法的问题是能量会衰减，<br>但由于这个衰减相对较慢，所以用户可能会认为是摩擦力、空气阻力等其他力的影响导致，<br>从而使得这个衰减在游戏实际中相对不明显。 从另一个角度来说，我们在游戏引擎中设计中认为衰减肯定是好过增多的，<br>前者顶多最后停下来，但后者会不可控会爆炸。 通过一系列复杂计算可以证明这种隐式方法是无条件稳定的。 但其缺点是：</p><ul><li>计算成本高（计算未来值）</li><li>运动非线性时难以计算</li><li>能量衰减。</li></ul><h3 id="半隐式欧拉法-Semi-implicit-Euler’s-Method"><a href="#半隐式欧拉法-Semi-implicit-Euler’s-Method" class="headerlink" title="半隐式欧拉法 Semi-implicit Euler’s Method"></a>半隐式欧拉法 Semi-implicit Euler’s Method</h3><p>在游戏引擎中更常用的积分方法是半隐式Euler方法(semi-implicit Euler’s method)，<br>即在计算加速度时使用当前时刻的力推导下一时刻的速度，而在计算位置时使用刚才计算出的速度再更新位置。<br>半隐式方法有非常高的数值稳定性，广泛应用于各种类型的物理仿真中。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_16.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">半隐式欧拉法</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_17.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">半隐式欧拉法2</span></p><p>计算未来速度时用当前的力，计算未来位移时用未来的速度。 前提假设：力是不变的（很危险的假设，因为实际上力跟物体位置是相关的）。<br>优点是：</p><ul><li>条件性稳定</li><li>计算简单有效</li><li>随着时间的推移能够保存能量</li></ul><p>缺点是做一些sin cos等运动时，积分出来的周期会比正确值长一点点，所以在相位上会有偏移差。</p><h2 id="刚体动力学"><a href="#刚体动力学" class="headerlink" title="刚体动力学"></a>刚体动力学</h2><p>有了牛顿定律和数值积分算法就可以开始进行物理仿真了，其中最简单的情况是<b>质点动力学(particle dynamics)</b>。<br>在质点动力学中所有的物体都被抽象为没有具体形状的质点，此时我们只需要按照牛顿定律更新质点的运动状态即可。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_18.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">质点动力学</span></p><p>在游戏引擎中更为常见的仿真场景是刚体动力学(rigid body dynamics)。 和质点动力学不同，<br>刚体动力学仿真需要考虑物体自身的形状，也因此需要在质点运动的基础上引入刚体旋转的相关概念。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_19.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">刚体动力学</span></p><h3 id="取向"><a href="#取向" class="headerlink" title="取向"></a>取向</h3><p>刚体的<b>朝向(orientation)</b>可以使用一个旋转矩阵或者四元数来表示，它表示刚体当前姿态相对于初始姿态的旋转。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_20.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">取向</span></p><h3 id="角速度"><a href="#角速度" class="headerlink" title="角速度"></a>角速度</h3><p><b>角速度(angular velocity)</b>表示刚体绕某个旋转轴旋转的速度，需要注意的是在描述角速度时必须要指明旋转轴。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_21.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">角速度</span></p><h3 id="角加速度"><a href="#角加速度" class="headerlink" title="角加速度"></a>角加速度</h3><p><b>角加速度(angular acceleration)</b>类似于加速度，不过它描述的是角速度的变化。<br>这里需要说明的是角速度的变化不仅包括绕当前轴转速的变化，它还包括旋转轴发生变化的情况。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_22.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">角加速度</span></p><h3 id="旋转惯量"><a href="#旋转惯量" class="headerlink" title="旋转惯量"></a>旋转惯量</h3><p><b>转动惯量(rotational inertia)</b>类似于质量，它描述了刚体抵抗旋转的能力。 转动惯量与质量的一大区别在于转动惯量不是一个常数而是一个张量(矩阵)，<br>当刚体的朝向发生改变时需要利用旋转矩阵来计算当前姿态下的转动惯量； 同时转动惯量也与刚体上的质量分布密切相关。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_23.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">旋转惯量</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_24.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">旋转惯量2</span></p><h3 id="角动量"><a href="#角动量" class="headerlink" title="角动量"></a>角动量</h3><p><b>角动量(angular momentum)</b>则描述了刚体旋转的状态，它是转动惯量与角速度的乘积。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_25.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">角动量</span></p><h3 id="力矩"><a href="#力矩" class="headerlink" title="力矩"></a>力矩</h3><p>当外力不通过刚体的质心时会产生<b>力矩(torque)</b>，从而导致刚体发生旋转。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_26.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">力矩</span></p><p>在质点动力学的基础上把旋转部分也考虑进来对物体的运动状态进行更新就得到了刚体动力学的仿真方法。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_27.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">概要</span></p><h3 id="应用：台球动力学"><a href="#应用：台球动力学" class="headerlink" title="应用：台球动力学"></a>应用：台球动力学</h3><p>以台球游戏模拟为例，我们假设台球自身与桌面没有摩擦，这样台球的运动可以简化为二维平面运动。<br>在进行仿真时需要把球杆给予台球的力(冲量)移动到球心来计算台球沿球杆方向的速度；<br>同时这种移动还会对台球施加一个力矩使台球产生旋转，因此也需要更新台球的角速度。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_28.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">应用：台球动力学</span></p><h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>在进行刚体仿真时我们需要考虑不同刚体之间的相互作用，也即所谓的碰撞问题。<br>要求解碰撞问题的第一步是对刚体碰撞进行检测，目前在物理引擎中注意是使用两阶段的检测方法。<br>碰撞检测一般分为两个阶段</p><ul><li>Broad phase 初筛 – 利用AABB等找到刚体有没有相交</li><li>Narrow phase – 获取进一步信息（碰撞点、方向、深度等）</li></ul><p>Broad Phase一般常见的有两种方法：</p><ul><li>BVH Tree – 更新成本低，适合动态场景。</li><li>Sort and Sweep – 先排序再逐个扫描，效率高，更符合大部分为静态物体小部分为动态物体的现实。更好。</li></ul><p><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_29.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">碰撞检测-分为两个阶段</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_30.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">宽相和窄相</span></p><h3 id="宽相"><a href="#宽相" class="headerlink" title="宽相"></a>宽相</h3><p>显然场景中大部分的物体是不会同时发生接触的，因此所谓的broad phase就是只利用物体的bounding box来快速筛选出可能发生碰撞的物体。<br>目前物理引擎中常用的碰撞检测包括<b>空间划分(space partitioning)</b>以及<b>sort and sweep</b>两类方法。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_31.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">宽相</span></p><h4 id="BVH树"><a href="#BVH树" class="headerlink" title="BVH树"></a>BVH树</h4><p>我们在介绍渲染技术时就介绍过空间划分的相关概念，它的思想是把场景中的物体使用一个树状的数据结构进行管理从而加速判断物体是否相交的过程。<br>BVH是空间划分的经典算法，它使用一棵二叉树来管理场景中所有物体的bounding box。 BVH的特点是它可以通过动态更新节点来描述场景中物体的变化，<br>因此可以快速地检测场景中的bounding box可能存在的碰撞。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_32.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">BVH树</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_33.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">BVH树2</span></p><h4 id="排序和扫描"><a href="#排序和扫描" class="headerlink" title="排序和扫描"></a>排序和扫描</h4><p>sort and sweep是使用排序来检测碰撞的算法。 它的思想非常直观：对于使用AABB进行表示的bounding box，<br>两个bounding box出现碰撞时必然会导致它们的边界产生了重叠，而判断是否出现重叠则可以通过对bounding box的边界进行排序来进行计算。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_34.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">排序和扫描</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_35.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">排序和扫描2</span></p><h3 id="窄相"><a href="#窄相" class="headerlink" title="窄相"></a>窄相</h3><p>筛选出可能发生碰撞的物体后就需要对它们进行实际的碰撞检测，这个阶段称为narrow phase。 除了进一步判断刚体是否相交外，<br>在narrow phase中一般还需要去计算交点、相交深度以及方向等信息。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_36.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">窄相的目标</span><br>目前在narrow phase中一般会使用相交测试、Minkowski距离以及分离轴等方法。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_37.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">窄相的方法</span></p><h4 id="基本形状相交测试"><a href="#基本形状相交测试" class="headerlink" title="基本形状相交测试"></a>基本形状相交测试</h4><p>对于一些简单的几何形状可以使用解析的方法来判断它们是否相交并且计算交点的信息。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_38.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">基本形状相交测试</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_39.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">基本形状相交测试2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_40.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">基本形状相交测试3</span></p><h3 id="闵可夫斯基基于差分的方法"><a href="#闵可夫斯基基于差分的方法" class="headerlink" title="闵可夫斯基基于差分的方法"></a>闵可夫斯基基于差分的方法</h3><p>对于凸多边形的情况则可以使用<b>Minkowski差异(Minkowski distance)</b>来判断它们是否相交。<br>在介绍Minkowski距离之前首先要引入<b>Minkowski和(Minkowski sum)</b>的概念：<br>对于两个点集<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2953.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mi" transform="translate(2194.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>，它们的Minkowski和定义为两个集合中任意一对矢量相加后得到的新的点集。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_41.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">闵可夫斯基基于差分的方法</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_42.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">闵可夫斯基和</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_43.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">闵可夫斯基和2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_44.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">闵可夫斯基和3</span></p><p>对于凸多边形，它们的Minkowski和也必为一个凸多边形，而且这个新多边形的顶点也是原始多边形顶点的和。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_45.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">闵可夫斯基和凸多边形</span></p><p>在此基础上我们定义点集<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2953.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mi" transform="translate(2194.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>的Minkowski差异为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.188ex" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>的Minkowski和，<br>即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.188ex" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="9.825ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4342.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mo" transform="translate(2027.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(2416.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3194.7,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(3953.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_46.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">闵可夫斯基差</span></p><p>可以证明当<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="6.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2953.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(916.7,0)"><path data-c="2A01" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM513 478Q513 664 512 664Q504 664 481 660T406 637T313 588Q281 564 255 537T211 483T181 431T161 382T150 342T144 310T141 292H513V478ZM798 588Q758 616 711 634T639 658T602 663L597 664V292H969Q969 293 967 309T960 341T949 381T930 430T900 482T856 537T798 588ZM513 -164V208H141Q142 205 144 189T149 160T158 125T173 83T196 39T229 -9Q249 -34 273 -55T318 -92T363 -119T405 -138T444 -150T475 -158T499 -162T513 -164ZM775 -103Q801 -87 823 -68T863 -30T894 10T919 49T937 88T950 123T959 154T964 180T968 198L969 208H597V-164Q599 -163 616 -161T647 -155T683 -145T728 -128T775 -103Z"></path></g><g data-mml-node="mi" transform="translate(2194.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>相交时，原点必位于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.188ex" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>中。<br>这样判断两个凸多边形是否相交的问题就转化为判断原点是否位于凸多边形<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.188ex" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.808ex" role="img" focusable="false" viewBox="0 -716 2731.4 799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2296" d="M56 250Q56 394 156 488T384 583Q530 583 626 485T722 250Q722 110 625 14T390 -83Q249 -83 153 14T56 250ZM681 278Q669 385 591 463T381 542Q283 542 196 471T96 278V270H681V278ZM275 -42T388 -42T585 32T681 222V230H96V222Q108 107 191 33Z"></path></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>中的问题， 这种问题一般可以使用GJK算法来求解。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_47.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">起源和闵可夫斯基差异</span></p><p>GJK算法的主要流程如下:<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_48.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_49.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_50.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法3</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_51.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法4</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_52.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法5</span></p><p>当GJK算法判断出两个凸多边形相交后还可以进一步计算交点以及深度等信息。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_53.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法6</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_54.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法7</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_55.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">GJK算法8</span><br>使用的方法为GJK算法。可以参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/511164248">https://zhuanlan.zhihu.com/p/511164248</a></p><h3 id="分离轴定理（Separating-Axis-Theorem）"><a href="#分离轴定理（Separating-Axis-Theorem）" class="headerlink" title="分离轴定理（Separating Axis Theorem）"></a>分离轴定理（Separating Axis Theorem）</h3><p><b>分离轴定理(separating axis theorem, SAT)</b>同样是一种计算凸多边形相交的算法，<br>它的思想是平面上任意两个互不相交的图形我们必然可以找到一条直线将它们分隔在两端。<br>对于凸多边形还可以进一步证明必然存在以多边形顶点定义的直线来实现这样的分隔，<br>因此判断凸多边形相交就等价于寻找这样的分隔直线。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_56.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 凸面</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_57.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 重叠的必要性</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_58.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 分离标准</span></p><p>使用SAT判断凸多边形是否相交时需要分别对两个图形的边进行遍历，然后判断另一个图形上的每个顶点是否落在边的同一侧。<br>只要发现存在一条边可以分隔两个图形即说明它们互不相交，否则继续遍历直到用尽所有的边，此时两个图形必然是相交的。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_59.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 2D案例</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_60.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 2D案例2</span></p><p>当图形的位置发生变化时还可以从上一次检测得到的分离轴开始重新进行检测，这样可以进一步提高算法的效率。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_61.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 2D案例优化</span></p><p>对于三维图形的情况则不仅需要考虑面和面的分隔关系，还要考虑边和边的分隔关系。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_62.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">SAT - 3D案例</span></p><h2 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h2><p>完成碰撞检测后就需要对发生碰撞的刚体进行处理，使它们相互分开。目前刚体的碰撞主要有三种处理思路，<br>分别是penalty force、velocity constraints以及position constraints，本节课我们主要介绍前两种处理方法。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_63.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">碰撞解决</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_64.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">碰撞解决方法</span></p><h3 id="施加惩罚力（Applying-Penalty-Force）"><a href="#施加惩罚力（Applying-Penalty-Force）" class="headerlink" title="施加惩罚力（Applying Penalty Force）"></a>施加惩罚力（Applying Penalty Force）</h3><p><b>Penalty force</b>是最直观的碰撞处理方法，它的思想是当两个物体相交后沿反方向分别施加一个排斥力把它们推开。<br>这种方法要求设置比较大的排斥力以及很小的积分时间间隔，否则容易出现非常不符合直觉的碰撞效果，<br>因此现代物理引擎中几乎不会使用penalty force来处理刚体碰撞问题。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_65.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">施加惩罚力</span></p><h3 id="求解约束（Solving-Constraints）"><a href="#求解约束（Solving-Constraints）" class="headerlink" title="求解约束（Solving Constraints）"></a>求解约束（Solving Constraints）</h3><p>目前物理引擎中主流的刚体碰撞处理算法是基于Lagrangian力学的求解方法，它会把刚体之间的碰撞和接触转换为系统的约束，然后求解约束优化问题。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_66.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">求解约束</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_67.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">求解约束2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_68.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">求解速度约束</span></p><h2 id="场景请求"><a href="#场景请求" class="headerlink" title="场景请求"></a>场景请求</h2><p>除了上面介绍过的内容外，在游戏中我们往往还需要对场景中的物体进行一些查询，这些查询操作也需要物理引擎的支持。</p><h3 id="光线投射（Raycast）"><a href="#光线投射（Raycast）" class="headerlink" title="光线投射（Raycast）"></a>光线投射（Raycast）</h3><p><b>Raycast</b>是非常基本的查询操作，我们希望能够获取某条射线在场景中击中的物体。实际上在光线追踪中就大量使用了raycast的相关操作，<br>而在物理引擎中raycast也有大量的应用，比如说子弹击中目标就是使用raycast来实现的。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_69.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">光线投射</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_70.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">光线投射2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_71.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">光线投射3</span></p><h3 id="遮挡（Sweep）"><a href="#遮挡（Sweep）" class="headerlink" title="遮挡（Sweep）"></a>遮挡（Sweep）</h3><p><b>Sweep<b>与</b>Raycast</b>类似，不过在sweep中需要使用有一定几何形态的物体取击中场景中的其它物体<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_72.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">遮挡</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_73.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">遮挡2</span></p><h3 id="重叠（Overlap）"><a href="#重叠（Overlap）" class="headerlink" title="重叠（Overlap）"></a>重叠（Overlap）</h3><p>另一种常用的操作是<b>overlap</b>，此时我们需要判断场景中的物体是否位于某个几何形状中。overlap与碰撞检测非常类似，<br>不过overlap一般只会使用简单的几何体来进行检测。像游戏中爆炸效果的检测就是使用overlap来实现的。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_74.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">重叠</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_75.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">重叠2</span></p><h3 id="碰撞组（Collision-Group）"><a href="#碰撞组（Collision-Group）" class="headerlink" title="碰撞组（Collision Group）"></a>碰撞组（Collision Group）</h3><p>在物理引擎中还需要额外注意对场景中的物体进行分组，这样可以提高各种物理仿真算法的效率。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_76.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">碰撞组</span></p><h2 id="效率、准确性与确定性"><a href="#效率、准确性与确定性" class="headerlink" title="效率、准确性与确定性"></a>效率、准确性与确定性</h2><h3 id="仿真优化（Simulation-Optimization）"><a href="#仿真优化（Simulation-Optimization）" class="headerlink" title="仿真优化（Simulation Optimization）"></a>仿真优化（Simulation Optimization）</h3><p>我们知道物理仿真是极其消耗计算资源的，如果在所有时刻都对场景中的物体进行模拟会造成计算资源的浪费。<br>因此一种常用的手段是把场景中的物体划分为若干个island，当island内没有外力作用时就对它们进行休眠，<br>这样就可以节约计算资源。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_77.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">仿真优化 - 堆</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_78.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">仿真优化 - 休眠</span></p><h3 id="连续碰撞检测（Continuous-Collision-Detection-CCD）"><a href="#连续碰撞检测（Continuous-Collision-Detection-CCD）" class="headerlink" title="连续碰撞检测（Continuous Collision Detection - CCD）"></a>连续碰撞检测（Continuous Collision Detection - CCD）</h3><p>当物体运动的速度过快时可能会出现一个物体之间穿过另一个物体的现象，一种比较质朴的方法就是把墙等物体做的厚一点。<br>更规范的做法就是CCD：先计算一个安全时间（在这个时间内两个物体不会碰撞），然后开始一点点详细计算会不会碰撞，知道它们的距离小于一定阈值。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_79.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">连续碰撞检测</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_80.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">连续碰撞检测2</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_81.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">连续碰撞检测3</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_82.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">连续碰撞检测4</span></p><h3 id="确定性模拟（Deterministic-Simulation）"><a href="#确定性模拟（Deterministic-Simulation）" class="headerlink" title="确定性模拟（Deterministic Simulation）"></a>确定性模拟（Deterministic Simulation）</h3><p>在进行物理仿真时还需要考虑仿真结果的确定性。尽管在编程时我们使用的都是同一套物理定律，<br>在程序运行阶段由于帧率、计算顺序以及浮点数精度等问题容易出现同一个场景在不同终端上产生不同的模拟结果。<br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_83.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">确定性模拟</span><br><img   class="lazyload" data-original="/images/article/Games104/10/Games104_10_84.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">确定性模拟2</span></p><p>总而言之，物理仿真仍然是比较困难的。在现代游戏引擎中还有很多开放问题待我们进行解决。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://peng00bo00.github.io/2022/05/26/GAMES104-NOTES-10.html">参考文章1</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/Jason__Y/article/details/124986719">参考文章2</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV16U4y117VU/?spm_id_from=333.788&vd_source=371bc0e94a8c97f991c4ac20af0b2d53">课程视频</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture10_Physics%20System_Basic%20Concepts.pdf">课件PPT</a></p></section><section class="extra"><ul class="copyright"><li><strong>本文作者：</strong>樱白 - Cherry White</li><li><strong>本文链接：</strong><a href="https://cherry-white.github.io/posts/de5d97c9.html" title="https:&#x2F;&#x2F;cherry-white.github.io&#x2F;posts&#x2F;de5d97c9.html">https:&#x2F;&#x2F;cherry-white.github.io&#x2F;posts&#x2F;de5d97c9.html</a></li><li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener external nofollow noreferrer">BY-NC-SA</a> 许可协议，转载请注明出处！</li></ul><section class="donate"><div id="qrcode-donate"><img   class="lazyload" data-original="/images/pay/alipay.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></div><div class="icon"><a href="javascript:;" rel="external nofollow noreferrer" id="alipay"><i class="iconfont iconalipay"></i></a> <a href="javascript:;" rel="external nofollow noreferrer" id="wechat"><i class="iconfont iconwechat-fill"></i></a></div></section><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/games104/" rel="tag">games104</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" rel="tag">游戏引擎</a></li></ul><nav class="nav"><a href="/posts/be812c00.html"><i class="iconfont iconleft"></i>现代游戏引擎 - 游戏引擎中物理系统的高级应用（十一）</a> <a href="/posts/649819f1.html">现代游戏引擎 - 高级动画技术：动画树、IK和表情动画（九）<i class="iconfont iconright"></i></a></nav></section><section class="comments"><div class="btn" id="comments-btn">查看评论</div><link rel="stylesheet" href="/lib/gitalk/gitalk.css"><div id="gitalk" class="gitalk"></div><script src="/lib/gitalk/gitalk.js"></script><script>const title=window.location.pathname.substring(0,50);window.onload=function(){const e=new Gitalk({clientID:"5d2553717eea46759e10",clientSecret:"4d93ce39e65dd2c5b9e364f75d06efd73c64a8ba",id:title,repo:"cherry-white.github.io",owner:"cherry-white",admin:"cherry-white",proxy:"https://vercel.prohibitorum.top/github_access_token"});$("#comments-btn").on("click",function(){$(this).hide(),e.render("gitalk")})}</script></section></section></div></article></div><div class="col-xl-3"><aside class="toc-wrap"><h3 class="toc-title">文章目录：</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">物理系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BD%A2%E7%8A%B6"><span class="toc-text">物理对象与形状</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6"><span class="toc-text">形状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9B%E4%BA%8E%E8%BF%90%E5%8A%A8"><span class="toc-text">力于运动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9B"><span class="toc-text">力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8"><span class="toc-text">运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%AC%A7%E6%8B%89%E6%B3%95-Explicit-Forward-Euler%E2%80%99s-Method"><span class="toc-text">显示欧拉法 Explicit (Forward) Euler’s Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%AC%A7%E6%8B%89%E6%B3%95-Implicit-Backward-Euler%E2%80%99s-Method"><span class="toc-text">隐式欧拉法 Implicit (Backward) Euler’s Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E9%9A%90%E5%BC%8F%E6%AC%A7%E6%8B%89%E6%B3%95-Semi-implicit-Euler%E2%80%99s-Method"><span class="toc-text">半隐式欧拉法 Semi-implicit Euler’s Method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9A%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6"><span class="toc-text">刚体动力学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%90%91"><span class="toc-text">取向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E9%80%9F%E5%BA%A6"><span class="toc-text">角速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E5%8A%A0%E9%80%9F%E5%BA%A6"><span class="toc-text">角加速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%83%AF%E9%87%8F"><span class="toc-text">旋转惯量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E5%8A%A8%E9%87%8F"><span class="toc-text">角动量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9B%E7%9F%A9"><span class="toc-text">力矩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8F%B0%E7%90%83%E5%8A%A8%E5%8A%9B%E5%AD%A6"><span class="toc-text">应用：台球动力学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-text">碰撞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E7%9B%B8"><span class="toc-text">宽相</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%84%E7%9B%B8"><span class="toc-text">窄相</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%9F%BA%E4%BA%8E%E5%B7%AE%E5%88%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">闵可夫斯基基于差分的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E8%BD%B4%E5%AE%9A%E7%90%86%EF%BC%88Separating-Axis-Theorem%EF%BC%89"><span class="toc-text">分离轴定理（Separating Axis Theorem）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E8%A7%A3%E5%86%B3"><span class="toc-text">碰撞解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%BD%E5%8A%A0%E6%83%A9%E7%BD%9A%E5%8A%9B%EF%BC%88Applying-Penalty-Force%EF%BC%89"><span class="toc-text">施加惩罚力（Applying Penalty Force）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E7%BA%A6%E6%9D%9F%EF%BC%88Solving-Constraints%EF%BC%89"><span class="toc-text">求解约束（Solving Constraints）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%AF%B7%E6%B1%82"><span class="toc-text">场景请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84%EF%BC%88Raycast%EF%BC%89"><span class="toc-text">光线投射（Raycast）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%AE%E6%8C%A1%EF%BC%88Sweep%EF%BC%89"><span class="toc-text">遮挡（Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%EF%BC%88Overlap%EF%BC%89"><span class="toc-text">重叠（Overlap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E7%BB%84%EF%BC%88Collision-Group%EF%BC%89"><span class="toc-text">碰撞组（Collision Group）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E3%80%81%E5%87%86%E7%A1%AE%E6%80%A7%E4%B8%8E%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="toc-text">效率、准确性与确定性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E7%9C%9F%E4%BC%98%E5%8C%96%EF%BC%88Simulation-Optimization%EF%BC%89"><span class="toc-text">仿真优化（Simulation Optimization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%EF%BC%88Continuous-Collision-Detection-CCD%EF%BC%89"><span class="toc-text">连续碰撞检测（Continuous Collision Detection - CCD）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%A8%A1%E6%8B%9F%EF%BC%88Deterministic-Simulation%EF%BC%89"><span class="toc-text">确定性模拟（Deterministic Simulation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li></ol></aside></div></div></div></main><footer class="footer"><div class="footer-social"><a href="tencent://message/?Menu=yes&uin=1789139001" target="_blank" class="footer-social-item" onmouseover='this.style.color="#12B7F5"' onmouseout='this.style.color="#33333D"'><i class="iconfont iconQQ"></i> </a><a href="/images/contact/wechat.jpg" target="_blank" class="footer-social-item" onmouseover='this.style.color="#09BB07"' onmouseout='this.style.color="#33333D"'><i class="iconfont iconwechat-fill"></i> </a><a href="https://cherry-white.github.io/" target="_blank" class="footer-social-item" onmouseover='this.style.color="#DA2E76"' onmouseout='this.style.color="#33333D"'><i class="iconfont iconinstagram"></i> </a><a href="https://gitee.com/zj1789139001" target="_blank" class="footer-social-item" onmouseover='this.style.color="#9f7be1"' onmouseout='this.style.color="#33333D"'><i class="iconfont icongithub-fill"></i> </a><a href="mailto:1789139001@qq.com" target="_blank" class="footer-social-item" onmouseover="this.style.color=#FF3B00" onmouseout='this.style.color="#33333D"'><i class="iconfont iconmail"></i></a></div><div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io" rel="external nofollow noreferrer">Hexo</a> | Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo" rel="external nofollow noreferrer">zhaoo</a></p><p>Cherry White .All Rights Reserved Copyright © 2021</p></div></footer><div class="fab fab-plus"><i class="iconfont iconplus"></i></div><a href="https://support.qq.com/product/368715" rel="external nofollow noreferrer" target="_blank"><div class="fab fab-tencent-chao"><i class="iconfont iconcomment"></i></div></a><div class="fab fab-up"><i class="iconfont iconcaret-up"></i></div><script src="/js/color-mode.js"></script><div class="search"><div class="search-container"><div class="search-close"><i class="iconfont iconbaseline-close-px"></i></div><div class="search-input-wrapper"><i class="search-input-icon iconfont iconsearch"></i> <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off" autocorrect="off" autocapitalize="off"></div><div class="search-output" id="search-output"></div></div></div></body><script src="/lib/jquery/jquery.js"></script><script src="/lib/lazyload/lazyload.js"></script><script src="/lib/fancybox/fancybox.js"></script><script src="/lib/qrcode/qrcode.js"></script><script src="/js/utils.js"></script><script src="/js/script.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}()</script><script defer src="https://hm.baidu.com/hm.js?3cbbee458915615f7e2e5b7a073f2113"></script><script src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script><script src="/random.js"></script></html>